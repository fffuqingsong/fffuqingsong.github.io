<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式</title>
      <link href="/archives/364ea8cc.html"/>
      <url>/archives/364ea8cc.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>源码中体现各种设计模式的思想,学好设计模式有利于提高我们阅读源码的能力, 有利于代码的设计</code></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><blockquote><p>一个类只能存在<code>一个实例</code>, 通过单例模式创建的类只能有一个实例</p><p>特点</p><ol><li>单例模式能保证在一个JVM中, 该对象只有一个实例存在</li><li>该类的<code>构造器</code>必须<code>私有</code>, 外部无法通过调用构造器创建实例对象</li><li><code>没有</code>公开的<code>set</code>方法, 外部无法调用set方法创建实例</li><li>通过公开的<code>静态</code>的<code>get方法</code>获取实例</li></ol><p>好处</p><ol><li>对于创建少的大对象, 我们反复的创建很消耗系统的性能</li><li>省去大量new操作符, <code>降低内存</code>使用频率, <code>减轻GC</code>压力</li><li>对于一些类, 如系统的流程处理类, 是不允许创建多个对象的, 这个时候我们就可以用到单例模式</li></ol></blockquote><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个实例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法，防止被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态get方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么它叫饿汉式呢, 因为它饿, 所以它<code>迫不及待</code>, 所以饿汉式就<code>先</code>把唯一的实例<code>创建</code>出来, 在外部第一次获取这个类的时候, 实例就已经存在了, 省去了创建对象的步骤</p></blockquote><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么叫懒汉式呢, 因为<code>它懒</code>, 等事情来了才开始做, <code>先不创建</code>实例, 先不干活, 等第一个人来要实例的时候, 它才去创建实例.</p><p>饿汉式和懒汉式区别</p><ol><li>首次创建实例的消耗</li><li><code>懒汉式线程不安全</code></li></ol></blockquote><h3 id="解决懒汉式线程安全问题"><a href="#解决懒汉式线程安全问题" class="headerlink" title="解决懒汉式线程安全问题"></a>解决懒汉式线程安全问题</h3><blockquote><p>两个线程可能会<code>都</code>进入了 <code>if 中</code>, 导致<code>创建了多个实例</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法加锁解决</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法，防止被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态get方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>方法上加锁会导致<code>性能慢</code></p><p>那我们就在方法中对代码块加锁, <code>双检锁</code>, 这样只需要在第一次创建实例的时候加锁, 其他情况下都无需加锁了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//先检查实例是否存在，如果不存在才进入下面的同步块</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步块，线程安全的创建实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//再次检查实例是否存在，如果不存在才真正的创建实例</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>instance = new Singleton() -&gt;<code>不是原子性</code>的操作, 这是两步操作, 创建对象和赋值是分开的 一个线程去创建实例, JVM给<code>分配了内存空间</code>, <code>但还没进行赋值</code> 这个时候另外一个线程来了, 发现实例不为Null, 直接返回实例, 用的时候发现没有初始化赋值, 直接<code>报错</code></p><p>实例属性加上 volatile 关键字修饰, <code>防止指令重排</code>, 使其他线程可见本线程的操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//先检查实例是否存在，如果不存在才进入下面的同步块</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步块，线程安全的创建实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//再次检查实例是否存在，如果不存在才真正的创建实例</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>volatile会屏蔽掉JVM的一些内存代码优化, 因为防止指令重排, 而指令重排就是为了优化代码的</p><p>为了更好的实现, 我们使用内部类的方式实现</p><p>因为当一个<code>类的加载</code>的时候, <code>线程是互斥</code>的, 所以加载内部类的时候, 线程是互斥的, 所以可以<code>避免线程安全</code>问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 私有构造方法，防止被实例化 */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 此处使用一个内部类来维护单例 */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonFactory</span> &#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取实例 */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonFactory.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> getInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></blockquote><h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><blockquote><p>为什么不用静态方法而用单例模式？</p><ul><li>因为<code>静态方法</code>只<code>基于对象</code>, 而<code>单例模式</code>是基于<code>面向对象</code>, 因为类中的很多属性是通过面向对象的编码方式获取的, 所以我们用单例模式更适合</li></ul></blockquote><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><blockquote><p>在Java的世界中, 万事万物皆为对象, 如果创建对象的时候, 我们直接去New对象, 那我们本对象与对象之间的耦合性就很高, A对象中想使用B对象我们就要去new, 这样耦合度是很高的, 我们怎么解决呢, 我们可以搞一个第三方, 第三方的工厂, 我们需要什么对象我们直接去工厂拿就行, <code>创建对象的工作交给工厂</code>, 这样就实现了<code>解耦</code></p></blockquote><h3 id="OCP开闭原则"><a href="#OCP开闭原则" class="headerlink" title="OCP开闭原则"></a>OCP开闭原则</h3><blockquote><p>一个类对外提供扩展, <code>不能</code>因为需求的<code>改</code>变去改变类的<code>源代码</code>, 应该通过<code>新增代码的方式</code>实现新的需求, 实现<code>可扩展性</code>, 控制需求变动引发的风险, 缩小维护的成本</p></blockquote><h3 id="无工厂模式"><a href="#无工厂模式" class="headerlink" title="无工厂模式"></a>无工厂模式</h3><blockquote><p>自己创建, 自己调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;奥迪在跑&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BYD</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;比亚迪在跑&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client01</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Car</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Audi</span>();</span><br><span class="line">     <span class="type">Car</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BYD</span>();</span><br><span class="line">     a.run();</span><br><span class="line">     b.run();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><blockquote><p>别人创建我调用, 还是违反了开闭原则, 还是需要修改源代码</p><p>一个工厂只有一个生产方法, 可以通过判断生产<code>多个产品</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奥迪在跑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BYD</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;比亚迪在跑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line"> <span class="comment">//方式一</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">getCar</span><span class="params">(String type)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;奥迪&quot;</span>.equals(type)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Audi</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;比亚迪&quot;</span>.equals(type)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BYD</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">a</span> <span class="operator">=</span> CarFactory.getCar(<span class="string">&quot;奥迪&quot;</span>);</span><br><span class="line">        a.run();</span><br><span class="line">        <span class="type">Car</span> <span class="variable">b</span> <span class="operator">=</span> CarFactory.getCar(<span class="string">&quot;比亚迪&quot;</span>);</span><br><span class="line">        b.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><blockquote><p>一个工厂只有一个生产方法, 只能生产<code>一个产品</code></p><p>缺点在于每增加一种产品都需要创建一个新的工厂</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFactory</span> &#123;</span><br><span class="line">IProduct <span class="title function_">getProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryA1</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> IProduct <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ProductA1</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductA1</span>();</span><br><span class="line">product.produce();</span><br><span class="line"><span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryA2</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> IProduct <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ProductA2</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductA2</span>();</span><br><span class="line">product.produce();</span><br><span class="line"><span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryB1</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> IProduct <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ProductB1</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductB1</span>();</span><br><span class="line">product.produce();</span><br><span class="line"><span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryB2</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> IProduct <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ProductB2</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductB2</span>();</span><br><span class="line">product.produce();</span><br><span class="line"><span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><blockquote><p>与工厂方法一样, 每增加一种产品都需要再创建一个工厂</p><p>不同的是, 工厂方法是一个生产方法只能创建一个产品 -&gt; 只能创建6寸的屏幕</p><p>而抽象工厂是一个生产方法能创建<code>多个同系列的产品</code> -&gt; 6寸, 5寸..的屏幕</p></blockquote><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><blockquote><p>代理模式是<code>给</code>一个<code>对象提供</code>一个<code>代理对象</code>, 由代理对象控制对原对象的引用, 我们可以在代理对象上进行原对象的扩展, 降低耦合性, 代理对象类似于中介, 我想租房, 但我还要去找房子很麻烦, 所以我直接通过中介租房, 我和房东不建立直接的联系, <code>中介</code>可以对房东的房子进行美化, 这就叫扩展.</p></blockquote><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><blockquote><ol><li>在某些情况下, <code>客户端</code>不想或不能直接引用一个对象, 而代理对象可以在其中间, <code>代理类</code>和<code>委托类</code>之间实现相同的接口</li><li>代理类除了是客户类和委托类之间的中介外, 还可以<code>对代理类增加额外的功能</code>实现对委托类的扩展, 这样的话, 我们只需要修改代理类, <code>不需要</code>直接去<code>修改委托类</code>, <code>符合开闭原则</code>.</li><li>我们可以在代理类中对委托类的业务之前和之后加入一些功能, 比如加缓存, 打印日志等, 都可以通过代理类实现, 没必须修改封装好的委托类</li></ol></blockquote><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>含义</p><ul><li>手动的方式实现代理类, 以及对委托类功能的扩展</li><li>代理类和委托类继承同一个方法, 在代理类中使用委托类的属性, 对委托类指定功能方法前后增加一些功能</li></ul><p>缺点</p><ul><li>我们要<code>为每一个委托类都创建一个代理类</code>, 不易管理</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BuyHouse</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buyHouse</span><span class="params">()</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//委托类实现此接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyHouseImpl</span> <span class="keyword">implements</span> <span class="title class_">BuyHouse</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyHouse</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;我要买房&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//代理类实现此接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyHouseProxy</span> <span class="keyword">implements</span> <span class="title class_">BuyHouse</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BuyHouse buyHouse;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BuyHouseProxy</span><span class="params">(<span class="keyword">final</span> BuyHouse buyHouse)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.buyHouse = buyHouse;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyHouse</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;买房前准备&quot;</span>);  </span><br><span class="line">        buyHouse.buyHouse();  </span><br><span class="line">        System.out.println(<span class="string">&quot;买房后装修&quot;</span>);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></blockquote><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><blockquote><p> 不需要手动创建代理类, 只需要编写动态处理器就行,<code> 一个代理类可以代理多个委托类</code></p></blockquote><h4 id="普通版"><a href="#普通版" class="headerlink" title="普通版"></a>普通版</h4><blockquote><p>1.Java类</p><ul><li>依次创建UserDao<code>接口</code>,UserDaoImpl<code>实现类</code></li><li>解释: 我们要实验JDK动态代理,此代理是基于在存在接口的情况下使用的,所以我们要先”创建一个接口”</li><li>接口中定义一个方法,我们再创建此接口的”实现类”,重写接口的方法,然后我们再利用<code>动态代理</code>实现对此方法在不修改其方法源码的情况下对方法进行的增加功能操作.</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserDao接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserDaoImpl实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建<code>InvocationHandler接口</code>的实例化对象(写具体的增强部分)</p><p>​    为什么</p><ul><li>动态代理的具体的增强部分代码是在InvocationHandler接口中的invoke方法中写的,所以我们要实现此接口写具体的增强代码</li></ul><p>​    具体要做什么:</p><ul><li>要让接口实例知道我需要对谁进行增强,所以我们要把要实现动态代理的接口告诉我</li><li>在invoke方法中写具体的我要做什么的代码(具体的增强代码)</li></ul><p>​    需要知道什么:</p><ul><li>invoke(Object proxy, Method method, Object[] args)</li><li>第一个参数:代理类的对象,对代理类中的invoke进行实例化,只存在于内存中的类</li><li>第二个参数:代理对象,代理哪个接口的方法,的实例方法</li><li>第三个参数:代理对象,代理哪个接口的方法,的实例方法,的参数列表</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">UserDao userDao;</span><br><span class="line"><span class="comment">//代理对象代理哪个接口,就把这个接口传递进来,执行接口实例方法的时候反射要用到method.invoke</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(UserDao userDao)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable  &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法执行之前</span></span><br><span class="line">  System.out.println(<span class="string">&quot;方法执行之前执行...&quot;</span> + method.getName() + <span class="string">&quot;传递的参数为:&quot;</span> +              Arrays.toString(args));</span><br><span class="line">  <span class="comment">//方法执行中(得到方法的加法的返回值)</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(userDao, args);</span><br><span class="line">  <span class="comment">//方法执行后</span></span><br><span class="line">  System.out.println(<span class="string">&quot;方法执行后执行...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> invoke;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建测试类</p><ul><li>newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</li><li>第一个参数:被代理类的类加载器,就是接口的类加载器,代理类代理的是UserDao接口</li><li>第二个参数:代理类要实现的接口数组,不是UserDao接口的接口数组</li><li>第三个参数:处理器,每个代理类对象都有一个实现InvocationHandler(调用处理程序)接口的实例类Handler,Handler类中的invoke方法就是代理类对象实际调用的处理器,对所代理的类的方法进行增强功能.</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">JDKProxyTest1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//被代理的类的类加载器(UserDao类加载器)</span></span><br><span class="line"> <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> UserDao.class.getClassLoader();</span><br><span class="line"> <span class="comment">//被代理的类的所以实现接口的class对象,在方法内部会克隆一份给代理类的内部(Proxy类的内部)</span></span><br><span class="line"> Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line"> <span class="comment">//获取代理的类的实现类对象</span></span><br><span class="line"> <span class="type">UserDaoImpl</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"> <span class="comment">//InvocationHandler接口实例化对象</span></span><br><span class="line"> <span class="type">UserDaoProxy</span> <span class="variable">userDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao);</span><br><span class="line"> <span class="comment">//获取代理类(Proxy)对象</span></span><br><span class="line"> <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao)Proxy.newProxyInstance</span><br><span class="line">     (classLoader, interfaces, userDaoProxy);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//打印接口方法的实例化方法的结果</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> userDao1.add(<span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="Pro版"><a href="#Pro版" class="headerlink" title="Pro版"></a>Pro版</h4><blockquote><ul><li>区别:pro版本不实例化接口,也就是<code>不创建UserDao接口</code>的实例化类</li></ul><p>InvocationHandler接口的实例化对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy2</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//方法执行之前</span></span><br><span class="line">  System.out.println(<span class="string">&quot;方法执行之前执行...&quot;</span> + method.getName() + <span class="string">&quot;传递的参数为:&quot;</span> + Arrays.toString(args));</span><br><span class="line">     <span class="comment">//方法执行中(得到方法的加法的返回值)</span></span><br><span class="line">     <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(<span class="keyword">new</span> <span class="title class_">UserDao2</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> a + b;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, args);</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//方法执行后</span></span><br><span class="line">  System.out.println(<span class="string">&quot;方法执行后执行...&quot;</span>);</span><br><span class="line">   </span><br><span class="line">     <span class="keyword">return</span> invoke;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">JDKProxyTest2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//被代理的类的类加载器(UserDao类加载器)</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> UserDao2.class.getClassLoader();</span><br><span class="line"> <span class="comment">//被代理的类的所以实现接口的class对象,在方法内部会克隆一份给代理类的内部(Proxy类的内部)</span></span><br><span class="line"> Class[] interfaces2 = &#123;UserDao2.class&#125;;</span><br><span class="line"> <span class="comment">//InvocationHandler接口实例化对象</span></span><br><span class="line"> <span class="type">UserDaoProxy2</span> <span class="variable">userDaoProxy2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy2</span>();</span><br><span class="line"> <span class="comment">//获取代理类(Proxy)对象</span></span><br><span class="line"> <span class="type">UserDao2</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao2)Proxy.newProxyInstance</span><br><span class="line">   (classLoader2, interfaces2, userDaoProxy2);</span><br><span class="line"> <span class="comment">//打印接口方法的实例化方法的结果</span></span><br><span class="line">   System.out.println(userDao2.add(<span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="Puls版"><a href="#Puls版" class="headerlink" title="Puls版"></a>Puls版</h4><blockquote><ul><li>区别:<code>不创建</code>处理器<code>实例化类</code>,就是不创建UserDaoProxy3</li></ul><p>测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">JDKProxyTest3</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//被代理的类的类加载器(UserDao类加载器)</span></span><br><span class="line">   <span class="type">ClassLoader</span> <span class="variable">classLoader3</span> <span class="operator">=</span> UserDao3.class.getClassLoader();</span><br><span class="line">     <span class="comment">//被代理的类的所以实现接口的class对象,在方法内部会克隆一份给代理类的内部(Proxy类的内部)</span></span><br><span class="line">     Class[] interfaces3 = &#123;UserDao3.class&#125;;</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//获取代理类(Proxy)对象</span></span><br><span class="line">  <span class="type">UserDao3</span> <span class="variable">userDao3</span> <span class="operator">=</span> (UserDao3)Proxy.newProxyInstance</span><br><span class="line">         (classLoader3, interfaces3,(proxy,method,args) -&gt; &#123;   </span><br><span class="line">   </span><br><span class="line">          <span class="comment">//方法执行之前</span></span><br><span class="line">      System.out.println(<span class="string">&quot;方法执行之前执行...&quot;</span> + method.getName() + </span><br><span class="line">             <span class="string">&quot;传递的参数为:&quot;</span> + Arrays.toString(args));</span><br><span class="line">         <span class="comment">//方法执行中(得到方法的加法的返回值)</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(<span class="keyword">new</span> <span class="title class_">UserDao3</span>() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">                 System.out.println(<span class="string">&quot;方法正在执行中...&quot;</span>);</span><br><span class="line">                 <span class="keyword">return</span> a + b;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;, args);</span><br><span class="line">         <span class="comment">//方法执行后</span></span><br><span class="line">         System.out.println(<span class="string">&quot;方法执行后执行...&quot;</span>);</span><br><span class="line">         <span class="comment">//返回invoke方法结果值</span></span><br><span class="line">         <span class="keyword">return</span> invoke;&#125;);</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//打印接口方法的实例化方法的结果</span></span><br><span class="line">  System.out.println(userDao3.add(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h3><blockquote><p>对于<code>没有实现接口的类</code>我们怎么实现动态代理呢, 这个时候就需要用到<code>CGLib动态代理</code>, CGLib底层采用了<code>字节码技术</code>, 原理是通过字节码技术为一个类创建子类, 在子类中对父类的方法进行拦截, <code>横切逻辑</code>, Spring AOP 的基础就是 JDK动态代理和CGLib动态代理.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/archives/b7e144d1.html"/>
      <url>/archives/b7e144d1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210202007961.gif" alt="20210711220009741"></p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><ol><li>总共有<code>两层循环</code>, 外层循环为<code>轮次数</code>, 内层循环为每轮中的元素<code>对比次数</code>.</li><li>排序规则为, 我们先拿第一个元素和容器中的每一个元素进行对比, 一轮对比选举出最大值或者最小值放在容器最末尾,第一轮元素对比的次数是最多的一轮, 往后的每一轮对比次数-1, 因为进行一轮就选举出了一个最值, 我们下轮对比就不用和选出的最值进行对比了</li><li>耗费的时间复杂度为<code>O(N²)</code>, 随着数组元素长度的变大, 算法所执行的步骤成倍的增加.</li></ol></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span> -j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i] &gt; a[ i + <span class="number">1</span> ])&#123;</span><br><span class="line">                    b = a[i];</span><br><span class="line">                    a[i] = a[i+<span class="number">1</span>];</span><br><span class="line">                    a[i+<span class="number">1</span>] = b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210211622398.gif" alt="快排"></p></blockquote><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><ol><li>在序列中先确定一个<code>基准数</code>, 为了方便我们直接选取序列左方第一个数字作为基数</li><li>然后我们将大于基数的数字放在基数的右边, 小于基数的数字放在基数的左边,</li><li>怎么实现呢, 我们使用两个哨兵, 哨兵A和哨兵B, 让A站在序列的最左方, B在最右方, 然后先让哨兵B<code>向左边</code>寻找小于基数的数, 如果找到了就停下来让哨兵A<code>向右</code>寻找大于基数的数字, 如果找到了就<code>停</code>下来, 然后<code>交换</code>AB所在的数字</li><li>交换完毕后B继续向左寻找, 知道找到停下, 然后让A先右寻址, 然后交换, 一直这样重复, 直到哨兵<code>AB相遇</code>, 站在了同一个位置上, 这时我们将基数与AB相遇的位置上的数进行<code>交换</code>.</li><li>随后我们以基数的位置为中心, 分割序列, 让基数的左右两边各分割为新的序列, 然后递归调用左半序列, 右半序列<code>重复</code>上方的操作, 直到<code>无法拆分</code>出新的子序列, 到此排序结束</li><li>快速排序之所以快, 是因为每次交换都是跳跃式的, 不像冒牌是相邻的两个数交换, 总的比较和交换次数就相较于冒泡少了很多, 因此快排的最差时间复杂度和冒泡一样是<code>O(N²)</code>平方级别, 平均复杂度为<code>O(logN)</code>对数级别, 快排是基于一种二分的思想</li></ol></blockquote><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] data, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i, j, temp, t;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = low;</span><br><span class="line">        j = high;</span><br><span class="line">        <span class="comment">//temp就是基准位</span></span><br><span class="line">        temp = data[low];</span><br><span class="line">        System.out.println(<span class="string">&quot;基准位：&quot;</span> + temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">//先看右边，依次往左递减</span></span><br><span class="line">            <span class="keyword">while</span> (temp &lt;= data[j] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再看左边，依次往右递增</span></span><br><span class="line">            <span class="keyword">while</span> (temp &gt;= data[i] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果满足条件则交换</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;交换：&quot;</span> + data[i] + <span class="string">&quot;和&quot;</span> + data[j]);</span><br><span class="line">                t = data[j];</span><br><span class="line">                data[j] = data[i];</span><br><span class="line">                data[i] = t;</span><br><span class="line">                System.out.println(java.util.Arrays.toString(data));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后将基准位与i和j相等位置的数字交换</span></span><br><span class="line">        System.out.println(<span class="string">&quot;基准位&quot;</span> + temp + <span class="string">&quot;和i、j相遇的位置&quot;</span> + data[i] + <span class="string">&quot;交换&quot;</span>);</span><br><span class="line">        data[low] = data[i];</span><br><span class="line">        data[i] = temp;</span><br><span class="line">        System.out.println(java.util.Arrays.toString(data));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归调用左半数组</span></span><br><span class="line">        quickSort(data, low, j - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//递归调用右半数组</span></span><br><span class="line">        quickSort(data, j + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span>[] data = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>&#125;;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;排序之前：\n&quot;</span> + java.util.Arrays.toString(data));</span><br><span class="line"></span><br><span class="line">            quickSort(data, <span class="number">0</span>, data.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;排序之后：\n&quot;</span> + java.util.Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210211811243.gif" alt="eb648f86b4ada5b32afc7a52e78d9953"></p></blockquote><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><blockquote><ol><li>前提此序列中的元素一定是<code>有序</code>的, 假设序列是升序的的</li><li>首先我们用两个变量分别存储序列<code>首索引</code>和<code>尾索引</code>, 取序列的<code>中间值</code></li><li>如果我们要查找的元素大于中间值, 我们就去中间值的右边去找, 首元素 = 中间值 + 1</li><li>如果我们要查找的元素小于中间值, 我们就去中间值的左边去找, 尾元素 = 中间值 - 1</li><li>怎么找呢, 我们重复上方的步骤, 依旧对左右序列分别各自取中间值</li><li>知道找到我们要查询的元素</li></ol></blockquote><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> indices 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lookup1 查找的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">extracted</span><span class="params">(<span class="type">int</span>[] indices, <span class="type">int</span> lookup1)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">judge</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//定义变量存放首索引,和尾索引值;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> indices.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用while循环,当首索引大于小于等于尾索引值的时候进入循环</span></span><br><span class="line">    <span class="keyword">while</span>(first &lt;= tail)&#123;</span><br><span class="line">        <span class="comment">//注意是首索引值+尾索引值再/2得到中间值,不是直接用尾索引值/2,那样的值不正确,逻辑错误</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (first + tail)  / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果中间值刚好等于我们需要查询的值,输出中间索引值</span></span><br><span class="line">        <span class="keyword">if</span> (indices[middle] == lookup1)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到了,索引值为:&quot;</span> + middle);</span><br><span class="line">            judge = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (indices[middle] &gt; lookup1)&#123;</span><br><span class="line">            <span class="comment">//否则如果中间值大于我们需要查找的值,我们把尾索引值重新赋值</span></span><br><span class="line">            tail = middle - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//否则中间值小于我们需要查找的值,我们把首索引值重新赋值</span></span><br><span class="line">            first = middle + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!judge)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有找到!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/archives/79666db.html"/>
      <url>/archives/79666db.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.程序 = 数据结构 + 算法</span><br><span class="line">2.数据结构是算法的基础</span><br></pre></td></tr></table></figure></blockquote><h2 id="时间和空间复杂度"><a href="#时间和空间复杂度" class="headerlink" title="时间和空间复杂度"></a>时间和空间复杂度</h2><blockquote><p>时间复杂度: 衡量一个算法所占<code>时间</code>长不长</p><p>空间复杂度: 衡量一个算法所占<code>内存</code>多不多</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><ol><li>假设一个<code>算法</code>, 它去访问一个<code>容器</code>的一个<code>元素</code>,如果这个容器的元素<code>长度为N</code>, 这个算法执行的步骤为<code>N步</code>, 那我们就称此算法的时间复杂度为<code>O(N)</code></li><li><code>大O括号</code>中的数字并<code>不</code>像数学那样<code>准确</code>,例如一个算法, 访问一个容器中的元素, 遍历了<code>两次</code>容器才访问到, 那此算法的时间复杂度为<code>O(2N)</code>, 但我们一般不会这样表示,我们会<code>省略常数</code>,</li><li>再比如说<code>O(1)</code>, 我们其实知道不可能有一个算法只执行一步就能查到某一个元素, 它应该是<code>执行了好几步</code>, 可能是5步,8步, 它的<code>步数是恒定</code>的与容器的元素<code>长度无关</code>,所以它是O(1)</li><li>一个算法在容器的<code>不同输入</code>下所耗费的步数可能是完全不同的, 例如<code>有序</code>输入的容器和<code>无序</code>输入的容器, 算法对这两个容器会呈现出<code>不同的时间复杂度</code>, 我们一般取耗费时间最多的那个作为标准.</li></ol></blockquote><h3 id="级别"><a href="#级别" class="headerlink" title="级别"></a>级别</h3><blockquote><p>**O(1)**常数级别</p><p>无论容器元素长度的大小, 它执行的步数是<code>恒定</code>的, 不会因为容器元素长度的变大而变大, <code>哈希表</code>就是这个级别.</p><p>**O(N)**线性级别</p><p>随着容器元素长度的变大, 算法所执行的步数也会<code>正向的增加</code>, <code>遍历</code>算法就是这个级别.</p><p>**O(logN)**对数级别</p><p>对于容器元素的长度每<code>增加一倍</code>, 算法所执行的步数<code>+1</code>, <code>二分法</code>就是这个级别</p><p>**O(N²)**平方级别</p><p>随着容器元素长度的变大, 算法所执行的步骤<code>成倍</code>的增加, 双层for循环, <code>冒泡排序</code>就是这个级别.</p></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210201914129.png" alt="image-20221020191401087"></p></blockquote><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><ol><li>数组是一种可以快速访问的数据结构,所有的编程语言内置都支持数组,数组在内存中是一块<code>连续的内存地址</code></li><li>数组作为容器可以<code>方便</code>的存储成百上千的元素,如果没有数组,我们存储嫩么多的元素需要成百上千个引用</li><li>每一个数组都有一个地址, 我们可以通过数组的下标计算出每个数组元素所在的内存地址, 从而实现快速的访问, 所以通过<code>下标方式</code>查找元素的效率是<code>O(1)</code>级别</li><li>在数组的尾部插入和删除一个元素没问题, 但如果在数组的其他位置<code>插入或删除</code>一个元素, 我们需要对数组的其他元素的<code>位置进行调整</code></li><li>当数组已经满后, 就<code>无法</code>再继续<code>添加</code>元素, 数组无法动态扩容, 解决这个问题我们需要用到<code>动态数组</code>, Array List就是一个动态数组, 当动态数组的元素长度到达某一个临界点的时候, 动态数组会创建一个更大的数组, 将原来的数组元素<code>复制</code>过去.</li><li>动态数组在具有自动扩容功能的同时,也带来了元素复制的代价</li></ol></blockquote><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><h4 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h4><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210201914177.png" alt="image-20221020191434134"></p></blockquote><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><blockquote><ol><li>相对于数组查找元素的优势, 链表的<code>优势在于插入和删除</code></li><li>数组的元素地址是连续的, 但链表的元素地址是<code>可以不连续</code>的, 链表中的每一个元素都是一个<code>节点</code>(Node), 每个节点中都存放的有<code>指向下一个节点</code>的地址, 所以链表看起来像是串在一起的</li><li>每一个节点的结构大致分为数据<code>Data</code>和地址<code>next</code>域, Data用于存储本身的数据, next域用于存储指向下一个节点的地址的引用.</li><li>单项链表这个数据结构想要访问其中的一个元素就需要遍历整个链表,所以单项链表的复杂度为<code>O(N)</code>级别</li><li>但是单项链表想要进行插入和删除, 在<code>头节点进行插入和删除</code>会比较快, 只需要O(1)就行, 只需要改变第一个元素的引用</li><li>为什么要在头节点进行插入和删除呢, 因为如果在其他位置进行的话, 一定要遍历链表才能操作, 所以会很慢, 就成了O(N)级别的花费了</li><li><code>HashMap</code>底层就存在单链表结构</li></ol></blockquote><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiyLinked</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> T item;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T t)</span> &#123;</span><br><span class="line">            item = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><h4 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h4><blockquote><p>双向链表</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210201548766.png" alt="image-20221020154815708"></p><p>双向循环链表</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210201548670.png" alt="image-20221020154834607"></p></blockquote><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><blockquote><ol><li>为了解决<code>尾插</code>的问题, 出现了双向链表</li><li>一个双向链表节点的结构多了一个指向前一个节点的引用,</li><li>双向链表会同时维护头节点和尾节点, 当我们需要尾插的时候, 我们就从尾节点开始</li><li>双向链表访问的顺序是<code>有序的</code></li><li><code>LinkedList</code>就是一个双向链表</li></ol></blockquote><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiyLinked</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; first;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> T item;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;T&gt; prev;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T t)</span> &#123;</span><br><span class="line">            item = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210201643372.png" alt="image-20221020164330308"></p></blockquote><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><blockquote><ol><li>队列有两个操作分别为入队<strong>enqueue</strong>,出队<strong>dequeue</strong>, 遵循<code>先进先出</code>原则</li><li>一般在尾部<code>入队</code>(插入), 在头部<code>出队</code>(取出)</li><li>队列一般可以分为有界队列和无界队列, 有界队列存放的元素有限, 无界队列存放的元素无限, 只要内存够多, 就能一直存下去</li><li>数组可以构造一个有界队列, 双向链表可以构造一个无界队列</li><li>时间复杂度为<code>O(1)</code>, 非常快</li></ol></blockquote><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="图示-4"><a href="#图示-4" class="headerlink" title="图示"></a>图示</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210201901525.png" alt="image-20221020190142463"></p></blockquote><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><blockquote><ol><li>栈是一种<code>先入后出</code>的数据结构, 例如<code>弹夹</code></li><li>用数组和链表可以构造栈结构</li><li>在程序的运行过程中可能出现栈内存溢出异常, 所以可以看出栈具有相对固定的深度</li><li>在栈中往往第一个被取出的元素,同样是最后一个放入的元素</li><li>时间复杂度为<code>O(1)</code>, 非常快</li></ol></blockquote><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote><p>在如今的编程中, 我们用到的数据结构更多的是前两种</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/archives/b543ced0.html"/>
      <url>/archives/b543ced0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><blockquote><h6 id="AMQP生产者流转过程"><a href="#AMQP生产者流转过程" class="headerlink" title="AMQP生产者流转过程"></a>AMQP生产者流转过程</h6><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210161658913.png" alt="image-20221016165845816"></p><h6 id="AMQP消费者流转过程"><a href="#AMQP消费者流转过程" class="headerlink" title="AMQP消费者流转过程"></a>AMQP消费者流转过程</h6><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210161659228.png" alt="image-20221016165904160"></p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>一个协议,应用层中的一个高级消息队列协议</p><h4 id="连接-Connection"><a href="#连接-Connection" class="headerlink" title="连接(Connection)"></a>连接(Connection)</h4><blockquote><p>一个网络连接,比如TCP/IP套接字连接,三次握手和四次挥手.</p></blockquote><h4 id="信道-Channel"><a href="#信道-Channel" class="headerlink" title="信道(Channel)"></a>信道(Channel)</h4><blockquote><p>数据流传输的通道,就是消息传输的通道,每一个信道代表一个会话任务(类似于客户与客服的会话)</p></blockquote><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><blockquote><p>AMQP会话的发起者,客户端生产和消费消息,服务端存储消息</p></blockquote><h4 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h4><blockquote><p>一个AMQP会话连接两个端点,客户端和服务端</p></blockquote><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><blockquote><p>客户端程序,消息的生产者</p></blockquote><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><blockquote><p>客户端程序,消息的消费者</p></blockquote></blockquote><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><h4 id="交换机-Exchange"><a href="#交换机-Exchange" class="headerlink" title="交换机(Exchange)"></a>交换机(Exchange)</h4><blockquote><p>交换机接收信道中传输的消息,根据路由Key,发送消息到指定的队列中,不具备存储消息的能力</p></blockquote><h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h4><blockquote><p>用来保存消息,并将消息转发给消费者</p></blockquote><h4 id="路由Key"><a href="#路由Key" class="headerlink" title="路由Key"></a>路由Key</h4><blockquote><p>一个路由规则,队列绑定路由Key,交换机用它来确定消息路由给哪些队列</p></blockquote><h4 id="BindingKey"><a href="#BindingKey" class="headerlink" title="BindingKey"></a>BindingKey</h4><blockquote><p>一个BindingKey可以代表多个路由Key</p></blockquote><h4 id="消息-Message"><a href="#消息-Message" class="headerlink" title="消息(Message)"></a>消息(Message)</h4><blockquote><p>服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。</p></blockquote><h3 id="Exchange类型"><a href="#Exchange类型" class="headerlink" title="Exchange类型"></a>Exchange类型</h3><h4 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h4><blockquote><p> 广播，将消息交给所有绑定到交换机的队列</p></blockquote><h4 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h4><blockquote><p>定向，把消息交给符合 Routing key 的指定队列</p></blockquote><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><blockquote><p>通配符，把消息交给符合 Binding key 的队列</p></blockquote><h3 id="简单模式-Simple"><a href="#简单模式-Simple" class="headerlink" title="简单模式(Simple)"></a>简单模式(Simple)</h3><h4 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h4><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210171922869.png" alt="image-20221017192211820"></p></blockquote><h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><blockquote><p>一个生产者对应一个消费者</p></blockquote><h3 id="工作模式-Work"><a href="#工作模式-Work" class="headerlink" title="工作模式(Work)"></a>工作模式(Work)</h3><h4 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h4><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210171922242.png" alt="image-20221017192226190"></p></blockquote><h4 id="详解-1"><a href="#详解-1" class="headerlink" title="详解"></a>详解</h4><blockquote><p>一个生产者对应多个消费者,但一个消息只能一个消费者获取,队列向消费者转发消息开启轮询机制</p></blockquote><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><h4 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h4><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210171922811.png" alt="image-20221017192239745"></p></blockquote><h4 id="详解-2"><a href="#详解-2" class="headerlink" title="详解"></a>详解</h4><blockquote><p>一条消息被交换机发送给所有绑定自己的队列,可以实现一个消息被多次消费,当前模式下的交换机为Fanout广播交换机</p></blockquote><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><h4 id="图示-4"><a href="#图示-4" class="headerlink" title="图示"></a>图示</h4><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210171922068.png" alt="image-20221017192255000"></p></blockquote><h4 id="详解-3"><a href="#详解-3" class="headerlink" title="详解"></a>详解</h4><blockquote><p>在生产者向交换器发送消息的时候,会为消息指定路由Key,交换机在收到消息后会转发给绑定该路由Key的队列(全值匹配),再由队列交给其下的消费者消费</p></blockquote><h3 id="主题模式-Topic"><a href="#主题模式-Topic" class="headerlink" title="主题模式(Topic)"></a>主题模式(Topic)</h3><h4 id="图示-5"><a href="#图示-5" class="headerlink" title="图示"></a>图示</h4><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210171923986.png" alt="image-20221017192327902"></p></blockquote><h4 id="详解-4"><a href="#详解-4" class="headerlink" title="详解"></a>详解</h4><blockquote><p>在生产者向交换器发送消息的时候,会为消息指定路由Key,交换机在收到消息后,会将该消息交给符合消息路由Key匹配规则的队列,每个队列绑定都有一个BindingKey,消息的路由Key符合此BindingKey的规则,就可以入列.</p></blockquote><h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><h3 id="发布订阅模式-FanoutExchange"><a href="#发布订阅模式-FanoutExchange" class="headerlink" title="发布订阅模式[FanoutExchange]"></a>发布订阅模式[FanoutExchange]</h3><h4 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h4><blockquote><p>POM文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">producer</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.200</span><span class="number">.129</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">        <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.producer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> RabbitMqConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 付青松</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2022年 10月 16日 17:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> FanoutExchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">myExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;myExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Queue对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">myQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;myQueue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Queue对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">myQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;myQueue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(myQueue1()).to(myExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(myQueue2()).to(myExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送消息接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.producer.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ProducerController</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 付青松</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2022年 10月 16日 17:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sendMessage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//发送消息,因为发布订阅模式不需要路由Key,所以第二个参数给空</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;myExchange&quot;</span>,<span class="string">&quot;&quot;</span>,message);</span><br><span class="line">        <span class="keyword">return</span> message + <span class="string">&quot;已发送&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h4><blockquote><p>POM</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>消费消息接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.consumer.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> RabbitMqListener</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 付青松</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2022年 10月 16日 18:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;myQueue1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerQueue1</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(message + <span class="string">&quot;消息已被myQueue1队列消费者消费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;myQueue2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerQueue2</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(message + <span class="string">&quot;消息已被myQueue2队列消费者消费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><blockquote><p>1.记得写启动类</p><p>2.记得先启动生产者发送一条消息将交换机和队列先创建</p></blockquote><h3 id="路由模式-Direct"><a href="#路由模式-Direct" class="headerlink" title="路由模式[Direct]"></a>路由模式[Direct]</h3><h4 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h4><blockquote><p>配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.producer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> RabbitMqConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 付青松</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2022年 10月 16日 17:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建定向交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> DirectExchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">myDirectExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1.name -&gt; 交换机名称</span></span><br><span class="line"><span class="comment">         * 2.durable -&gt; 是否开启持久化,默认false,开启后在交换机中的消息会被持久化在磁盘中,确保消息重启任然存在</span></span><br><span class="line"><span class="comment">         * 3.autoDelete -&gt; 是否自动删除</span></span><br><span class="line"><span class="comment">         * 一般只将持久化设置为Ture,其他默认</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;myDirectExchange&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Queue对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">myQueueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1.name -&gt; 队列名称</span></span><br><span class="line"><span class="comment">         * 2.durable -&gt; 是否持久化,默认false,开启后在队列中的消息会被持久化在磁盘中,确保消息重启任然存在</span></span><br><span class="line"><span class="comment">         * 3.exclusive -&gt; 当连接关闭后队列是否被删除</span></span><br><span class="line"><span class="comment">         * 4.autoDelete -&gt; 当没有生产者和消费者使用队列,则该队列是否自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;myQueueA&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Queue对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">myQueueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;myQueueB&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * with(String routingKey)</span></span><br><span class="line"><span class="comment">         * 那个队列绑定哪个交换机,并指定交换机和队列连接之间的路由Key</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(myQueueA()).to(myDirectExchange()).with(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(myQueueB()).to(myDirectExchange()).with(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发送消息接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.producer.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ProducerController</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 付青松</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2022年 10月 16日 17:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sendMessageA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMessageA</span><span class="params">(String messageA)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1.exchange -&gt; 交换机名称</span></span><br><span class="line"><span class="comment">         * 2.routingKey -&gt; 路由Key</span></span><br><span class="line"><span class="comment">         * 3.object -&gt; 发送的消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;myDirectExchange&quot;</span>,<span class="string">&quot;A&quot;</span>,messageA);</span><br><span class="line">        <span class="keyword">return</span> messageA + <span class="string">&quot;已发送&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sendMessageB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMessageB</span><span class="params">(String messageB)</span> &#123;</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;myDirectExchange&quot;</span>,<span class="string">&quot;B&quot;</span>,messageB);</span><br><span class="line">        <span class="keyword">return</span> messageB + <span class="string">&quot;已发送&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h4><blockquote><p>消费消息接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.consumer.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> RabbitMqListener</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 付青松</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2022年 10月 16日 18:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;myQueueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerQueue1</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(message + <span class="string">&quot;消息已被myQueueA队列的消费者消费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;myQueueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerQueue2</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(message + <span class="string">&quot;消息已被myQueueB队列的消费者消费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="主题模式-Topic-1"><a href="#主题模式-Topic-1" class="headerlink" title="主题模式[Topic]"></a>主题模式[Topic]</h3><h4 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h4><blockquote><p>配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 修改交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TopicExchange <span class="title function_">myTopicExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(<span class="string">&quot;myTopicExchange&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新绑定交换机,并修改路由绑定的BindingKey</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingA</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(myQueueA()).to(myTopicExchange()).with(<span class="string">&quot;*.A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(myQueueB()).to(myTopicExchange()).with(<span class="string">&quot;*.B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发送消息接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重新绑定交换机,并指定每条消息的路由Key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sendMessageA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sendMessageA</span><span class="params">(String messageA)</span> &#123;</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;myTopicExchange&quot;</span>,<span class="string">&quot;C.A&quot;</span>,messageA + <span class="string">&quot;RK = C.A&quot;</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;myTopicExchange&quot;</span>,<span class="string">&quot;D.A&quot;</span>,messageA + <span class="string">&quot;RK = D.A&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> messageA + <span class="string">&quot;已发送&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sendMessageB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sendMessageB</span><span class="params">(String messageB)</span> &#123;</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;myTopicExchange&quot;</span>,<span class="string">&quot;E.B&quot;</span>,messageB + <span class="string">&quot;RK = E.B&quot;</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;myTopicExchange&quot;</span>,<span class="string">&quot;R.B&quot;</span>,messageB + <span class="string">&quot;RK = R.B&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> messageB + <span class="string">&quot;已发送&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="消费者-3"><a href="#消费者-3" class="headerlink" title="消费者"></a>消费者</h4><blockquote><p>不用修改</p></blockquote><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210171320109.png" alt="image-20221017132019043"></p></blockquote><h3 id="注解替代配置类"><a href="#注解替代配置类" class="headerlink" title="注解替代配置类"></a>注解替代配置类</h3><h4 id="生产者-4"><a href="#生产者-4" class="headerlink" title="生产者"></a>生产者</h4><blockquote><p>禁用配置类,配置类我们将在消费者处用注解代替</p></blockquote><h4 id="消费者-4"><a href="#消费者-4" class="headerlink" title="消费者"></a>消费者</h4><blockquote><p>消费消息接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.consumer.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> RabbitMqListener</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 付青松</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2022年 10月 16日 18:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(value = &quot;myQueueA&quot;,durable = &quot;true&quot;),exchange = @Exchange(</span></span><br><span class="line"><span class="meta">            value = &quot;myTopicExchange&quot;,type = ExchangeTypes.TOPIC),key = &quot;*.A&quot;))</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerQueue1</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(message + <span class="string">&quot;消息已被myQueueA队列的消费者消费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(value = &quot;myQueueB&quot;,durable = &quot;true&quot;),exchange = @Exchange(</span></span><br><span class="line"><span class="meta">                    value = &quot;myTopicExchange&quot;,type = ExchangeTypes.TOPIC),key = &quot;*.B&quot;))</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerQueue2</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(message + <span class="string">&quot;消息已被myQueueB队列的消费者消费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><blockquote><p>1.交换机和队列的创建交给了消费者,消费者不用等生产者发送消息创建交换机和队列.</p><p>2.但相较于配置类不便于同一管理</p><p>3.消费者启动后自动创建交换机和队列.</p></blockquote><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="消息确认机制-参考文章"><a href="#消息确认机制-参考文章" class="headerlink" title="消息确认机制[参考文章]"></a>消息确认机制[参考<a href="https://juejin.cn/post/6844904205438681095#heading-5">文章</a>]</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><blockquote><p>图示</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210171918342.png" alt="image-20221017191802245"></p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210171926132.png" alt="image-20221017192659076"></p><p>yaml配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line"> <span class="comment">#默认禁止开启消息确认机制</span></span><br><span class="line">        <span class="attr">publisher-confirm-type:</span> <span class="string">none</span> </span><br><span class="line"> <span class="comment">#表示消息成功到达Broker后触发回调 ,开启ConfirmCallback确认模式</span></span><br><span class="line">        <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> </span><br><span class="line">        <span class="comment">#其一和correlated一样</span></span><br><span class="line">        <span class="comment">#其二会在发送消息成功后调用方法等待broker节点返回发送结果</span></span><br><span class="line">        <span class="comment">#根据返回结果来判断下一步的逻辑</span></span><br><span class="line">        <span class="comment">#注意 :此方法返回false会关闭channel，则接下来无法发送消息到broker。</span></span><br><span class="line">        <span class="attr">publisher-confirm-type:</span> <span class="string">simple</span></span><br><span class="line">        <span class="comment">#确认消息已发送到队列(Queue),开启 ReturnCallback 退回模式</span></span><br><span class="line">        <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#设置消费手动ack应答</span></span><br><span class="line">        <span class="attr">listener:</span></span><br><span class="line">            <span class="attr">simple:</span></span><br><span class="line">                <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">                <span class="comment"># 是否支持重试</span></span><br><span class="line">             <span class="attr">retry:</span></span><br><span class="line">                    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="消息发送确认"><a href="#消息发送确认" class="headerlink" title="消息发送确认"></a>消息发送确认</h4><h5 id="ConfirmCallback确认模式"><a href="#ConfirmCallback确认模式" class="headerlink" title="ConfirmCallback确认模式"></a>ConfirmCallback确认模式</h5><blockquote><p>消息只要被 <code>rabbitmq broker</code> 接收到就会触发 <code>confirmCallback</code> 回调 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmCallbackService</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息发送异常!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;发送者爸爸已经收到确认，correlationData=&#123;&#125; ,ack=&#123;&#125;, cause=&#123;&#125;&quot;</span>, correlationData.getId(), ack, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>correlationData</code>：对象内部只有一个 <code>id</code> 属性，用来表示当前消息的唯一性。</li><li><code>ack</code>：消息投递到<code>broker</code> 的状态，<code>true</code>表示成功。</li><li><code>cause</code>：表示投递失败的原因</li></ul><p>但消息被 <code>broker</code> 接收到只能表示已经到达 MQ服务器，并不能保证消息一定会被投递到目标 <code>queue</code> 里。所以接下来需要用到 <code>returnCallback</code> .</p></blockquote><h5 id="ReturnCallback-退回模式"><a href="#ReturnCallback-退回模式" class="headerlink" title="ReturnCallback 退回模式"></a>ReturnCallback 退回模式</h5><blockquote><p>如果消息未能投递到目标 <code>queue</code> 里将触发回调 <code>returnCallback</code> ，一旦向 <code>queue</code> 投递消息未成功，这里一般会记录下当前消息的详细投递数据，方便后续做重发等操作.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnCallbackService</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ReturnCallback &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">     log.info(<span class="string">&quot;returnedMessage ===&gt; replyCode=&#123;&#125; ,replyText=&#123;&#125; ,exchange=&#123;&#125; ,routingKey=&#123;&#125;&quot;</span>, replyCode, replyText, exchange, routingKey);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>message</code>（消息体）</li><li><code>replyCode</code>（响应code）</li><li><code>replyText</code>（响应内容）</li><li><code>exchange</code>（交换机）</li><li><code>routingKey</code>（队列）</li></ul></blockquote><h5 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h5><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfirmCallbackService confirmCallbackService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ReturnCallbackService returnCallbackService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String exchange, String routingKey, Object msg)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 确保消息发送失败后可以重新返回到队列中</span></span><br><span class="line"><span class="comment">         * 注意：yml需要配置 publisher-returns: true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者确认收到消息后，手动ack回执回调处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(confirmCallbackService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息投递到队列失败回调处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(returnCallbackService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, msg,</span><br><span class="line">                message -&gt; &#123;</span><br><span class="line">                    message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">                    <span class="keyword">return</span> message;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="消息接收确认"><a href="#消息接收确认" class="headerlink" title="消息接收确认"></a>消息接收确认</h4><blockquote><p>消息接收确认要比消息发送确认简单一点，因为只有一个消息回执（<code>ack</code>）的过程。使用<code>@RabbitHandler</code>注解标注的方法要增加 <code>channel</code>(信道)、<code>message</code> 两个参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;confirm_test_queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiverMessage1</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processHandler</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;小富收到消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//TODO 具体业务</span></span><br><span class="line">            </span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        &#125;  <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (message.getMessageProperties().getRedelivered()) &#123;</span><br><span class="line">                </span><br><span class="line">                log.error(<span class="string">&quot;消息已重复处理失败,拒绝再次接收...&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>); <span class="comment">// 拒绝消息</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                log.error(<span class="string">&quot;消息即将再次返回队列处理...&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">true</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费消息有三种回执方法，我们来分析一下每种方法的含义。</p></blockquote><h5 id="basicAck"><a href="#basicAck" class="headerlink" title="basicAck"></a>basicAck</h5><blockquote><p><code>basicAck</code>：表示成功确认，使用此回执方法后，消息会被<code>rabbitmq broker</code> 删除。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">basicAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>deliveryTag</code>：表示消息投递序号，每次消费消息或者消息重新投递后，<code>deliveryTag</code>都会增加。手动消息确认模式下，我们可以对指定<code>deliveryTag</code>的消息进行<code>ack</code>、<code>nack</code>、<code>reject</code>等操作。</p><p><code>multiple</code>：是否批量确认，值为 <code>true</code> 则会一次性 <code>ack</code>所有小于当前消息 <code>deliveryTag</code> 的消息。</p><p><strong>举个栗子：</strong> 假设我先发送三条消息<code>deliveryTag</code>分别是5、6、7，可它们都没有被确认，当我发第四条消息此时<code>deliveryTag</code>为8，<code>multiple</code>设置为 true，会将5、6、7、8的消息全部进行确认。</p></blockquote><h5 id="basicNack"><a href="#basicNack" class="headerlink" title="basicNack"></a>basicNack</h5><blockquote><p><code>basicNack</code> ：表示失败确认，一般在消费消息业务异常时用到此方法，可以将消息重新投递入队列。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">basicNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple, <span class="type">boolean</span> requeue)</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>deliveryTag</code>：表示消息投递序号。</p><p><code>multiple</code>：是否批量确认。</p><p><code>requeue</code>：值为 <code>true</code> 消息将重新入队列。</p></blockquote><h5 id="basicReject"><a href="#basicReject" class="headerlink" title="basicReject"></a>basicReject</h5><blockquote><p><code>basicReject</code>：拒绝消息，与<code>basicNack</code>区别在于不能进行批量操作，其他用法很相似。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">basicReject</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> requeue)</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>deliveryTag</code>：表示消息投递序号。</p><p><code>requeue</code>：值为 <code>true</code> 消息将重新入队列。</p></blockquote><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><blockquote><p>什么情况下消息会进入死信队列</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.在消息确认机制中被拒绝的消息</span><br><span class="line">2.消息超过自身的过期时间或超过队列设置的消息过期时间</span><br><span class="line">3.队列存储的消息满了,达到了最大长度</span><br></pre></td></tr></table></figure><p>入队流程</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.因为```原因消息要进入死信队列</span><br><span class="line">2.先经过死信交换机,由死信交换机转发给各个死信队列</span><br></pre></td></tr></table></figure><p>图示</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210171614046.png" alt="image-20221017161440959"></p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202210171615031.png" alt="image-20221017161504954"></p><p>创建队列时设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TopicExchange <span class="title function_">myTopicExchange</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">    Map&lt;String, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    hashMap.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,<span class="string">&quot;死信交换机名称&quot;</span>);</span><br><span class="line">    <span class="comment">//路由Key设置与否主要看死信交换机的类型</span></span><br><span class="line">    hashMap.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,路由key<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    return new Queue(&quot;</span>myQueueA<span class="string">&quot;,true,false,false,hashMap);    </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="TTL-延时队列"><a href="#TTL-延时队列" class="headerlink" title="TTL[延时队列]"></a>TTL[延时队列]</h3><blockquote><p>队列设置过期时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在创建队列时设置</span></span><br><span class="line"><span class="keyword">public</span> TopicExchange <span class="title function_">myTopicExchange</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    hashMap.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">5000</span>);<span class="comment">//只能int类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;myQueueA&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,hashMap);    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>消息设置过期时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在发送消息时</span></span><br><span class="line"><span class="comment">//注意导包 -&gt; import org.springframework.amqp.core.MessagePostProcessor;</span></span><br><span class="line"><span class="type">MessagePostProcessor</span> <span class="variable">Processor</span> <span class="operator">=</span> message -&gt; &#123;</span><br><span class="line">            message.getMessageProperties().setExpiration(<span class="string">&quot;5000&quot;</span>);</span><br><span class="line">            message.getMessageProperties().setContentEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;myTopicExchange&quot;</span>,<span class="string">&quot;&quot;</span>,messageA,Processor);</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/archives/69c3279c.html"/>
      <url>/archives/69c3279c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><blockquote><ul><li>Workspace：工作区,在日常开发中存储我们项目代码的区域</li><li>Index / Stage：暂存区,执行add命令后,就是一个文件,文件内是我们改动过的文件信息列表</li><li>Repository：本地仓库,我们commit命令后文件都存放在这里</li><li>Remote：远程仓库,我们执行push后,代码会到远程仓库内</li></ul></blockquote><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看系统config</span></span><br><span class="line">git config --system --list</span><br><span class="line">　　</span><br><span class="line"><span class="comment">#查看当前用户（global）配置</span></span><br><span class="line">git config --global  --list</span><br></pre></td></tr></table></figure><h3 id="配置文件所在目录"><a href="#配置文件所在目录" class="headerlink" title="配置文件所在目录"></a>配置文件所在目录</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">系统配置文件 ==&gt; Git<span class="keyword">\etc</span><span class="keyword">\gitconfig</span></span><br><span class="line"></span><br><span class="line">全局配置文件 ==&gt; C:<span class="keyword">\Users</span><span class="keyword">\用</span>户<span class="keyword">\ </span>.gitconfig</span><br><span class="line"></span><br><span class="line">SSH密钥 ==&gt; C:<span class="keyword">\Users</span><span class="keyword">\用</span>户<span class="keyword">\ </span>.ssh<span class="keyword">\</span></span><br></pre></td></tr></table></figure><h3 id="设置配置"><a href="#设置配置" class="headerlink" title="设置配置"></a>设置配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用户名邮箱</span></span><br><span class="line">git config --global user.name <span class="string">&quot;名称&quot;</span></span><br><span class="line">git config --global user.email 邮箱</span><br><span class="line"><span class="comment">#生成SSh密钥</span></span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line">git <span class="built_in">clone</span> [url]  <span class="comment"># https://gitee.com/xxx.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看指定文件状态</span></span><br><span class="line">git status [filename]</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看所有文件状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有文件到暂存区</span></span><br><span class="line">git add .       </span><br><span class="line"></span><br><span class="line"><span class="comment">#提交暂存区中的内容到本地仓库 -m 提交信息</span></span><br><span class="line">git commit -m <span class="string">&quot;消息内容&quot;</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前文件夹下的远程仓库</span></span><br><span class="line"> git remote -v</span><br><span class="line"> </span><br><span class="line"><span class="comment">#先拉取再推送</span></span><br><span class="line">git pull --rebase origin master</span><br><span class="line"></span><br><span class="line"><span class="comment">#推送本地仓库到远程仓库</span></span><br><span class="line"> git push origin master</span><br><span class="line"> git push 远程仓库名 远程仓库分支</span><br></pre></td></tr></table></figure><h3 id="文件忽略"><a href="#文件忽略" class="headerlink" title="文件忽略"></a>文件忽略</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">*.txt        <span class="params">#</span>忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     <span class="params">#</span>但lib.txt除外</span><br><span class="line">/temp        <span class="params">#</span>仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/       <span class="params">#</span>忽略build/目录下的所有文件</span><br><span class="line">doc/*.txt    <span class="params">#</span>会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure><h3 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql高级</title>
      <link href="/archives/af491aa0.html"/>
      <url>/archives/af491aa0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote><p>配置文件所在位置</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">/etc/mysql/my.cnf</span><br></pre></td></tr></table></figure><p>设置字符集为UTF-8</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8<span class="built_in">_</span>general<span class="built_in">_</span>ci</span><br></pre></td></tr></table></figure><p>查询引擎</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure></blockquote><h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209071946247.png" alt="image-20220907194606113"></p></blockquote><h3 id="逻辑四层"><a href="#逻辑四层" class="headerlink" title="逻辑四层"></a>逻辑四层</h3><blockquote><p>连接层</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.当客户端访问Mysql服务器的时候,要建立TCP连接</span><br><span class="line">2.经过三次握手成功建立连接后,服务器会对TCP传输过来的账号数据进行获取.</span><br><span class="line">3.对账号密码进行认证</span><br><span class="line">4.在权限表中对账号的权限进行认证</span><br><span class="line">5.TCP分配专门的线程做与客户端的交互</span><br></pre></td></tr></table></figure><p>服务层</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">SQL接口</span><br><span class="line">1.接受用户的SQL命令</span><br><span class="line">2.返回用户需要查询的结果</span><br><span class="line"></span><br><span class="line">Parser解析器</span><br><span class="line">1.对用户SQL语法进行解析</span><br><span class="line">2.将SQL语法分解成数据结构</span><br><span class="line">3.进行语法优化</span><br><span class="line">4.讲数据结果传给后续步骤</span><br><span class="line"></span><br><span class="line">Optimizer查询优化器</span><br><span class="line">1.确定使用什么索引进行查询</span><br><span class="line">2.生成SQL语句的执行计划</span><br><span class="line"></span><br><span class="line">Caches<span class="built_in">&amp;</span>Buffers查询缓存组件</span><br><span class="line">1.缓存一条SQL语句的返回结果</span><br></pre></td></tr></table></figure><p>引擎层</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.插拔式的存储引擎</span><br><span class="line">2.负责数据的存储和提取</span><br><span class="line">3.通过API与存储引擎进行通信</span><br></pre></td></tr></table></figure><p>存储层</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.数据库所有的数据都是存储在文件系统上面的</span><br><span class="line">2.存储层与存储引擎进行交互</span><br></pre></td></tr></table></figure><p>小结</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端</span><br><span class="line">2.SQL层(服务层)：对 SQL 语句进行查询处理,与数据库文件的存储方式无关</span><br><span class="line">3.存储引擎层：与数据库文件打交道，负责数据的存储和读取</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209072008840.png" alt="image-20220907200839776"></p></blockquote><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209072012175.png" alt="image-20220907201247048"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.建立连接</span><br><span class="line">MySQL 客户端通过协议与 MySQL 服务器建连接，发送查询语句。</span><br><span class="line">2.查询缓存</span><br><span class="line">===&gt;如果在查询缓存中发现了相同的SQL语句,会将缓存的结果直接返回</span><br><span class="line">===&gt;因为查询缓存的命中率不高,所以在8版本去掉了</span><br><span class="line">3.解析器</span><br><span class="line">===&gt;对SQL语句进行语法解析,判断用户的SQL是否满足SQL语法</span><br><span class="line">===&gt;如果用户语法正确,会生对应的语法树</span><br><span class="line">4.优化器</span><br><span class="line">===&gt;确定SQL的执行路径,是全文检索还是索引检索</span><br><span class="line">===&gt;优化器可以分为逻辑查询和物理查询优化</span><br><span class="line">===&gt;生成执行计划</span><br><span class="line">5.执行器</span><br><span class="line">===&gt;根据执行计划调用存储引擎接口</span><br><span class="line">===&gt;将满足条件的结果集返回</span><br></pre></td></tr></table></figure></blockquote><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><blockquote><p>查看MySQl支持的引擎</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209231348894.png" alt="image-20220923134845764"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure><p>查看默认的存储引擎</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209231350052.png" alt="image-20220923135007940"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &quot;%storage_engine&quot;;</span><br></pre></td></tr></table></figure></blockquote><h3 id="引擎分类"><a href="#引擎分类" class="headerlink" title="引擎分类"></a>引擎分类</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.InnoDB</span><br><span class="line">==&gt; mysql 5.5 版本之后默认使用InnoDB引擎</span><br><span class="line">==&gt; 用来处理短期事务,可以确保事务的完整提交和回滚</span><br><span class="line">==&gt; 除了增查操作,还需要更新和删除操作,优先选择 InnoDB 存储引擎。</span><br><span class="line">2.MyISAM</span><br><span class="line">==&gt; mysql 5.5 版本之前默认使用MyISAM引擎</span><br><span class="line">==&gt; 提供了全文索引,压缩,空间函数等功能</span><br><span class="line">==&gt; 不支持事务和行级锁,奔溃后无法进行安全恢复</span><br><span class="line">==&gt; 数据文件结构：- .frm 存储定义表 - .MYD 存储数据 - .MYI 存储索引</span><br><span class="line">3.Archive</span><br><span class="line">==&gt; 只支持添加和查询操作</span><br><span class="line">4.Blackhole</span><br><span class="line">==&gt; 没有实现任何存储机制,丢弃所有插入的数据,不做任何保存</span><br><span class="line">==&gt; 但服务器会记录日志,用于复制数据到备库，或者简单地记录到日志。</span><br><span class="line">5.CSV</span><br><span class="line">==&gt; 不支持索引</span><br><span class="line">==&gt; 存储的数据可以直接放在操作系统中,可以直接用文本编辑器或者Excel读取</span><br><span class="line">6.Memory</span><br><span class="line">==&gt; 如果需要快速地访问数据，且这些数据不会被修改，重启以后丢失也没有关系，那么使用 Memory 表是非常有用。</span><br><span class="line">==&gt; Memory 表至少比 MyISAM 表要快一个数量级。</span><br></pre></td></tr></table></figure><p>InnoDB与MyISAM对比</p><table><thead><tr><th><strong>对比项</strong></th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td><strong>外键</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>事务</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>行表锁</strong></td><td>支持表锁  <br>即使操作一条记录也会锁住整个表，  <br>不适合高并发操作</td><td>支持行锁<br>操作时只锁某一行，不对其它行有影响，  <br>适合高并发操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，  <br>对内存要求较高， <br>而且内存大小对性能有决定性的影响</td></tr><tr><td>系统提供预创建数据库表  <br>给用户使用</td><td>是</td><td>否</td></tr><tr><td>关注点</td><td>性能：节省资源、消耗少、简单业务</td><td>事务：并发写、事务、需要更大资源</td></tr><tr><td>默认安装</td><td>是</td><td>是</td></tr><tr><td>默认使用</td><td>5.5版本前</td><td>5.5版本开始</td></tr></tbody></table></blockquote><h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><blockquote><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><table><thead><tr><th>索引类型</th><th>索引特点</th></tr></thead><tbody><tr><td>单列索引</td><td>即一个索引是只根据一个字段创建的，里面只包含单个列，  <br>一个表可以有多个单值索引（也叫单列索引）</td></tr><tr><td>联合索引</td><td>即一个索引包含多个列（也叫多值索引、多列索引）</td></tr><tr><td>唯一索引</td><td>索引列的值必须唯一，但允许有空值，空值可以有多个</td></tr><tr><td>主键索引</td><td>设定为主键后数据库会自动建立索引，InnoDB 为聚簇索引</td></tr></tbody></table><h4 id="基本操作语法"><a href="#基本操作语法" class="headerlink" title="基本操作语法"></a>基本操作语法</h4><p>创建单值索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index 索引名 on 字段所在表(字段);</span><br></pre></td></tr></table></figure><p>创建唯一索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create unique index 索引名 on 字段所在表(字段);</span><br></pre></td></tr></table></figure><p>联合索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index 索引名 on 字段所在表(字段1,字段2);</span><br></pre></td></tr></table></figure><p>删除索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop index 要删除的索引名 on 索引所在的表;</span><br></pre></td></tr></table></figure></blockquote><h3 id="创建索引的情况"><a href="#创建索引的情况" class="headerlink" title="创建索引的情况"></a>创建索引的情况</h3><blockquote><p>需要创建索引的情况</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.主键自动建立唯一索引</span><br><span class="line">2.频繁作为查询条件的字段应该创建索引</span><br><span class="line">3.表之间关联查询的情况</span><br><span class="line">  -涉及的表不能大于3张以上</span><br><span class="line">  -给大表的关联字段创建索引</span><br><span class="line">  -关联字段在各个表中的类型要一致</span><br><span class="line">4.因为一条SQL语句只能用到一个索引,所以多个字段查询的应创建组合索引而不是单列索引</span><br><span class="line">5.查询中排序的字段</span><br><span class="line">6.查询中统计和分组的字段</span><br></pre></td></tr></table></figure><p>下列情况创建索引效果更好</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.字段的数值有唯一性限制</span><br><span class="line">2.类型小（字节宽度小）的字段</span><br></pre></td></tr></table></figure><p>不要创建索引的情况</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.数据库表中记录数量小于 300 万条时,创建索引也不会让搜索速度有明显提升。</span><br><span class="line">2.经常增删改的表,建立索引是为了提高查询的速度.建立索引会降低更新表的速度,因为更新表要重排索引,重排索引要全表扫描,所以非常的耗时间</span><br><span class="line">3.条件,排序,分组查询都用不到的字段</span><br><span class="line">4.无法排序的字段</span><br><span class="line">5.不要创建重复的索引</span><br></pre></td></tr></table></figure></blockquote><h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><h3 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.InnoDb引擎最小的存储单位是页,不是所有页都是数据页,只有存放原始数据的页称为数据页</span><br><span class="line">2.一页默认大小为16KB,假设一条记录占1KB,那一个数据页大概能存16条记录一个数据库需要很多数据页来存放数据</span><br></pre></td></tr></table></figure></blockquote><h3 id="数据页内部"><a href="#数据页内部" class="headerlink" title="数据页内部"></a>数据页内部</h3><blockquote><p>主键排序</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">数据页内部是根据主键来排序的,当我们在数据页中查找数据时是根据二分法来查找的</span><br></pre></td></tr></table></figure><p>数据页编号</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">一个数据库有很多数据页,每个数据页都有自己的唯一编号,相当于这个数据页的地址</span><br></pre></td></tr></table></figure></blockquote><h3 id="数据页如何便于查找"><a href="#数据页如何便于查找" class="headerlink" title="数据页如何便于查找"></a>数据页如何便于查找</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.排序</span><br><span class="line">==&gt; 根据主键值对所有数据页的数据进行排序</span><br><span class="line">2.双向链表</span><br><span class="line">==&gt; 将所有的数据页组成双向链表</span><br></pre></td></tr></table></figure></blockquote><h3 id="数据页设定目录"><a href="#数据页设定目录" class="headerlink" title="数据页设定目录"></a>数据页设定目录</h3><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">为了能够更快速的查找到数据,我们可以给数据页设置目录</span><br></pre></td></tr></table></figure><p>第一层目录</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209232110898.png" alt="image-20220923211031817"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.如何设置?</span><br><span class="line">==&gt; 将一个数据页中最小主键值和数据页编号组成一个目录页</span><br><span class="line">==&gt; 目录页因为主键值,所以目录页中的记录是有序的</span><br><span class="line"></span><br><span class="line">2.搜索</span><br><span class="line">==&gt; 假设目录页中有3条记录,依次最小主键为1,11,21,这样就有三个区间[1,11),[11,21),[21, ...)</span><br><span class="line">情景:</span><br><span class="line">1.搜索主键值为11的数据</span><br><span class="line">2.11在[11,21)中,因为[11,21)区间对应的数据页码为2</span><br><span class="line">3.进入页码为2的数据页,在数据页内部根据二分法进行主键的查找</span><br><span class="line"></span><br><span class="line">小贴士💖</span><br><span class="line">1.不管是目录页还是数据页都是页,默认大小都是16KB</span><br><span class="line">2.一个主键值8字节,一个页码8个字节,一个目录页大概能存1024条记录</span><br></pre></td></tr></table></figure><p>第二层目录</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209240855200.png" alt="image-20220924085544116"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.如何设置？</span><br><span class="line">==&gt; 为了更进一步的查找，我们可以给目录页再设置目录页，多层级的目录页</span><br><span class="line"></span><br><span class="line">2.搜索</span><br><span class="line">用户搜索的主键值是：60。现在 13 号目录页中包含的区间：</span><br><span class="line"></span><br><span class="line">- [1,51)</span><br><span class="line">- [51,150)</span><br><span class="line">- [150,...)</span><br><span class="line"></span><br><span class="line">所以 60 会落在 [51,150) 区间，所以继续查找页码为 8 的目录页：</span><br><span class="line"></span><br><span class="line">- [51,81)</span><br><span class="line">- [81,100)</span><br><span class="line">- [100,...)</span><br><span class="line"></span><br><span class="line">所以 60 会落在 [51,81) 区间，所以继续查找页码为 5 的数据页，根据主键执行二分法查找。</span><br></pre></td></tr></table></figure></blockquote><h4 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a>树型结构</h4><blockquote><p>1.示意图</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209240903306.png" alt="image-20220924090316218"></p><p>2.对接概念</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.B+Tree</span><br><span class="line">上图其实就是B+Tree的结构,多层目录页和最终的数据页组成,每页,无论是目录页还是数据页都是一个节点</span><br><span class="line">2.聚簇索引</span><br><span class="line">聚簇索引就是将主键作为索引值,且树形结构中存在数据页[原始数据]</span><br></pre></td></tr></table></figure><p>3.B+Tree 能够存储的记录数量</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.当结构只有一层的时候</span><br><span class="line">==&gt; 只有一个节点,并且这个节点是根节点,并且这个节点是数据页</span><br><span class="line">==&gt; 一个数据页默认大小16kb,假设一条记录占1kb,那一个数据页能存储16条数据</span><br><span class="line">2.当结构有4层时</span><br><span class="line">==&gt; 根节点是目录页,目录页一条记录占16B(主键8B+数据也页码8B),所以一页目录页16kb/16b=1024</span><br><span class="line">==&gt; 最后一层一定为数据页,数据页一页大概能存16条数据,那四层能存: 1024*1024*1024*16≈170亿</span><br></pre></td></tr></table></figure><p>4.B+Tree 层次对性能的影响</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.根节点数据常驻在内存中</span><br><span class="line">2.其他层的数据常驻于磁盘</span><br><span class="line">3.访问第一层下一层的节点会进行一次IO,访问硬盘</span><br><span class="line">4.所以层数越少,IO次数就越少,性能就越好</span><br></pre></td></tr></table></figure><p>5.BTree 为什么高瘦？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.BTree 的每个节点都是数据页</span><br><span class="line">2.数据页因为存的都是数据,所以条数很少,按照每条记录1kb,大概只能存16条记录</span><br><span class="line">3.而B+Tree因为节点有目录页,目录页一条记录由『主键8B+页码8B』组成,一条记录16B,一页存1024条,所以宽</span><br><span class="line">4.因为BTree一个节点容纳条数少,所以数据量大的话,只能一层一层向下分,导致深度增加</span><br><span class="line">5.对于查询来说,深度增加一层,就会导致IO次数+1,所以BTree的性能不如B+Tree</span><br></pre></td></tr></table></figure><p>6.BTree 为什么每个节点都存原始数据？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">因为BTree是将所有的主键排序,父节点出现过的主键不会在子节点中出现,所以每个主键只能出现在一个节点中,而每个节点都有对应的数据,所以每个节点都要存储数据,每个节点都是数据页</span><br></pre></td></tr></table></figure><p>7.BTree 和 B+Tree 的区别总结</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.BTree节点没有目录页,全是数据页</span><br><span class="line">2.BTree节点存储主键值,原始数据地址值,数据页页码引用</span><br><span class="line">3.BTree每个主键值只能在一个节点上出现,所以每个节点都需要保存原始数据</span><br><span class="line">4.BTree每个节点都要保存原始数据,所以一个节点保存的记录时很少,导致保存的子节点引用也就很少</span><br><span class="line">5.BTree的层数要比B+Tree多得多</span><br></pre></td></tr></table></figure><p>8.有数据表和索引表之分吗？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这要看索引表具体指的是哪种类型的索引。</span><br><span class="line"></span><br><span class="line">- 聚簇索引：那就没有额外的数据表，数据本身就是按照 B+Tree 的形式组成了聚簇索引——以主键作为索引值。</span><br><span class="line">- 非聚簇索引：非聚簇索引相对于聚簇索引来说可以称之为是另外一张表。</span><br></pre></td></tr></table></figure></blockquote><h4 id="B-Tree-和-BTree图示"><a href="#B-Tree-和-BTree图示" class="headerlink" title="B+Tree 和 BTree图示"></a>B+Tree 和 BTree图示</h4><blockquote><p>BTree</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209271659829.png" alt="image-20220927165932732"></p><p>B+Tree</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209271700082.png" alt="image-20220927170016004"></p></blockquote><h3 id="非主键字段创建索引"><a href="#非主键字段创建索引" class="headerlink" title="非主键字段创建索引"></a>非主键字段创建索引</h3><blockquote><p>1.不同数据类型的搜索方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#数值类型:用这个数值字段本身值作为索引</span><br><span class="line">select emp_id,emp_name,emp_age from t_emp where emp_age=20;</span><br><span class="line">#字符串类型:用这个字符串字段本身值作为索引</span><br><span class="line">select emp_id,emp_name,emp_age from t_emp where emp_name=&#x27;tom&#x27;;</span><br><span class="line">#较长的字符串类型:用字符串开头一部分值作为索引</span><br><span class="line">select emp_id,emp_name,emp_age from t_emp where emp_decs like &quot;I come from UK%&quot;;</span><br></pre></td></tr></table></figure><p>2.单列索引</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">一个索引只包含单列字段,一个表可以有多个单列索引</span><br><span class="line"></span><br><span class="line">存储结构</span><br><span class="line">当前节点页码值+一条记录(索引值[索引字段对应的值],字段所在的主键)</span><br></pre></td></tr></table></figure><p>3.多列索引(组合索引)</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">顾名思义,多个字段值组成的索引,叫多列索引.</span><br></pre></td></tr></table></figure><p>4.回表</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">我们以非聚簇索引只能查找到记录对应的主键值,所以我们任要回到聚簇索引中再查一遍,这个过程叫做回表操作,也就是我们根据非聚簇索引列的值查询一条完整的用户原始数据记录需要用到两颗B+树</span><br><span class="line"></span><br><span class="line">为什么要进行回表操作,直接把原始数据放到非聚簇索引的叶子节点不行吗?</span><br><span class="line">1.直接放是可以,但是太占用地方了,那每颗B+树都要把用户原始数据拷一边,太占用空间了</span><br><span class="line">2.会导致数据不一致,在保存两条数据的情况下,我们执行uodate操作,不能只改一个,两个都要改,浪费性能.</span><br></pre></td></tr></table></figure></blockquote><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Mysql索引包括普通索引,唯一索引,全文索引,多列和单列索引以及空间索引</span><br><span class="line"></span><br><span class="line">- &quot;功能逻辑&quot; 普通索引、唯一索引、主键索引和全文索引。</span><br><span class="line">- &quot;物理实现&quot; 聚簇索引,非聚簇索引</span><br><span class="line">- &quot;字段个数&quot; 单列和多列索引</span><br></pre></td></tr></table></figure><p>1.普通索引</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">任何数据类型都可以创建普通索引,普通索引允许出现相同的索引内容,允许Null值</span><br></pre></td></tr></table></figure><p>2.唯一索引</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在这个字段中的内容唯一,我们可以根据这个字段创建唯一索引,不可以出现相同的数据内容,但可以为Null值</span><br></pre></td></tr></table></figure><p>3.主键索引</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">其实就是特殊的唯一索引,增加一个不能为Null的限制</span><br></pre></td></tr></table></figure><p>4.单列索引</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在单个字段上面创建的索引,可以是普通索引,唯一索引,主键索引,也可以是全文索引,一个表可以有多个单列索引</span><br></pre></td></tr></table></figure><p>5.多列索引</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">多个字段创建组合索引,在实际查询中只会最左字段的索引</span><br></pre></td></tr></table></figure><p>6.全文索引</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">目前是搜索引擎使用的关键技术,利用了分词技术,按照一定算法智能筛选出我们想要的结果,允许列中存在重复值和Null值,全文索引只能创建在char,varchar,text类型和其系列类型上,查询数据量很大的字符串类型的字段的时候,使用全文索引可以加快查询速度,全文索引技术也叫倒排索引技术.</span><br><span class="line"></span><br><span class="line">- 自然语言的全文索引</span><br><span class="line">计算数据查询的相关度,相关度是基于关键词的个数和关键词在文档中出现的次数,在搜索记录中出现次数越少的词,匹配度就越高,反而一个词在50<span class="comment">%的搜索记录中都存在,那自然语言搜索不会搜索这类词语</span></span><br><span class="line">- 布尔全文索引</span><br><span class="line">可以自定义搜索的词语的相关性</span><br><span class="line"></span><br><span class="line">随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被 solr、elasticSearch等专门的搜索引擎所替代。</span><br></pre></td></tr></table></figure><p>7.空间索引</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">空间索引建立在空间数据类型上,可以提高系统获取空间数据的效率,Mysql中空间数据类型包括geometry[几何]、point[坐标点]、linestring[线]和polygon[多边形]等,目前只有MyISAM支持空间索引,索引的字段不能Null.</span><br></pre></td></tr></table></figure></blockquote><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在实际的开发过程中,我们需要尽量准确的将查询消耗时间比较久的SQL语句找到,然后再针对性的对其建立索引,再使用explain命令查看这个sql语句的执行详情,查看有没有用到索引,有没有做全表扫描等,对由此分析出的结果,我们进行优化.</span><br></pre></td></tr></table></figure><p>1.日志开启,设置阈值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#默认情况下slow_query_log的值为OFF</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#开启慢日志</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#慢查询日志阈值[超过这个时间的<span class="keyword">sql</span>将被记录在日志中]</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time<span class="operator">=</span><span class="number">0.1</span>; </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果希望修改后永久生效，那就修改my.cnf文件，[mysqld]下增加或修改参数slow_query_log 和slow_query_log_file后，然后重启MySQL服务器。也即将如下四行配置进my.cnf文件</span></span><br><span class="line"></span><br><span class="line">slow_query_log=1</span><br><span class="line">slow_query_log_file=/var/lib/mysql/atguigu-slow.log </span><br><span class="line">long_query_time=3</span><br><span class="line">log_output=FILE</span><br></pre></td></tr></table></figure><p>2.查看慢查询记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看系统中有多少条慢查询记录</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>; </span><br><span class="line"></span><br><span class="line">#查看日志信息内容</span><br><span class="line">#去我们日志存放路径下,用cat命令查看其内容</span><br></pre></td></tr></table></figure><p>3.使用mysqldumpslow命令导出</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g <span class="string">&quot;left join&quot;</span> /var/lib/mysql/atguigu-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">-a: 不将数字抽象成N，字符串抽象成S</span><br><span class="line"></span><br><span class="line">-s: 是表示按照何种方式排序；</span><br><span class="line"></span><br><span class="line">c: 访问次数</span><br><span class="line"></span><br><span class="line">l: 锁定时间</span><br><span class="line"></span><br><span class="line">r: 返回记录</span><br><span class="line"></span><br><span class="line">t: 查询时间</span><br><span class="line"></span><br><span class="line">al:平均锁定时间</span><br><span class="line"></span><br><span class="line">ar:平均返回记录数</span><br><span class="line"></span><br><span class="line">at:平均查询时间</span><br><span class="line"></span><br><span class="line">-t: 即为返回前面多少条的数据；</span><br><span class="line"></span><br><span class="line">-g: 后边搭配一个正则匹配模式，大小写不敏感的；</span><br></pre></td></tr></table></figure></blockquote><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><h4 id="最左原则"><a href="#最左原则" class="headerlink" title="最左原则"></a>最左原则</h4><blockquote><p>1.创建索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_deptid_name <span class="keyword">ON</span> emp(age, deptid, NAME);</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">-查询 age</span><br><span class="line">索引生效</span><br><span class="line">-查询 age 和 deptId</span><br><span class="line">索引生效</span><br><span class="line">-查询 age、deptId 和 name</span><br><span class="line">索引生效</span><br><span class="line">-查询 deptId、name 和 age</span><br><span class="line">索引生效,但原本遵循最左原则是不生效的,但SQL的优化器调整了解析树,使得查询字段符合了索引的顺序,使得索引生效</span><br><span class="line">-仅查询 deptId</span><br><span class="line">索引失效,违背最左原则</span><br></pre></td></tr></table></figure><p>2.为什么MySQL 会如此执着于『最左』字段？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.因为在B+Tree创建的时候,需要对索引值进行排序,如果我们指定的是联合索引,那就要涉及到多个字段的排序,排序的时候肯定是优先根据最左字段进行排序,当最左字段值有相同数据时再对后一个字段进行排序,以此类推.</span><br><span class="line">2.在实际的查询中如果查询条件没有提供最左字段,那么联合索引将不会生效,因为我们首先要根据最左字段通过二分法进行查找.</span><br></pre></td></tr></table></figure><p>3.结论</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">要遵循最左原则，查询字段中至少要有索引中的最左字段作为过滤条件存在。而且就最左原则本身来说，它要求索引最左字段在查询顺序中也最左。只不过只要最左字段出现，优化器会帮我们调整到查询顺序中的最左。而且还有一个要求是：中间不能断。中间一旦断开，后面的就都无法使用索引了。</span><br><span class="line">口诀：带头大哥不能死，中间兄弟不能断</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209292029060.png" alt="image-20220929202931979"></p></blockquote><h4 id="索引失效的其他情况"><a href="#索引失效的其他情况" class="headerlink" title="索引失效的其他情况"></a>索引失效的其他情况</h4><blockquote><p>1.范围查询</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">- 注意点1：创建索引时应该把容易做范围查询的字段往后放</span><br><span class="line">- 注意点2：实际编写 SQL 语句时，做范围查询的字段参照索引中的顺序，也是往后放</span><br></pre></td></tr></table></figure><p>2.where中使用函数</p><p>3.不等于</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">所有不等于操作都会导致索引失效：</span><br><span class="line"></span><br><span class="line">- !=</span><br><span class="line">- &lt;&gt;</span><br><span class="line">- not</span><br></pre></td></tr></table></figure><p>4.like</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">like 条件把 <span class="comment">% 放左边不生效,其他都生效</span></span><br></pre></td></tr></table></figure><p>5.类型转换</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#我们给查询条件传入的参数和原本的类型不一致。但是这种情况不是必然会导致索引失效。</span><br><span class="line"><span class="keyword">where</span> name<span class="operator">=</span><span class="number">123</span>;</span><br></pre></td></tr></table></figure></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.对于单列索引,我们尽量来选择过滤性较好的字段来创建索引,比如手机号,一下能过滤掉很数据</span><br><span class="line">2.对于组合索引,我们尽量使过滤性较好的字段位置靠前,这样可以提前过滤掉很多数据</span><br><span class="line">3.对于组合索引出现了范围查询的时候,我们尽量将范围字段放到最后</span><br><span class="line">4.我们要尽量避免索引失效的情况</span><br><span class="line">5.创建索引字段的时候,我们尽量选择经常查询的字段,并字段值很少改动.因为字段值一改,索引也要跟着修改</span><br><span class="line">6.当一个特殊的查询场景包含多个字段的时候,创建组合索引比单列索引查询快.</span><br><span class="line">7.大部分情况下,一条SQL语句只能用到一个索引,所以索引并不是创建的越多越好.</span><br></pre></td></tr></table></figure></blockquote><h3 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">小表驱动大表</span><br><span class="line">- 小表：相对来说记录较少的表</span><br><span class="line">- 大表：相对来说记录较多的表</span><br><span class="line">驱动方式识别</span><br><span class="line">- left join：左边驱动右边（此时把小表放在左边）</span><br><span class="line">- right join：右边驱动左边（此时把小表放在右边）</span><br><span class="line">加索引的方式</span><br><span class="line">- 通常建议在大表（被驱动）的关联字段上加索引，效率提升更明显。</span><br></pre></td></tr></table></figure></blockquote><h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在实际开发中，能够不用子查询就尽量不用。</span><br></pre></td></tr></table></figure></blockquote><h3 id="排序分组优化"><a href="#排序分组优化" class="headerlink" title="排序分组优化"></a>排序分组优化</h3><blockquote><p>排序</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">- order by 子句需要配合 limit 子句才能让索引生效。</span><br><span class="line">- 如果涉及多个字段的排序，那么这些字段排序的方向要一致（要升序都升序，要降序都降序），否则索引失效。</span><br></pre></td></tr></table></figure><p>分组</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">能写在 where 限定的条件就不要写在 having 中,实现尽早过滤</span><br></pre></td></tr></table></figure></blockquote><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.视图是一张虚表,本身不具有数据</span><br><span class="line">2.视图表建立在已有的基表上</span><br><span class="line">3.视图创建和删除不会影响基表</span><br><span class="line">4.视图数据的更改,基表数据会响应更改,反之亦然.</span><br></pre></td></tr></table></figure></blockquote><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.帮助我们使用表的一部分</span><br><span class="line">2.提供给用户部分的数据</span><br><span class="line">3.保护敏感字段</span><br></pre></td></tr></table></figure></blockquote><h3 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h3><blockquote><p>创建视图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW 视图名称</span><br><span class="line">AS 查询语句</span><br></pre></td></tr></table></figure><p>查看视图详情信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE VIEW 视图名称;</span><br></pre></td></tr></table></figure><p>删除视图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称;</span><br></pre></td></tr></table></figure><p>更新,删除视图数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将 from 后的表名换成视图名 </span><br></pre></td></tr></table></figure></blockquote><p>总结</p><blockquote><p>优点</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 简化操作</span><br><span class="line">经常查询的操作,创建为一个视图,这样的话以后只用对视图进行操作即可,不用再去关心视图对应的基表的结构,表和表的关联关系,简化开发过程.</span><br><span class="line">2. 减少数据冗余</span><br><span class="line">视图本身不存储数据,只存储查询语句,用过查询语句获取结果集,不占用存储的资源,减少数据冗余.</span><br><span class="line">3. 保护数据安全</span><br><span class="line">用户对数据的访问限制在视图上,视图再通过查询语句获取基表的结果集,避免了用户直接访问基表,保障了数据的安全性.</span><br><span class="line">4. 适应多变的需求 </span><br><span class="line">业务需求发生变化,需要改动基表的结构,工作量比较大,可以使用视图减少改动量</span><br></pre></td></tr></table></figure><p>不足</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.如果基表的结构变了，我们就需要及相关的视图进行相应的维护.</span><br><span class="line">2.实际项目中，如果视图过多，会导致数据库维护成本的问题.</span><br></pre></td></tr></table></figure></blockquote><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209081057462.png" alt="image-20220908105738396"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">主从复制,是用来建立一个和主数据库完全一样的数据库环境,称为从数据库</span><br></pre></td></tr></table></figure></blockquote><h3 id="为什么-1"><a href="#为什么-1" class="headerlink" title="为什么"></a>为什么</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209081057736.png" alt="image-20220908105752684"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.读写分离。</span><br><span class="line">2.数据备份。</span><br><span class="line">3.具有高可用性。</span><br><span class="line">4.提高数据库的吞吐量</span><br></pre></td></tr></table></figure></blockquote><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><blockquote><p>主机配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[必须]主服务器唯一ID</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[必须]启用二进制日志,指名路径。比如：自己本地的路径/log/mysqlbin</span></span><br><span class="line">log-bin=atguigu-bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选] 0（默认）表示读写（主机），1表示只读（从机）</span></span><br><span class="line">read-only=0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]设置日志文件保留的时长，单位是秒</span></span><br><span class="line">binlog_expire_logs_seconds=6000</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]控制单个二进制日志大小。此参数的最大和默认值是1GB</span></span><br><span class="line">max_binlog_size=200M</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]设置不要复制的数据库</span></span><br><span class="line">binlog-ignore-db=test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]设置需要复制的数据库,默认全部记录。比如：binlog-do-db=atguigu_master_slave</span></span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]设置binlog格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure><p>从机配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[必须]从服务器唯一ID</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure><p>重启Mysql服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">注意：主从机都关闭防火墙,或开放端口号</span><br><span class="line">systemctl stop firewalld.service #CentOS 7</span><br></pre></td></tr></table></figure><p>主机:建立账户并授权</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在主机MySQL里执行授权主从复制的命令</span></span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;slave1&#x27;@&#x27;从机器数据库IP&#x27; IDENTIFIED BY &#x27;abc123&#x27;;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5.5,5.7</span></span><br></pre></td></tr></table></figure><p>主机查看同步状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><p>从机:配置需要复制的主机</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端执行命令</span></span><br><span class="line">CHANGE MASTER TO</span><br><span class="line">MASTER_HOST=&#x27;主机的IP地址&#x27;,</span><br><span class="line">MASTER_USER=&#x27;主机用户名&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;主机用户名的密码&#x27;,</span><br><span class="line">MASTER_LOG_FILE=&#x27;mysql-bin.具体数字&#x27;,</span><br><span class="line">MASTER_LOG_POS=具体值;</span><br></pre></td></tr></table></figure><p>从机启动slave同步</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端执行命令</span></span><br><span class="line">START SLAVE;</span><br></pre></td></tr></table></figure><p>从机查看同步状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端执行命令</span></span><br><span class="line">SHOW SLAVE STATUS\G;</span><br></pre></td></tr></table></figure></blockquote><h2 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h2><h3 id="垂直拆分-分库"><a href="#垂直拆分-分库" class="headerlink" title="垂直拆分-分库"></a>垂直拆分-分库</h3><h4 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h4><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.将数据库中的表按照业务逻辑拆分到不同的数据库中.</span><br><span class="line">2.垂直拆分:对表做分类</span><br></pre></td></tr></table></figure></blockquote><h4 id="为什么-2"><a href="#为什么-2" class="headerlink" title="为什么"></a>为什么</h4><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.不同业务逻辑的表在相同的数据库中,会加大数据库的压力.</span><br><span class="line">2.垂直拆分数据表,降数据库的压力.</span><br></pre></td></tr></table></figure></blockquote><h3 id="水平拆分-分表"><a href="#水平拆分-分表" class="headerlink" title="水平拆分-分表"></a>水平拆分-分表</h3><h4 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h4><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.按照字段,将一个表拆分为多个表</span><br><span class="line">2.水平拆分:按照字段将表分散到各个库中</span><br></pre></td></tr></table></figure></blockquote><h4 id="为什么-3"><a href="#为什么-3" class="headerlink" title="为什么"></a>为什么</h4><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.当一张表的数据达到千万时,查询一次花费的时间会很久,分表可以缩短查询时间.</span><br><span class="line">2.Mysql具有锁机制,当对表或者行进行操作时,其他用户就不能操作表或行,分表可以加大可操作性</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seata</title>
      <link href="/archives/8d9a091c.html"/>
      <url>/archives/8d9a091c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h2><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">多条SQL语句对数据库进行操作,要么都成功,要么都失败,事务提供了一种机制(&quot;全套&quot;),这个机制将所有涉及到活动的操作纳入到一个不可分割的单元,任何一个操作失败都会导致所有的操作进行回滚.</span><br></pre></td></tr></table></figure></blockquote><h2 id="数据库本地事务"><a href="#数据库本地事务" class="headerlink" title="数据库本地事务"></a>数据库本地事务</h2><h3 id="四大特性-ACID"><a href="#四大特性-ACID" class="headerlink" title="四大特性(ACID)"></a>四大特性(ACID)</h3><blockquote><p>原子性</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">事务开始之后的所有操作,要么全部完成,要么全部不做,所有操作中的某一个操作失败,都会导致所有的操作回滚到事务开始前的状态,事务是一个不可分割的单元,类似于化学中的原子</span><br></pre></td></tr></table></figure><p>一致性</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">事务开始前和事务结束后,数据库的数据的完整性必须保证一致,例如A向B转账,不能A扣了前B却没收到钱</span><br></pre></td></tr></table></figure><p>隔离性</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">每个事务之间都是独立个体的存在,它干它的,我干我的,同一个时间内,只允许一个事务对同一个数据进行操作,当一个事务对同一个数据进行操作的时候,要把这个数据隔离起来,别的事务不能对其数据进行操作</span><br></pre></td></tr></table></figure><p>持久性</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">事务结束后,事务对数据库所有的更新将会被保存到数据库中,不能回滚,对数据库的改变是永久性的</span><br></pre></td></tr></table></figure></blockquote><h3 id="事务并发出现的问题"><a href="#事务并发出现的问题" class="headerlink" title="事务并发出现的问题"></a>事务并发出现的问题</h3><blockquote><p>脏读</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">事务A读取到事务B还未提交的数据,当事务B对数据库进行操作的过程中,还没有提交事务的时候,事务A来读取未提交的数据,会出现脏读的数据,这个数据不一定是最终数据.</span><br></pre></td></tr></table></figure><p>不可重复读</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在一个事务中两次读取了某一个数据,每次读取的结果不同.当A事务第一次读取某一个数据后,B事务将此数据更新并提交了,导致A事务第二次读取时数据前后不一致.导致A事务发生疑惑,我也没修改数据啊,怎么就突然变了.重复读取数据会不一致,我还是不重复读了吧.</span><br></pre></td></tr></table></figure><p>幻读</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在一个事务中两次读取的记录数不一致,在A事务第一个读取表记录数后,B事务添加或删除了一条数据,导致A事务第二次读取表记录数时,数据和第一次不同,导致A事务以为自己出现了幻觉,突然多了,突然少了.</span><br></pre></td></tr></table></figure><p>小贴士💖</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.不可重复读侧重于修改，解决不可重复读只需锁住满足条件的行</span><br><span class="line">2.幻读侧重于新增或删除。解决幻读需要锁表.</span><br></pre></td></tr></table></figure></blockquote><h3 id="四大隔离级别"><a href="#四大隔离级别" class="headerlink" title="四大隔离级别"></a>四大隔离级别</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209221635254.png" alt="image-20220922163525190"></p><p>小贴士💘</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.读未提交</span><br><span class="line">可以说性能是最好的了,压根不加锁,其实谈不上隔离,什么都没隔离.</span><br><span class="line">2.串行化</span><br><span class="line">事务的操作中会加锁,对读的操作加共享锁,别的线程也能来读,可以实现并发读,对写的操作加排它锁,我在写的时候,别的事务不能读也不能写,都等着去.</span><br><span class="line"></span><br><span class="line">Mysql默认事务隔离级别为可重复读</span><br></pre></td></tr></table></figure></blockquote><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">跨库的事务,可以称为分布式事务,分布式事务可以理解为一个包含多个本地事务分支的全局事务,所有的本地事务要么一起成功提交,要么一起回滚失败.</span><br></pre></td></tr></table></figure></blockquote><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><blockquote><p>C(一致性)</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">两台机器之间的数据是实时一致的,每台机器可以看作一个节点,从任一个节点上读取的数据都是最新的数据</span><br></pre></td></tr></table></figure><p>A(可用性)</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">两台机器之间的数据不是实时一致的,从任一个节点上读取的数据可能是旧数据</span><br></pre></td></tr></table></figure><p>P(分区容错性)</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">某一台机器因为某些问题宕机,有其他的机器提供相同的服务</span><br></pre></td></tr></table></figure></blockquote><h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><blockquote><p>BA</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Basic Available 基本可用</span><br><span class="line">1.在一定的时间内任然能够返回一个明确的结果</span><br></pre></td></tr></table></figure><p>S</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Soft State 柔性状态</span><br><span class="line">1.同一数据的不同副本的状态，可以不需要实时一致</span><br></pre></td></tr></table></figure><p>E</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Eventual Consisstency 最终一致性</span><br><span class="line">1.同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。</span><br></pre></td></tr></table></figure></blockquote><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.强一致性</span><br><span class="line">某个节点更新过的数据,能保证此数据在后续节点的访问都能访问到最新的数据</span><br><span class="line">2.弱一致性</span><br><span class="line">某个节点更新过的数据,可能一段时间能访问,也可能一直访问不到最新消息</span><br><span class="line">3.最终一致性[弱一直性的分支]</span><br><span class="line">某个节点更新过的数据,能保证在某个时间端内一定被访问到</span><br></pre></td></tr></table></figure></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="2PC-两端-XA事务模式"><a href="#2PC-两端-XA事务模式" class="headerlink" title="2PC(两端)(XA事务模式)"></a>2PC(两端)(XA事务模式)</h4><blockquote><p>成功情况</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209230844863.png" alt="image-20220923084403788"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&gt;1.准备阶段</span><br><span class="line">&gt;事务管理器向资源管理器发送准备请求,资源管理器开始执行事务操作,事务操作执行完成后返回给事务管理器已完成</span><br><span class="line">&gt;2.提交执行阶段</span><br><span class="line">&gt;事务管理器收到资源管理器的回复的成功消息后向资源管理器发送提交请求,资源管理器收到提交请求后就开始执行事务的提交</span><br></pre></td></tr></table></figure><p>失败情况</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209230844879.png" alt="image-20220923084417823"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&gt;1.准备阶段</span><br><span class="line">&gt;事务管理器向资源管理器发送准备请求,资源管理器开始执行事务操作,事务操作执行过程中出现错误导致执行失败,返回失败消息给事务管理器</span><br><span class="line">&gt;2.提交执行阶段</span><br><span class="line">&gt;如果事务管理器收到任何一个资源管理器执行失败的消息,则向每个资源管理器发送回滚的消息,每个资源管理器收到回滚消息后,根据指令回滚本地事务,释放所有锁的资源</span><br><span class="line">&gt;如果事务管理器收到了任何一个资源管理器失败的消息，则向每个资源管理器发送回滚消息。资源管理器根据事务管理器的指令回滚本地事务操作，释放所有事务处理过程中使用的锁资源。</span><br></pre></td></tr></table></figure><p>小结</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&gt;1.阻塞问题</span><br><span class="line">&gt;一旦一个资源管理器一直失败,则会导致其他资源管理器一直无法提交完成自己的事务</span><br><span class="line">&gt;2.单点故障问题</span><br><span class="line">&gt;一旦一个事务管理器挂掉了,则会导致整个系统不可用</span><br><span class="line">&gt;3.一致性问题</span><br><span class="line">&gt;当事务管理器发送提交消息后,有的资源管理器可能提交失败,所以会导致整个事务不一致,每个节点是数据不一致</span><br></pre></td></tr></table></figure></blockquote><h4 id="3PC-三端"><a href="#3PC-三端" class="headerlink" title="3PC(三端)"></a>3PC(三端)</h4><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">3PC比2PC多了一个询问的阶段,在准备阶段之前多了一个询问阶段,先询问资源管理器能不能执行事务的操作</span><br></pre></td></tr></table></figure><p>小结</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.3PC引入了超时机制,在准备阶段超时的资源管理器,则任务失败,在提交阶段超时的资源管理器,则其他资源管理器不会等待</span><br><span class="line">2.解决了阻塞和单点故障问题</span><br></pre></td></tr></table></figure></blockquote><h4 id="本地消息表-MQ"><a href="#本地消息表-MQ" class="headerlink" title="本地消息表+MQ"></a>本地消息表+MQ</h4><blockquote><p>暂略</p></blockquote><h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">2007的老古董,分为三个阶段,尝试,确定,取消,市面上基本没人用</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. try 尝试阶段 尝试锁定资源</span><br><span class="line">2. confirm 确认阶段 尝试将锁定的资源进行提交</span><br><span class="line">3. cancel 取消阶段 其中某个环节执行失败，将发起事务取消动作</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">TCC适合严格一致性的业务活动,TCC有三个阶段,对应的三个动作,每个动作都要保证幂等性,例如转账业务,三个阶段对应的是冻结,扣钱,解冻</span><br></pre></td></tr></table></figure><p>幂等性</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">多次对数据库的操作,结果都是一直的.</span><br><span class="line">例如:</span><br><span class="line">用户进行支付,因为网络问题,用户多点击了一次支付,系统不会因为用户多点击一次,不会多扣款</span><br></pre></td></tr></table></figure></blockquote><h4 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h4><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Saga的历史比TCC还悠远,可以追述到1987年,核心思想是将长事务拆分为多个短事务,</span><br></pre></td></tr></table></figure></blockquote><h4 id="最大努力补偿"><a href="#最大努力补偿" class="headerlink" title="最大努力补偿"></a>最大努力补偿</h4><blockquote><p>暂略</p></blockquote><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">是一款阿里巴巴开源的分布式事务的解决方案,提供了多种事务模式,(AT、TCC、SAGA 和 XA 等)</span><br></pre></td></tr></table></figure></blockquote><h3 id="三个组件"><a href="#三个组件" class="headerlink" title="三个组件"></a>三个组件</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.Transaction Coordinator (TC)</span><br><span class="line">事务的协调者,维护全局事务和分支事务的运行状态,负责驱动全局事务的提交和回滚</span><br><span class="line">2.Transaction Manager (TM)</span><br><span class="line">事务管理器,复制开启全局事务,提交和回滚事务</span><br><span class="line">3.Resource Manager (RM)</span><br><span class="line">资源管理器,负责本地分支事务的注册,接收事务协调者指令,驱动本地分支事务的提交和回滚</span><br></pre></td></tr></table></figure></blockquote><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.事务管理器向事务协调者申请开启一个全局事务,事务管理器会创建一个全局事务并生成一个全局唯一的XID</span><br><span class="line">2.XID在各个微服务之间调用传递</span><br><span class="line">3.资源管理器向事务协调者注册本地分支事务,并将分支事务纳入到XID对应的全局事务的管辖中</span><br><span class="line">4.事务管理器向事务协调者发起针对XID所绑定的全局事务的全局提交和回滚决议</span><br><span class="line">5.事务协调者调度XID所管辖的全部分支事务使它们完成提交和回滚的请求</span><br></pre></td></tr></table></figure></blockquote><h3 id="两个阶段"><a href="#两个阶段" class="headerlink" title="两个阶段"></a>两个阶段</h3><blockquote><h4 id="一阶段"><a href="#一阶段" class="headerlink" title="一阶段"></a>一阶段</h4><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209230955148.png" alt="image-20220923095551033"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.解析SQL语句,生成一条SQL,先查询当前数据库镜像,保存原镜像</span><br><span class="line">2.执行解析后的SQL语句,查询新的数据库镜像,保存新镜像</span><br><span class="line">3.将两个镜像组成回滚日志,将业务数据的更新和回滚日志放在同一个事务中进行提交,放别插入到不同的表中</span><br><span class="line">4.将提交事务的结果上报给事务协调者</span><br></pre></td></tr></table></figure><h4 id="二阶段-做提交和回滚"><a href="#二阶段-做提交和回滚" class="headerlink" title="二阶段(做提交和回滚)"></a>二阶段(做提交和回滚)</h4><p>全局提交</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209231010446.png" alt="image-20220923101020299"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.各分支事务提交提交完成,之后事务协调者会向分支发送第二阶段请求,分支收到请求会把该请求放在异步队列中</span><br><span class="line">2.异步队列会根据分支的ID查找并删除回滚日志</span><br></pre></td></tr></table></figure><p>全局回滚</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209231010021.png" alt="image-20220923101029847"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.全局回滚会进行查找回滚日志,并解析回滚日志,执行回滚反向更新,完成分支的回滚</span><br></pre></td></tr></table></figure></blockquote><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.添加seata依赖</span><br><span class="line">2.添加配置文件</span><br><span class="line">3.注入数据源</span><br><span class="line">4.每个微服务中添加yml配置 </span><br><span class="line">5.使用@GlobalTransactional开启事务</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Seata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos</title>
      <link href="/archives/c383a3c4.html"/>
      <url>/archives/c383a3c4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><blockquote><p>下载源码</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/alibaba/nacos.git</span><br></pre></td></tr></table></figure><p>单机启动</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209201847477.png" alt="image-20220920184753420"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">-Dnacos.standalone=true</span><br></pre></td></tr></table></figure></blockquote><h2 id="核心功能点"><a href="#核心功能点" class="headerlink" title="核心功能点"></a>核心功能点</h2><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.服务注册</span><br><span class="line">Nacos客户端会向服务端发送REST请求并携带自身的元数据(IP,端口等),请求服务端注册自己的服务,当服务端收到客户端请求后会把客户端请求携带的元数据存储在一个双层Map中</span><br><span class="line">2.服务心跳</span><br><span class="line">当客户端的服务被注册后,客户端会添加一个定时心跳任务默认每隔5秒去通知服务端我还活着,处于可用状态</span><br><span class="line">3.服务健康检查</span><br><span class="line">当客户端的服务被注册,服务端会开启一个定时[它的探测周期是2000毫秒+随件数(5000毫秒内)]的服务健康检查任务来检查注册的服务实例的健康状况,对于超过15秒没有收到客户端心跳的实例,将它(Instance)的healthy属性值改为false(服务发现时不会发现此服务),对于超过30秒没有收到客户端心跳的实例,则将此实例从服务端服务注册中心剔除(如果被剔除的实例恢复心跳则会重新注册)</span><br><span class="line">4.服务发现</span><br><span class="line">服务的消费者(Nacos Client1)在调用服务的提供者(Nacos Client2)时,会先发送一个REST请求给服务端,获取服务端的服务注册信息,并缓存在客户端本地,同时会在客户端本地开启一个定时的任务来拉取服务端最新的服务注册信息更新本地的服务注册表缓存</span><br><span class="line">5.服务同步</span><br><span class="line">服务端集群之间的数据的同步</span><br></pre></td></tr></table></figure></blockquote><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><blockquote><p>架构图</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209201939560.png" alt="image-20220920193920450"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Nacos服务端：作用是提供服务注册、服务发现、服务同步以及服务健康检查功能等。</span><br><span class="line">Nacos客户端：作用是给每一个微服务提供调用方法，跟Nacos服务端进行通信。</span><br><span class="line"></span><br><span class="line">客户端如何与服务端做通信? ==&gt; 使用HTTP</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209201946875.png" alt="image-20220920194614797"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&gt;服务注册表的结构</span><br><span class="line">1.Map&lt;String, Map&lt;String, Service&gt;&gt; ==&gt; Map&lt;namespace, Map&lt;ServiceName, Service&gt;&gt;</span><br><span class="line"></span><br><span class="line">Service.clusterMap  ==&gt;  Map&lt;String, Cluster&gt;</span><br><span class="line">Cluster.ephemeralInstances ==&gt; Set&lt;Instance&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209211247202.png" alt="Nacos-导出 (1)"></p></blockquote><h2 id="源码入口"><a href="#源码入口" class="headerlink" title="源码入口"></a>源码入口</h2><blockquote><p>依赖坐标</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209201948249.png" alt="image-20220920194855197"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">利用SpringBoot的自动装配的原理,依赖对应的包中会有一个spring.factories文件,里面是自动配置的类,找到Key为EnableAutoConfiguration中的NacosDiscoveryAutoConfiguration调用类</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">NacosDiscoveryAutoConfiguration类有三个Bean,最后一个Bean是核心Bean</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">又调用了NacosDiscoveryAutoConfiguration父类AbstractAutoServiceRegistration的构造方法,将NacosServiceRegistry赋值给serviceRegistry</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">NacosAutoServiceRegistration父类实现了ApplicationListener,意味着微服务启动时会执行本类的onApplicationEvent方法,onApplicationEvent由调用了bind(),bind()中又调用了启动方法start(),start()方法中由调用了核心方法register()</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在日志打印中可以看出register()方法在执行到registerInstance()方法之后,服务完成了注册,所以源码的服务注册入口就找到了</span><br></pre></td></tr></table></figure><p>register()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Registration registration)</span> &#123;</span><br><span class="line">    <span class="comment">//获取服务的ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceId</span> <span class="operator">=</span> registration.getServiceId();</span><br><span class="line">    <span class="comment">//获取默认的服务组(&quot;DEFAULT_GROUP&quot;)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="built_in">this</span>.nacosDiscoveryProperties.getGroup();</span><br><span class="line">    <span class="comment">//获取服务的实例(IP,端口,权重,集群名称,元数据)</span></span><br><span class="line">    <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="built_in">this</span>.getNacosInstanceFromRegistration(registration);</span><br><span class="line"><span class="comment">//执行注册</span></span><br><span class="line">    <span class="built_in">this</span>.namingService.registerInstance(serviceId, group, instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>目前的代码都是客户端提供给微服务的代码,并没有涉及到服务端的代码</p></blockquote></blockquote><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><blockquote><p>NacosNamingService.registerInstance()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">//判断是不是临时的实例</span></span><br><span class="line"><span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">  <span class="comment">//设置心跳信息 == &gt;后面服务心跳会详讲</span></span><br><span class="line">  <span class="type">BeatInfo</span> <span class="variable">beatInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeatInfo</span>();</span><br><span class="line">  beatInfo.setServiceName(NamingUtils.getGroupedName(serviceName, groupName));</span><br><span class="line">  beatInfo.setIp(instance.getIp());</span><br><span class="line">  beatInfo.setPort(instance.getPort());</span><br><span class="line">  beatInfo.setCluster(instance.getClusterName());</span><br><span class="line">  beatInfo.setWeight(instance.getWeight());</span><br><span class="line">  beatInfo.setMetadata(instance.getMetadata());</span><br><span class="line">  beatInfo.setScheduled(<span class="literal">false</span>);</span><br><span class="line">  beatInfo.setPeriod(instance.getInstanceHeartBeatInterval());</span><br><span class="line"></span><br><span class="line">  beatReactor.addBeatInfo(NamingUtils.getGroupedName(serviceName, groupName), beatInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用代理类注册服务</span></span><br><span class="line">serverProxy.registerService(NamingUtils.getGroupedName(serviceName, groupName), groupName, instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamingProxy.registerService()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line"> NAMING_LOGGER.info(<span class="string">&quot;[REGISTER-SERVICE] &#123;&#125; registering service &#123;&#125; with instance: &#123;&#125;&quot;</span>,</span><br><span class="line">                    namespaceId, serviceName, instance);</span><br><span class="line"> <span class="comment">//创建参数集合,放入请求需要携带的参数</span></span><br><span class="line"> <span class="keyword">final</span> Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">9</span>);</span><br><span class="line"> params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line"> params.put(CommonParams.SERVICE_NAME, serviceName);</span><br><span class="line"> params.put(CommonParams.GROUP_NAME, groupName);</span><br><span class="line"> params.put(CommonParams.CLUSTER_NAME, instance.getClusterName());</span><br><span class="line"> params.put(<span class="string">&quot;ip&quot;</span>, instance.getIp());</span><br><span class="line"> params.put(<span class="string">&quot;port&quot;</span>, String.valueOf(instance.getPort()));</span><br><span class="line"> params.put(<span class="string">&quot;weight&quot;</span>, String.valueOf(instance.getWeight()));</span><br><span class="line"> params.put(<span class="string">&quot;enable&quot;</span>, String.valueOf(instance.isEnabled()));</span><br><span class="line"> params.put(<span class="string">&quot;healthy&quot;</span>, String.valueOf(instance.isHealthy()));</span><br><span class="line"> params.put(<span class="string">&quot;ephemeral&quot;</span>, String.valueOf(instance.isEphemeral()));</span><br><span class="line"> params.put(<span class="string">&quot;metadata&quot;</span>, JSON.toJSONString(instance.getMetadata()));</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//向服务端发送请求进行实例的注册,请求地址为&quot;/nacos/v1/ns/instance&quot;,请求方式为POST</span></span><br><span class="line"> reqAPI(UtilAndComs.NACOS_URL_INSTANCE, params, HttpMethod.POST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamingProxy.reqAPI()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reqAPI</span><span class="params">(String api, Map&lt;String, String&gt; params, String body, List&lt;String&gt; servers, String method)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> callServer(api, params, body, nacosDomain, method);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamingProxy.callServer()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">callServer</span><span class="params">(String api, Map&lt;String, String&gt; params, String body, String curServer, String method)</span></span><br><span class="line">        <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">//封装请求头信息</span></span><br><span class="line">    List&lt;String&gt; headers = builderHeaders();</span><br><span class="line"><span class="comment">//拼接请求地址</span></span><br><span class="line">    String url;</span><br><span class="line">   </span><br><span class="line">    url = curServer + api;</span><br><span class="line"></span><br><span class="line">    url = HttpClient.getPrefix() + curServer + api;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    HttpClient.<span class="type">HttpResult</span> <span class="variable">result</span> <span class="operator">=</span> HttpClient.request(url, headers, params, body, UtilAndComs.ENCODING, method);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在服务端中会有一个Controller来接受客户端发送的服务注册请求,在naming模块下的com.alibaba.nacos.naming.controllers下的InstanceController类中的register为服务端注册方法</span><br></pre></td></tr></table></figure><p>InstanceController.register()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CanDistro</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@Secured(parser = NamingResourceParser.class, action = ActionTypes.WRITE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//从请求中获取服务名称</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line"> <span class="comment">//从请求中获取namespaceId</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> WebUtils.optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line"> <span class="comment">// 实现注册实例  parseInstance(request)==&gt;解析请求参数中的Instance,并重新赋值</span></span><br><span class="line"> serviceManager.registerInstance(namespaceId, serviceName, parseInstance(request));</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">进入ServiceManager类的registerInstance方法</span><br><span class="line">ServiceManager类可以想象为一个我们写Service层的某个XXXService</span><br></pre></td></tr></table></figure><p>ServiceManager.registerInstance()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此方法创建了服务的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">     <span class="comment">//创建注册表,创建空的Service结构</span></span><br><span class="line">     createEmptyService(namespaceId, serviceName, instance.isEphemeral());</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//添加服务实例</span></span><br><span class="line">     addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p>ServiceManager.createEmptyService()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createServiceIfAbsent</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> local, Cluster cluster)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">//从注册表中获取服务</span></span><br><span class="line"> <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line"><span class="comment">//第一次注册的话,服务肯定是获取不到的</span></span><br><span class="line"> <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//创建服务,创建服务注册表,将服务放进服务注册表中</span></span><br><span class="line">   </span><br><span class="line">        <span class="comment">//创建服务</span></span><br><span class="line">        service = <span class="keyword">new</span> <span class="title class_">Service</span>();</span><br><span class="line">        <span class="comment">//对服务名称,命名空间ID,组名...属性进行赋值</span></span><br><span class="line">     service.setName(serviceName);</span><br><span class="line">             service.setNamespaceId(namespaceId);</span><br><span class="line">        service.setGroupName(NamingUtils.getGroupName(serviceName));</span><br><span class="line">        service.setLastModifiedMillis(System.currentTimeMillis());</span><br><span class="line">        service.recalculateChecksum();</span><br><span class="line">        <span class="keyword">if</span> (cluster != <span class="literal">null</span>) &#123;</span><br><span class="line">            cluster.setService(service);</span><br><span class="line">            <span class="comment">//将与当前服务对象绑定的cluster对Service对象的clusterMap属性赋值</span></span><br><span class="line">            service.getClusterMap().put(cluster.getName(), cluster);</span><br><span class="line">        &#125;</span><br><span class="line">        service.validate();</span><br><span class="line">        <span class="comment">// 1.创建服务注册中心表结构,将刚刚创建的Service添加进去</span></span><br><span class="line">        <span class="comment">// 2.执行Service对象的init()方法,执行定时任务,健康检查</span></span><br><span class="line">        <span class="comment">// 3.健康检查,对实例15,或30秒没有收到客户端发送的心跳,进行处理</span></span><br><span class="line">        <span class="comment">// 4.会从线程池中拿一个线程执行我们的延迟任务,初始化5秒后执行,每隔5秒执行一次</span></span><br><span class="line">        putServiceAndInit(service);</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            addOrReplaceService(service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p>ServiceManager.addInstance()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInstance</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> ephemeral, Instance... ips)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建临时的实例key ==&gt; 很长的一个字符串  里面有emph.&quot;xxxxxcemplh.&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line"></span><br><span class="line"> <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">   </span><br><span class="line">     List&lt;Instance&gt; instanceList = addIpAddresses(service, ephemeral, ips);</span><br><span class="line">        <span class="type">Instances</span> <span class="variable">instances</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instances</span>();</span><br><span class="line"></span><br><span class="line">        instances.setInstanceList(instanceList);</span><br><span class="line">          <span class="comment">//调用DelegateConsistencyServiceImpl.put方法 将服务放入内存中,AP,临时存储</span></span><br><span class="line">        consistencyService.put(key, instances);</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>   DelegateConsistencyServiceImpl.put()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">// 调用DistroConsistencyService.put</span></span><br><span class="line"> mapConsistencyService(key).put(key, value);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>   DistroConsistencyServiceImpl.put()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">//1.将内存注册实例更新到内存注册表中</span></span><br><span class="line"> <span class="comment">//2.同步实例信息到其他服务端集群</span></span><br><span class="line">onPut(key, value);</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> taskDispatcher.addTask(key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>   DistroConsistencyServiceImpl.onPut()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPut</span><span class="params">(String key, Record value)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (KeyBuilder.matchEphemeralInstanceListKey(key)) &#123;</span><br><span class="line">    <span class="comment">//1.将实例包装成一个Datum对象并放到dataStore中</span></span><br><span class="line">     <span class="comment">//2.将我们之前生成的实例key赋值给Datum对象的key属性</span></span><br><span class="line">     Datum&lt;Instances&gt; datum = <span class="keyword">new</span> <span class="title class_">Datum</span>&lt;&gt;();</span><br><span class="line">     datum.value = (Instances) value;</span><br><span class="line">        datum.key = key;</span><br><span class="line">        datum.timestamp.incrementAndGet();</span><br><span class="line">        <span class="comment">//暂时存储</span></span><br><span class="line">        dataStore.put(key, datum);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (!listeners.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将我们客户端传入的一些Key 和一些其他参数封装到按一个Pair对象里面去 然后在丢到内存队列里</span></span><br><span class="line"> <span class="comment">// notifier是一个Runnable,开启一个线程,执行任务</span></span><br><span class="line">    notifier.addTask(key, ApplyAction.CHANGE);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>   Notifier.addTask()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tasks是一个阻塞队列，这里就是把注册实例数据任务放入阻塞队列里。</span></span><br><span class="line">&gt;<span class="comment">//异步任务和内存队列操作,对系统性能有很大帮助</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String datumKey, ApplyAction action)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (services.containsKey(datumKey) &amp;&amp; action == ApplyAction.CHANGE) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (action == ApplyAction.CHANGE) &#123;</span><br><span class="line">     services.put(datumKey, StringUtils.EMPTY);</span><br><span class="line">    &#125;</span><br><span class="line">    tasks.add(Pair.with(datumKey, action));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>   Notifier.run()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//不断的从队列中拿任务,一旦没有任务就会阻塞住</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 异步注册 ==&gt; 并且不会占用cpu,一旦队列中没有消息 那么当前线程就会阻塞住,不会消耗cpu</span></span><br><span class="line">                <span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> tasks.take();</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">datumKey</span> <span class="operator">=</span> (String) pair.getValue0();</span><br><span class="line">         <span class="type">ApplyAction</span> <span class="variable">action</span> <span class="operator">=</span> (ApplyAction) pair.getValue1();</span><br><span class="line">            services.remove(datumKey);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!listeners.containsKey(datumKey)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (RecordListener listener : listeners.get(datumKey)) &#123;</span><br><span class="line">   </span><br><span class="line">                count++;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (action == ApplyAction.CHANGE) &#123;</span><br><span class="line">                     <span class="comment">// 从dataStore中拿取我们刚放入的instance   然后开始真正的注册</span></span><br><span class="line">                        listener.onChange(datumKey, dataStore.get(datumKey).value);</span><br><span class="line">                     <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">   </span><br><span class="line">                    <span class="keyword">if</span> (action == ApplyAction.DELETE) &#123;</span><br><span class="line">                        listener.onDelete(datumKey);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    .......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span> (Loggers.DISTRO.isDebugEnabled()) &#123;</span><br><span class="line">                .......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 即使有异常也不会终止 将异常吃掉了</span></span><br><span class="line">         Loggers.DISTRO.error......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>   Service.onChange()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChange</span><span class="params">(String key, Instances value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">.....</span><br><span class="line"> <span class="comment">// 真正的注册方法在这个里面</span></span><br><span class="line">updateIPs(value.getInstanceList(), KeyBuilder.matchEphemeralInstanceListKey(key));</span><br><span class="line"> .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   Service.updateIPs()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateIPs</span><span class="params">(Collection&lt;Instance&gt; instances, <span class="type">boolean</span> ephemeral)</span> &#123;</span><br><span class="line">......</span><br><span class="line"> <span class="comment">// 真正的逻辑 ==&gt; updateIPs(entryIPs, ephemeral)</span></span><br><span class="line">clusterMap.get(entry.getKey()).updateIPs(entryIPs, ephemeral);</span><br><span class="line"> .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   Cluster.updateIPs(entryIPs, ephemeral);</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.将已经注册的实例列表复制一份,将新的实例和老的实例更新到一个集合中</span><br><span class="line">&gt;2.最终再将此集合更新到真正的服务注册表中</span><br><span class="line">3.更新完实例后会主动推送给客户端  PushService.onApplicationEvent方法  ==&gt; UDP发送</span><br><span class="line"></span><br><span class="line">利用了写实复制思想</span><br><span class="line">1.在线程写的过程中,复制一份实例表副本,其他线程读到都是旧数据</span><br><span class="line">2.在线程真正写完后,会将数据更新会服务注册表</span><br><span class="line">3.解决了并发冲突问题</span><br></pre></td></tr></table></figure></blockquote><h2 id="服务心跳"><a href="#服务心跳" class="headerlink" title="服务心跳"></a>服务心跳</h2><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><blockquote><p> NacosNamingService.registerInstance</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">//临时的实例.发送心跳服务</span></span><br><span class="line"><span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">    <span class="comment">//创建心跳对象</span></span><br><span class="line">    <span class="type">BeatInfo</span> <span class="variable">beatInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeatInfo</span>();</span><br><span class="line">    beatInfo.setServiceName(NamingUtils.getGroupedName(serviceName, groupName));</span><br><span class="line">    beatInfo.setIp(instance.getIp());</span><br><span class="line">    beatInfo.setPort(instance.getPort());</span><br><span class="line">    beatInfo.setCluster(instance.getClusterName());</span><br><span class="line">    beatInfo.setWeight(instance.getWeight());</span><br><span class="line">    beatInfo.setMetadata(instance.getMetadata());</span><br><span class="line">    beatInfo.setScheduled(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//设置心跳周期,默认5秒</span></span><br><span class="line">    beatInfo.setPeriod(instance.getInstanceHeartBeatInterval());</span><br><span class="line"><span class="comment">//向服务端发送心跳请求</span></span><br><span class="line">    beatReactor.addBeatInfo(NamingUtils.getGroupedName(serviceName, groupName), beatInfo);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> BeatReactor.addBeatInfo</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeatInfo</span><span class="params">(String serviceName, BeatInfo beatInfo)</span> &#123;</span><br><span class="line">  .....</span><br><span class="line">  <span class="comment">//在线程池中添加一个心跳任务 ==&gt; new BeatTask(beatInfo)</span></span><br><span class="line">  executorService.schedule(<span class="keyword">new</span> <span class="title class_">BeatTask</span>(beatInfo), beatInfo.getPeriod(), TimeUnit.MILLISECONDS);</span><br><span class="line">  MetricsMonitor.getDom2BeatSizeMonitor().set(dom2Beat.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> BeatTask.run</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//设置下一次心跳服务时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">nextTime</span> <span class="operator">=</span> beatInfo.getPeriod();</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//发送心跳服务</span></span><br><span class="line">    serverProxy.sendBeat(beatInfo, BeatReactor.<span class="built_in">this</span>.lightBeatEnabled);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//执行延迟任务,每隔5秒执行一次</span></span><br><span class="line">    executorService.schedule(<span class="keyword">new</span> <span class="title class_">BeatTask</span>(beatInfo), nextTime, TimeUnit.MILLISECONDS);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><blockquote><p> InstanceController.beat</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CanDistro</span></span><br><span class="line"> <span class="meta">@PutMapping(&quot;/beat&quot;)</span></span><br><span class="line"> <span class="meta">@Secured(parser = NamingResourceParser.class, action = ActionTypes.WRITE)</span></span><br><span class="line"> <span class="keyword">public</span> JSONObject <span class="title function_">beat</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="comment">//1.解析请求携带的参数</span></span><br><span class="line">     <span class="comment">//2.构建所需参数</span></span><br><span class="line">     <span class="comment">//3.获取Instance实例,没有就注册</span></span><br><span class="line">     <span class="comment">//4.获取Service对象,没有就创建,注册</span></span><br><span class="line">     <span class="comment">//5.processClientBeat ==&gt; 具体处理逻辑</span></span><br><span class="line">     service.processClientBeat(clientBeat);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> Service.processClientBeat</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processClientBeat</span><span class="params">(<span class="keyword">final</span> RsInfo rsInfo)</span> &#123;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    <span class="type">ClientBeatProcessor</span> <span class="variable">clientBeatProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientBeatProcessor</span>();</span><br><span class="line">    clientBeatProcessor.setService(<span class="built_in">this</span>);</span><br><span class="line">    clientBeatProcessor.setRsInfo(rsInfo);</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    HealthCheckReactor.scheduleNow(clientBeatProcessor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ClientBeatProcessor.run()</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    instance.setLastBeat(System.currentTimeMillis());</span><br><span class="line">    <span class="comment">//因为客户端发送了心跳,所以我们要把那些不健康的服务,更新为健康的</span></span><br><span class="line">    <span class="keyword">if</span> (!instance.isMarked()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance.isHealthy()) &#123;</span><br><span class="line">            instance.setHealthy(<span class="literal">true</span>);</span><br><span class="line">            Loggers.EVT_LOG.info(<span class="string">&quot;service: &#123;&#125; &#123;POS&#125; &#123;IP-ENABLED&#125; valid: &#123;&#125;:&#123;&#125;@&#123;&#125;, region: &#123;&#125;, msg: client beat ok&quot;</span>,</span><br><span class="line">                                 cluster.getService().getName(), ip, port, cluster.getName(), UtilsAndCommons.LOCALHOST_SITE);</span><br><span class="line">            <span class="comment">//向客户端重新推送新的健康服务</span></span><br><span class="line">            getPushService().serviceChanged(service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="服务健康检查"><a href="#服务健康检查" class="headerlink" title="服务健康检查"></a>服务健康检查</h2><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在服务注册的时候会服务端会执行一个Service.init()方法,进行服务的健康检查</span><br></pre></td></tr></table></figure><p>Service.init()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行定时任务 ==&gt; 传入参数是我们客户端心跳检测任务</span></span><br><span class="line">    HealthCheckReactor.scheduleCheck(clientBeatCheckTask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Cluster&gt; entry : clusterMap.entrySet()) &#123;</span><br><span class="line">        entry.getValue().setService(<span class="built_in">this</span>);</span><br><span class="line">        entry.getValue().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClientBeatCheckTask.run()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时的服务健康检查任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 获取我们服务端的所有实例</span></span><br><span class="line">    List&lt;Instance&gt; instances = service.allIPs(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历实例,检查所有实例的健康状态</span></span><br><span class="line">    <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line">        <span class="comment">// 如果当前时间=上一次心跳时间&gt;15s 则标记instance.setHealthy(false);</span></span><br><span class="line">        <span class="keyword">if</span> (当前时间 - 上次心跳时间 &gt; 15s) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//超过15秒没有收到客户端心跳,设置健康属性值Healthy=false</span></span><br><span class="line">            instance.setHealthy(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//并向服务请推送新的实例健康状态</span></span><br><span class="line">            getPushService().serviceChanged(service);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (当前时间 - 上次心跳时间 &gt; 30s) &#123;</span><br><span class="line">            <span class="comment">// 剔除实例</span></span><br><span class="line">            deleteIP(instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/archives/aa55683f.html"/>
      <url>/archives/aa55683f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="程序-进程-线程"><a href="#程序-进程-线程" class="headerlink" title="程序 进程 线程"></a>程序 进程 线程</h3><blockquote><p>程序 </p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.静态的概念</span><br><span class="line">2.源程序,应用程序,都可笼统的称为程序</span><br></pre></td></tr></table></figure><p>进程 </p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.动态的概念</span><br><span class="line">2.程序运行起就是一个进程</span><br><span class="line">3.QQ,WChat,都是一个个进程</span><br></pre></td></tr></table></figure><p>线程</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.一个进程中有多个任务,每单独的一个任务需要一个线程来处理</span><br><span class="line">2.笼统的可以称为进程是线程的容器</span><br></pre></td></tr></table></figure></blockquote><h3 id="串行-并行-并发"><a href="#串行-并行-并发" class="headerlink" title="串行 并行 并发"></a>串行 并行 并发</h3><blockquote><p>串行</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">一个线程执行多个操作,多个操作要排队等待执行</span><br></pre></td></tr></table></figure><p>并行 </p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">多个CPU核同时执行多个任务,核数和任务数一一对应</span><br></pre></td></tr></table></figure><p>并发<br> <figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">单个CPU核同时执行多个任务</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="sleep-和wait-区别"><a href="#sleep-和wait-区别" class="headerlink" title="sleep()和wait()区别"></a>sleep()和wait()区别</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.sleep()会让线程拿着锁去睡</span><br><span class="line">2.wait()会让线程放开锁去睡</span><br></pre></td></tr></table></figure></blockquote><h2 id="多线程创建"><a href="#多线程创建" class="headerlink" title="多线程创建"></a>多线程创建</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><blockquote><p>步骤</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.继承 Thread 类</span><br><span class="line">2.重写 run() 方法</span><br><span class="line">3.创建 Thread 子类对象</span><br><span class="line">4.调用 start() 方法启动线程</span><br></pre></td></tr></table></figure><p>实现代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoThread</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoThread</span>(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">        demo.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoThread</span><span class="params">(String threadName)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(threadName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; thread working ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><blockquote><p> 实现 Runnable 接口形式</p> <figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><p> 匿名内部类形式</p> <figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><p> Lambda 表达式形式</p> <figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure></blockquote><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><blockquote><p>步骤</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.使用Executors.newFixedThreadPool(线程池数量)创建ExecutorService对象</span><br><span class="line">2.使用ExecutorService对象的execute()分配任务,每个任务就是一个线程</span><br><span class="line">3.execute()方法参数实现Runnable接口,写具体的线程操作.</span><br></pre></td></tr></table></figure><p>参考代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建线程池对象</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.给线程池对象分配任务，每一个任务是一个线程</span></span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h3 id="FutureTask-Callable"><a href="#FutureTask-Callable" class="headerlink" title="FutureTask+Callable"></a>FutureTask+Callable</h3><blockquote><p>和Runnable区别</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209151508761.png" alt="image-20220915150859690"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.我们直接再new Thread()的第一个参数中实现Runnable接口,在接口中写线程执行的操作,这样我们拿不到线程执行后的结果,因为Runnable接口中的run方法是没有返回值的</span><br><span class="line">2.Callable接口中的call方法是可以指定返回值的</span><br></pre></td></tr></table></figure><p>FutureTask 类的构造器</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209151511941.png" alt="image-20220915151124892"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="built_in">this</span>.callable = callable;</span><br><span class="line">  <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据这个构造器，我们知道，创建 FutureTask 对象时，传入一个 Callable 类型的对象即可</span></span><br></pre></td></tr></table></figure><p>Callable 接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从 call() 方法的声明我们可以看出，它有一个返回值。这个返回值可以将当前线程内计算结果返回</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建三个FutureTask对象，封装三个线程的执行逻辑</span></span><br><span class="line">FutureTask&lt;Integer&gt; task01 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * Math.random() * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line">FutureTask&lt;Integer&gt; task02 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * Math.random() * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line">FutureTask&lt;Integer&gt; task03 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * Math.random() * <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建三个线程对象，然后启动线程</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task01, <span class="string">&quot;thread01&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task02, <span class="string">&quot;thread02&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task03, <span class="string">&quot;thread03&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.上面三个线程执行完成后，可以收集它们各自运算的结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">task01Result</span> <span class="operator">=</span> task01.get();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">task02Result</span> <span class="operator">=</span> task02.get();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">task03Result</span> <span class="operator">=</span> task03.get();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;task01Result = &quot;</span> + task01Result);</span><br><span class="line">System.out.println(<span class="string">&quot;task02Result = &quot;</span> + task02Result);</span><br><span class="line">System.out.println(<span class="string">&quot;task03Result = &quot;</span> + task03Result);</span><br></pre></td></tr></table></figure></blockquote><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><blockquote> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明成员变量维护票库存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line">    <span class="comment">// 变量类型：java.util.concurrent.locks.Lock 接口</span></span><br><span class="line">    <span class="comment">// 对象类型：Lock 接口的最常用的实现类 ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明卖票的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saleTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            lock.lock(); <span class="comment">// synchronized (this) &#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 卖票的核心操作</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖了一张，还剩 &quot;</span> + --stock + <span class="string">&quot; 张票。&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖完了。&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock(); <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建当前类对象</span></span><br><span class="line">        <span class="type">Demo01HelloWorld</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo01HelloWorld</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开启三个线程调用卖票方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                demo.saleTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-01&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                demo.saleTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-02&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                demo.saleTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-03&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.确保锁被释放</span><br><span class="line"></span><br><span class="line">使用 Lock API 实现同步操作，是一种面向对象的编码风格。这种风格有很大的灵活性，同时可以在常规操作的基础上附加更强大的功能。但是也要求编写代码更加谨慎：如果忘记调用 lock.unlock() 方法则锁不会被释放，从而造成程序运行出错。</span><br><span class="line"></span><br><span class="line">2.加锁和解锁操作对称执行</span><br><span class="line"></span><br><span class="line">不管同步操作是一层还是多层，有多少个加锁操作，就应该相应的有多少个解锁操作。</span><br><span class="line"></span><br><span class="line">3.避免锁对象的线程私有化</span><br><span class="line"></span><br><span class="line">锁对象如果是线程内部自己创建的，是自己独占的，其它线程访问不到这个对象，那么这个锁将无法实现『排他』效果，说白了就是：锁不住。</span><br></pre></td></tr></table></figure></blockquote><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>void lock()</td><td>加同步锁，如果没有得到锁会一直等</td></tr><tr><td>void unlock()</td><td>解除同步锁</td></tr><tr><td>boolean tryLock()</td><td>尝试获取锁。如果没有获取到则立即返回，不做任何等待<br>返回 true：表示获取成功  <br>返回 false：表示获取失败</td></tr><tr><td>boolean tryLock(long time, TimeUnit unit)</td><td>尝试获取锁，且等待指定时间<br>返回 true：表示获取成功  <br>返回 false：表示获取失败</td></tr><tr><td>void lockInterruptibly()</td><td>以『支持响应中断』的模式获取锁</td></tr><tr><td>Condition newCondition()</td><td>获取用于线程间通信的 Condition 对象</td></tr></tbody></table></blockquote><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">全类名：java.util.concurrent.locks.ReentrantLock</span><br><span class="line"></span><br><span class="line">这是 Lock 接口最典型、最常用的一个实现类。</span><br></pre></td></tr></table></figure><p>基本用法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.将解锁操作lock.unlock()放在finally&#123;&#125;中</span></span><br><span class="line"><span class="comment">//2.加锁和解锁的操作要对称,加速后一定要解锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步代码部分</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证可重入性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;外层加锁成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;内层加锁成功&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;内层解锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;外层解锁成功&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><blockquote><p>概念</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.在实际的开发场景中,线程的读操作不会改变数据的值,所以多个线程进行读操作是不会存在线程安全问题的</span><br><span class="line">2.但如果很多个线程同时在进行读操作,一个线程来进行写操作时,就不应该允许其他线程进行任何操作</span><br><span class="line"></span><br><span class="line">实现</span><br><span class="line">1.Java并发包java.util.concurrent下提供了读写锁ReentrantReadWriteLock</span><br><span class="line">2.它表示了两个锁,一个读锁(共享锁),一个写锁(独占锁,互斥锁,排它锁)</span><br></pre></td></tr></table></figure><p>重要特性</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.公平选择性</span><br><span class="line">支持公平和非公平锁,默认非公平锁,因为非公平锁的吞吐量高</span><br><span class="line">2.重进入</span><br><span class="line">两个锁都单方面的支持线程的可重入性</span><br><span class="line">一个线程中加读锁后还能继续加读锁</span><br><span class="line">一个线程中加写锁后还能继续加写锁</span><br><span class="line">3.锁降级</span><br><span class="line">一个线程中,读锁不能升级为写锁</span><br><span class="line">一个线程中,写锁可以降级为读锁</span><br><span class="line"></span><br><span class="line">提示</span><br><span class="line">1.一个线程占用了读锁,另外的一个线程如果想要申请写锁的话,要等读锁的这个线程将读锁释放才行,但另外一个线程想申请读锁的话时可以的.</span><br><span class="line">2.一个线程占用了写锁,另外的一个线程如果想要申请写锁或读锁都是不可以的,都要等待写锁释放</span><br></pre></td></tr></table></figure></blockquote><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><blockquote><p>入门</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockConditionWayDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建同步锁对象</span></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//创建条件对象(控制线程间通信)</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">//操作数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data + 1 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doIncr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为了避免虚假唤醒问题：使用 while 结构进行循环判断</span></span><br><span class="line">            <span class="comment">// 判断当前线程是否满足执行核心操作的条件</span></span><br><span class="line">            <span class="keyword">while</span> (data == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 满足条件时，不该当前线程干活，所以进入等待状态</span></span><br><span class="line">                condition.await();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不满足上面的条件时，说明该当前线程干活了，所以执行核心操作</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行 + 1 操作，data = &quot;</span> + ++data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自己的任务完成后，叫醒其它线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data - 1 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doDecr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为了避免虚假唤醒问题：使用 while 结构进行循环判断</span></span><br><span class="line">            <span class="comment">// 判断当前线程是否满足执行核心操作的条件</span></span><br><span class="line">            <span class="keyword">while</span> (data == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 满足条件时，不该当前线程干活，所以进入等待状态</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不满足上面的条件时，说明该当前线程干活了，所以执行核心操作</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行 - 1 操作，data = &quot;</span> + --data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自己的任务完成后，叫醒其它线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建当前类的对象</span></span><br><span class="line">        <span class="type">LockConditionWayDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockConditionWayDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建四个线程，两个 + 1，两个 - 1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.doIncr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-add A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.doDecr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-sub A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.doIncr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-add B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.doDecr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-sub B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义线程间通信</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockConditionWayDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建同步锁对象</span></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//创建条件对象(控制线程间通信)</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (data % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                conditionA.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;A&quot;</span>);</span><br><span class="line">            data++;</span><br><span class="line">            conditionB.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (data % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                conditionB.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;B&quot;</span>);</span><br><span class="line">            data++;</span><br><span class="line">            conditionA.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建当前类的对象</span></span><br><span class="line">        <span class="type">LockConditionWayDemo1</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockConditionWayDemo1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                demo.toA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                demo.toB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Lock-与-synchronized-对比"><a href="#Lock-与-synchronized-对比" class="headerlink" title="Lock 与 synchronized 对比"></a>Lock 与 synchronized 对比</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在实际开发时，如果synchronized能够满足需要，那就使用synchronized，毕竟它自动加锁、解锁，代码简单。</span><br><span class="line">如果synchronized无法满足需求，只能使用Lock。</span><br></pre></td></tr></table></figure><p>相同点</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.都支持独占锁</span><br><span class="line">2.都支持可重入</span><br></pre></td></tr></table></figure><p>不同点</p><table><thead><tr><th></th><th>Lock 系列 API 用法</th><th>synchronized 用法</th></tr></thead><tbody><tr><td>加锁/解锁</td><td>手动</td><td>自动</td></tr><tr><td>支持共享锁</td><td>√</td><td>×</td></tr><tr><td>支持尝试获取锁失败  <br>后执行特定操作</td><td>√</td><td>×</td></tr><tr><td>灵活</td><td>√</td><td>×</td></tr><tr><td>便捷</td><td>×</td><td>√</td></tr><tr><td>响应中断</td><td>lockInterruptibly()  <br>方式支持阻塞状态响应中断</td><td>sleep()  <br>睡眠后支持响应中断</td></tr><tr><td>代码风格</td><td>面向对象</td><td>面向过程</td></tr><tr><td>底层机制</td><td>AQS（volatile + CAS + 线程的双向链表）= 非阻塞同步</td><td>阻塞同步</td></tr></tbody></table></blockquote><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><h3 id="锁膨胀机制"><a href="#锁膨胀机制" class="headerlink" title="锁膨胀机制"></a>锁膨胀机制</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在JDK1.6之前,synchronized锁的底层工作机制只有重量级锁,从1.6开始,为了减少重量级锁频繁的获得锁和释放锁带来的性能的消耗,所以引入了『偏向锁』和『轻量级锁』</span><br></pre></td></tr></table></figure><p>锁的状态</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.无锁</span><br><span class="line">锁所在的那个对象刚创建出来,还没有线程来执行同步代码块</span><br><span class="line">2.偏向锁</span><br><span class="line">只有唯一的一个线程来访问对象,没有必要获得锁和释放锁,例如世界就一个房子,没有必要锁门,我们只需要在这个对象头中的偏向锁的Mark Word结构中在thread上把这个线程的ID记录下来,等到这个线程下次再来,就无需获得锁,可以随意穿梭,省去大量关于锁的操作.</span><br><span class="line">3.轻量级锁</span><br><span class="line">当有第二个线程来申请锁,两个线程不存在竞争关系,一前一后交替执行同步块,</span><br><span class="line">4.重量级锁</span><br><span class="line">多个线程来竞争锁,各个线程之间存在竞争关系</span><br></pre></td></tr></table></figure></blockquote><h3 id="对象存储结构"><a href="#对象存储结构" class="headerlink" title="对象存储结构"></a>对象存储结构</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.对象头</span><br><span class="line">非数组对象</span><br><span class="line">    Mark Word</span><br><span class="line">    类型指针</span><br><span class="line">数组</span><br><span class="line">    Mark Word</span><br><span class="line">    类型指针</span><br><span class="line">    数组长度</span><br><span class="line">2.对象体</span><br><span class="line">3.对齐字节</span><br></pre></td></tr></table></figure><p>对象头</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.分类</span><br><span class="line">==&gt;非数组对象 MarkWord, 类型指针</span><br><span class="line">==&gt;数组      MarkWord, 类型指针, 数组长度</span><br><span class="line">2.MarkWord</span><br><span class="line">对象的运行时信息,对不中不同的锁状态有五种不同的结构</span><br><span class="line">3.类型指针</span><br><span class="line">指向这个对象对应方法区的类</span><br><span class="line">4.数组长度</span><br></pre></td></tr></table></figure><p>对象体</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">对象本身的数据</span><br></pre></td></tr></table></figure><p>对齐字节</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">填充数据,让这个对象的大小为8字节的整数倍</span><br></pre></td></tr></table></figure></blockquote><h3 id="MarkWord五种状态"><a href="#MarkWord五种状态" class="headerlink" title="MarkWord五种状态"></a>MarkWord五种状态</h3><blockquote><p>1.无锁</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162057391.png" alt="image-20220916205753316"></p><p>2.偏向锁</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162058607.png" alt="image-20220916205808541"></p><p>3.轻量级锁</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162058209.png" alt="image-20220916205819138"></p><p>4.重量级锁</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162058496.png" alt="image-20220916205828434"></p><p>5.GC</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162058173.png" alt="image-20220916205838107"></p></blockquote><h3 id="对象监视器"><a href="#对象监视器" class="headerlink" title="对象监视器"></a>对象监视器</h3><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>;  <span class="comment">// 锁计数器</span></span><br><span class="line">    _waiters      = <span class="number">0</span>;</span><br><span class="line">    _recursions   = <span class="number">0</span>; <span class="comment">// 锁的重入次数</span></span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL; <span class="comment">// 指向持有 ObjectMonitor 对象的线程</span></span><br><span class="line">    _WaitSet      = NULL; <span class="comment">// 处于 wait 状态的线程，会被加入到 _WaitSet（等待队列）</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">// 处于等待锁 block 状态的线程，会被加入到该列表（阻塞队列）</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Lock底层原理"><a href="#Lock底层原理" class="headerlink" title="Lock底层原理"></a>Lock底层原理</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><p>概念</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.Java内存模型</span><br><span class="line">2.CPU和内存之间的一层高速缓存层,这个缓存层存在与CPU内</span><br><span class="line">3.CPU从高速缓存中读取数据,对数据修改后,再通过高速缓存区同步给内存</span><br></pre></td></tr></table></figure><p>Java内存模型</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.主内存</span><br><span class="line">各线程之间共享的数据区域</span><br><span class="line">2.本地内存</span><br><span class="line">每个线程自己私有的数据区域</span><br></pre></td></tr></table></figure><p>作用</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.为了解决缓存一致性的问题</span><br><span class="line">不同的线程会从主内存读取同一个数据,又做了不同的修改,那么各个线程从本地内存同步给主内存的时候,又以哪个线程的修改结果为准呢?这就是缓存一致性的问题</span><br></pre></td></tr></table></figure><p>缓存一致性涉及的三个具体问题</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.原子性</span><br><span class="line">2.可见性</span><br><span class="line">3.有序性</span><br></pre></td></tr></table></figure></blockquote><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote><p>概念</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.一个操作是不可分割的,拿我们就可以说这个操作是原子操作</span><br><span class="line">2.非原子性的操作会引发线程安全问题,比如i++,++i等,看似一步操作,实则底层有两步操作</span><br><span class="line">3.有例如再JMM内存结构中,两个线程同时读取主内存的数据,各自修改后push将修改的数据返回给主内存的时候,会出现数据覆盖现象,</span><br><span class="line"></span><br><span class="line">怎么解决</span><br><span class="line">1.使用同步锁</span><br><span class="line">2.使用Java的concurrent包下面的原子类</span><br></pre></td></tr></table></figure><p>使用同步锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将累加方法修改为同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; data = &quot;</span> + ++data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用原子类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明成员变量作为操作对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 累加方法还是非同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; data = &quot;</span> + data.incrementAndGet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种解决方案的比较</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.当使用同步锁机制,先生产环境下,并发量的增加会导致锁的状态升级为重量级锁,重量级锁会涉及到锁的获取和释放,比较消耗性能</span><br><span class="line">2.原子类结合AQS和CAS使得减少消耗系统的性能</span><br></pre></td></tr></table></figure></blockquote><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><blockquote><p>概念</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.每个线程对自己本地内存的操作,其他线程是不可见的.</span><br><span class="line">2.使用volatile关键字修饰变量,可以使得一个线程对数据的修改是其他线程知道</span><br><span class="line">3.一个线程对本地内存数据的修改其他线程是否可见</span><br></pre></td></tr></table></figure></blockquote><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.在CPU执行指令,JVM编译源程序之后,系统内部会进行指令重排.</span><br><span class="line">2.保证程序的运行结果一致的情况下,优化系统内部的效率</span><br></pre></td></tr></table></figure></blockquote><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><blockquote><p>概念</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.当一个线程对被volatile修饰的变量进行操作的时候,JMM会将该线程对应的本地内存的变量的值flush到主内存中</span><br><span class="line">2.当一个线程对被volatile修饰的变量的值进行读取操作时,JMM会将该线程的本地内存的变量只置为无效,然后再去读取主内存中的变量的值</span><br><span class="line">3.所以volatile关键字可以保证各个线程之间的变量值的操作时可见性的</span><br><span class="line">4.volatile关键字能保证有序性</span><br></pre></td></tr></table></figure></blockquote><h3 id="CAS机制"><a href="#CAS机制" class="headerlink" title="CAS机制"></a>CAS机制</h3><blockquote><p>概念</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.比较交换</span><br><span class="line">2.原子类中我们大量的用到了CAS</span><br></pre></td></tr></table></figure><p>具体过程</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.当一个线程对本地内存中的数据进行修改的过程中,会调用Atomic原子类中的方法,方法又会调用Unsafe类对象中的方法进行操作,再调用这个类方法的时候会将此变量在主内存中的地址值和旧值和新值传入</span><br><span class="line">4.在Unsafe对象在进行操作的时候,会使用到CAS机制,先去找到主内存中地址值所对应的变量的值,然后再去判断旧值是否和主内存中的值是否一直.如果一致则将本地内存的旧值改为新值,再执行store指令将新值同步给主内存,然后再执行write指令将新值写入主内存对应的地址值中.</span><br><span class="line">5.如果CAS机制比较后值不相同,则不能修改,随后开始自旋,重新尝试修改</span><br></pre></td></tr></table></figure><p>非阻塞同步</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.不用阻塞线程就能达到同步的效果</span><br><span class="line"></span><br><span class="line">为什么AtomicInteger方式对比synchronized方式性能优势非常明显?</span><br><span class="line">1.AtomicInteger搭配CAS机制不需要阻塞线程就能达到同步的效果</span><br><span class="line">2.synchronized因为需要加锁解锁操作所以会比较慢,需要阻塞线程实现同步效果</span><br></pre></td></tr></table></figure><p>ABA问题</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">一个不允许线程执行的操作,因为数据发生的变化,又可以进行操作了</span><br><span class="line"></span><br><span class="line">解决方法</span><br><span class="line">1.加版本号</span><br></pre></td></tr></table></figure><p>AtomicInteger类</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">整合了CAS机制和volatile,解决了缓存不一致问题</span><br><span class="line"></span><br><span class="line">满足JMM三大特性</span><br><span class="line">1.原子性: 俺原子类嘞</span><br><span class="line">2.可见性: 有volatile</span><br><span class="line">3.有序性: 有volatile</span><br></pre></td></tr></table></figure></blockquote><h3 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.ReentrantLock是Lock接口最常用的一个实现类,这个实现类内部又有多个内部类,这几个内部类是公平锁和非公平锁等,我们一般默认使用的是非公平锁NonfairSync,NonfairSync继承了Sync,Sync继承了AQS,NonfairSync重写了夫类的tryAcquire方法</span><br><span class="line">2.当一个线程进入lock方法时候,会先判断是否有其他线程占用,如果没有,则将当前线程设置为独占,state值+1</span><br><span class="line">3.当一个线程再次进入lock方法的时候,此时发现当前资源已被其他线程占用,则进入else执行acquire(1);</span><br><span class="line">4.acquire方法内部执行if(!tryAcquire(arg) <span class="built_in">&amp;</span><span class="built_in">&amp;</span> acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">5.tryAcquire方法是本类重写的方法,tryAcquire方法又调用了父类Sync的nonfairTryAcquire()方法</span><br><span class="line">6.nonfairTryAcquire()方法中先再次判断了资源是否被独占,如果没有被独占,则当前线程就独占它</span><br><span class="line">7.如果还是被独占,那就判断独占的线程是不是自己本身,如果是的话,可重入次数+1,也就是state值+1</span><br><span class="line">8.如果不是自己,那就返回false;回到acquire方法执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">9.addWaiter方法中将当前线程封装成一个节点对象,然后判断双向链表最后一个节点是否有值,如果有值,就把最后一个节点向前移一位,自己放在最后一个节点上</span><br><span class="line">10.解锁的时候调用ReentrantLock的unlock方法,中调用Sync的tryRelease方法,state减去相应的值,释放锁</span><br></pre></td></tr></table></figure></blockquote><h2 id="集合线程安全"><a href="#集合线程安全" class="headerlink" title="集合线程安全"></a>集合线程安全</h2><blockquote><p>List</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">CopyOnWriteArrayList</span><br><span class="line">1.使用写时复制技术,向集合中写入数据时,先把整个集合复制一份</span><br><span class="line">2.将新数据写入的复制的集合中</span><br><span class="line">3.再让旧集合变量指向新集合2</span><br><span class="line"></span><br><span class="line">优点：写操作还是要加独占锁(一个一个)，这方面没区别；读操作允许并发执行，效率提升。</span><br><span class="line">缺点：由于需要把集合对象整体复制一份，所以对内存的消耗很大</span><br></pre></td></tr></table></figure><p>Set</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">CopyOnWriteArraySet</span><br><span class="line">//同理CopyOnWriteArrayList</span><br></pre></td></tr></table></figure><p>Map</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap</span><br><span class="line">加入锁分段技术</span><br><span class="line">1.将一个集合中的数据分段来加锁</span><br><span class="line">2.降低线程间的竞争概率</span><br><span class="line"></span><br><span class="line">假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</span><br></pre></td></tr></table></figure></blockquote><h2 id="工具类和Fork-Join框架"><a href="#工具类和Fork-Join框架" class="headerlink" title="工具类和Fork-Join框架"></a>工具类和Fork-Join框架</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指定一个操作步骤数量，在各个子线程中，每完成一个任务就给步骤数量 - 1；在步骤数量减到0之前，CountDownLatch 可以帮我们把最后一步操作抑制住（阻塞），让最后一步操作一直等到步骤被减到 0 的时候执行。</span><br></pre></td></tr></table></figure><p>班长锁门(有六名同学在值日，班长负责锁门。班长必须确保所有同学都离开教室再锁门)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个变量，用来保存同学的数量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">stuNum</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建CountDownLatch对象</span></span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(stuNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建和同学数量相等的线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stuNum; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> String.valueOf(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成一次操作</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + num + <span class="string">&quot;号同学离开教室&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让countDownLatch管理的数量-1</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让countDownLatch负责将最后一步操作抑制住</span></span><br><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;班长锁门&quot;</span>);</span><br></pre></td></tr></table></figure><p>集齐七颗龙珠召唤神龙</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明龙珠数量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dragonBall</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建CountdownLatch对象</span></span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(dragonBall);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建七个线程收集龙珠</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;现在拿到了&quot;</span> + num + <span class="string">&quot;号龙珠&quot;</span>);</span><br><span class="line"></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让countDownLatch对象抑制最后一步</span></span><br><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;龙珠集齐，召唤神龙&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">支持多线程在执行各自任务的时候，到达某个状态点就等待，等所有线程都到达这个状态点再继续执行后步骤。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoO19CyclicBarrierTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; matrix = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        matrix.add(Arrays.asList(<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;special&quot;</span>,<span class="string">&quot;end&quot;</span>));</span><br><span class="line">        matrix.add(Arrays.asList(<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;special&quot;</span>,<span class="string">&quot;end&quot;</span>));</span><br><span class="line">        matrix.add(Arrays.asList(<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;special&quot;</span>,<span class="string">&quot;end&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建CyclicBarrier对象</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建3个线程分别执行各自的任务</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;String&gt; list = matrix.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String value : list) &#123;</span><br><span class="line"></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; value = &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;special&quot;</span>.equals(value)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遇到特殊任务标记，就让当前线程等一下</span></span><br><span class="line">                        barrier.await();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;thread01&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;String&gt; list = matrix.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String value : list) &#123;</span><br><span class="line"></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; value = &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;special&quot;</span>.equals(value)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遇到特殊任务标记，就让当前线程等一下</span></span><br><span class="line">                        barrier.await();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;thread02&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;String&gt; list = matrix.get(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String value : list) &#123;</span><br><span class="line"></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; value = &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;special&quot;</span>.equals(value)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遇到特殊任务标记，就让当前线程等一下</span></span><br><span class="line">                        barrier.await();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;thread03&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote><p>入门使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、创建 Semaphore 对象，指定资源数量为 3</span></span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建 10 个线程争夺这 3 个资源</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 申请资源</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拿到资源执行操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】号车辆【驶入】车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】号车辆【驶出】车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 操作完成释放资源</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, i + <span class="string">&quot;&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入超时机制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、设定车位数量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">carPositionCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建 Semaphore 对象</span></span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(carPositionCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、创建 50 个线程抢车位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">carNum</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">acquireResult</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 线程开始时先申请资源，申请不到会进入等待状态</span></span><br><span class="line">            <span class="comment">// 申请资源方式一：不见不散，等不到资源就一直等</span></span><br><span class="line">            <span class="comment">// semaphore.acquire();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 申请资源方式二：过时不候</span></span><br><span class="line">            acquireResult = semaphore.tryAcquire(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (acquireResult) &#123;</span><br><span class="line">                <span class="comment">// 申请到资源时，线程会继续执行</span></span><br><span class="line">                System.out.println(carNum + <span class="string">&quot;号车辆驶入车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 车辆在车位停放一段时间</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 停放完成离开车位</span></span><br><span class="line">                System.out.println(carNum + <span class="string">&quot;号车辆驶出车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(carNum + <span class="string">&quot;号车辆放弃等待&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断当前线程释放拿到了资源</span></span><br><span class="line">            <span class="keyword">if</span> (acquireResult) &#123;</span><br><span class="line">                <span class="comment">// 任务执行完成释放资源</span></span><br><span class="line">                semaphore.release();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景举例</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">借助Semaphore实现『限流』操作。</span><br><span class="line"></span><br><span class="line">- 当前服务器实例能够承受多大的访问量——设置为资源的数量。</span><br><span class="line">- 根据资源的数量创建Semaphore对象。</span><br><span class="line">- 服务器实例接收到请求通过Semaphore对象管理处理请求数量。</span><br><span class="line">    - 在能力范围内：处理请求。</span><br><span class="line">    - 超过能力范围：设定等待时间，看是否能够得到别的请求处理完成释放资源。</span><br></pre></td></tr></table></figure></blockquote><h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork Join"></a>Fork Join</h3><blockquote><p>概念</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209211809076.png" alt="image-20220921180905006"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">使用 Fork Join 框架能够帮助我们把一个大型任务，根据一定规律，拆分成小任务执行。如果拆分后的任务还不够小，可以以递归模式继续拆分，直到拆分到可以执行的程度。然后再把各个子任务执行的结果汇总到一起。</span><br><span class="line"></span><br><span class="line">- Fork：拆分：把大任务拆分成小任务。</span><br><span class="line">- Join：合并：把小任务执行的结果合并到一起。</span><br></pre></td></tr></table></figure><p>框架中 API 介绍</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.RecursiveTask</span><br><span class="line">我们使用 Fork Join 框架只需要继承 RecursiveTask，然后重写 compute() 方法即可。在 compute() 方法中需要包含：</span><br><span class="line"></span><br><span class="line">- 任务拆分的逻辑</span><br><span class="line">- 任务拆分的操作：调用 fork() 方法</span><br><span class="line">- 已拆分任务的合并：调用 join() 方法</span><br><span class="line">- 子任务结果的合并：将 join() 方法的返回值合并起来</span><br><span class="line">2.ForkJoinTask</span><br><span class="line">ForkJoinTask 类是 RecursiveTask 的父类。</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.需求</span><br><span class="line">完成从 1~100 的累加。</span><br><span class="line">2.思路</span><br><span class="line">通过任务拆分、合并的方式来实现。拆分的逻辑是：</span><br><span class="line"></span><br><span class="line">- 将大范围数值累加拆分为小范围数值累加。</span><br><span class="line">- 在 1~10 区间范围内执行计算。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间开始位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间结束位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间调整值：要通过拆分任务将区间调整到 10 以内</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ADJUST_VALUE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前任务的结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明构造器，设定当前任务的开始和结束位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、判断当前区间是否是原子任务中可以执行计算的范围</span></span><br><span class="line">        <span class="keyword">if</span> (end - begin &lt;= ADJUST_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;= end ; i++) &#123;</span><br><span class="line">                result  = result + i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、计算新拆分任务的区间范围</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftBegin</span> <span class="operator">=</span> begin;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftEnd</span> <span class="operator">=</span> (begin + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">rightBegin</span> <span class="operator">=</span> leftEnd + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightEnd</span> <span class="operator">=</span> end;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、创建两个新的任务（子任务）</span></span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">myTaskLeft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(leftBegin, leftEnd);</span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">myTaskRight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(rightBegin, rightEnd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、调用框架提供的 fork() 进一步拆分任务</span></span><br><span class="line">            myTaskLeft.fork();</span><br><span class="line">            myTaskRight.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5、调用框架提供的 join() 获取子任务计算的结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftResult</span> <span class="operator">=</span> (<span class="type">int</span>) myTaskLeft.join();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightResult</span> <span class="operator">=</span> (<span class="type">int</span>) myTaskRight.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6、把子任务的结果合并到一起</span></span><br><span class="line">            result = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建 Fork Join 任务池</span></span><br><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建任务对象</span></span><br><span class="line"><span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、将任务对象提交到任务池</span></span><br><span class="line"><span class="type">ForkJoinTask</span> <span class="variable">forkJoinTask</span> <span class="operator">=</span> pool.submit(myTask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、获取任务执行结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">finalResult</span> <span class="operator">=</span> (<span class="type">int</span>) forkJoinTask.get();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;finalResult = &quot;</span> + finalResult);</span><br></pre></td></tr></table></figure></blockquote><h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">线程池就是一个容器,存放多个线程对象的容器,当我们需要用到线程的时候,只用区线程池拿就行,不需要new新的线程,可以节省开辟线程的空间,提高代码的效率.</span><br><span class="line">2.有哪些</span><br><span class="line">newCachedThreadPool</span><br><span class="line">线程会根据需要创建多线程,并可以重用之前创建的线程,可扩容,适合执行短期的异步任务.</span><br><span class="line">newFixedThreadPool(线程数)</span><br><span class="line">指定固定的线程数,适合执行长期的任务</span><br><span class="line">newScheduledThreadPool(线程数)</span><br><span class="line">指定固定的线程数,支持周期性的任务执行</span><br><span class="line">newSingleThreadExecutor</span><br><span class="line">一个任务一个任务的执行，一池一线程。</span><br><span class="line">3.实际开发</span><br><span class="line">在实际的开发中,我们采用由ThreadPoolExecutor自定义的线程池</span><br></pre></td></tr></table></figure><p>为什么</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">线程的主要作用就是为了控制线程的数量,在开发过程中,我们将需要线程处理的任务放入到队列中,等待线程创建之后启动这些在队列中排队的任务,如果队列已满,我们就将任务交由非核心线程处理,线程池的主要特点是在线程池中的线程能够复用,能够控制最大的并发数量,任务总数超过了核心线程和非核心线程的数量,那就拒绝这个任务,拒绝也有四种策略,一个是默认的,直接抛出异常,阻止线程池接受新的任务,还有一种是让任务从哪里来,回哪里去,不用抛弃自己的任务,也不用抛出异常,另一种是替换自己队列中等待最久的那个任务,最后一种是默默丢弃,不去抛异常,</span><br><span class="line">线程池中的线程的重复利用能够降低资源的消耗,任务不用去等待线程的创建才被执行,线程创建时间的减少可以提高任务的响应速度,也可以更好的管理线程,应为如果线程无限制,无休止的创建,反反复复,会影响到系统的性能,降低系统的稳定性,所以我们用线程池堆线程进行管理,提高可管理性.</span><br></pre></td></tr></table></figure><p>底层原理</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在线程池刚刚创建的时候,里面是没有任何线程的,等任务来的时候,才会创建线程,当然也可以调用方法提前创建线程,当提交一个任务的时候,如果还有空闲的核心线程数或还未被创建的核心线程数,那我们就直接用这个核心线程或创建这个核心线程执行我们的这个任务,如果没有空闲的核心线程,且队列没有满的情况下,我们就把这个任务放在核心线程中排队等待,等待有空闲的核心线程后来处理队列中排队的任务,如果队列已经满了,但非核心线程还有空闲,我们就用非核心线程去处理这个任务,核心线程和非核心线程的区别是,核心线程一直都存在,非核心线程在一定的时间内没干活了,那么这个非核心线程就会被停掉,线程池在创建了很多的非核心任务后,在任务量核心线程和队列能解决的情况下,会在一定的时间内停止掉非核心线程的数量,线程池中的线程数会慢慢缩减到核心线程的数量,当队列已满的情况下,再来任务,这个任务会被指定的拒绝策略拒绝掉.</span><br></pre></td></tr></table></figure><p>七大参数</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">这个类的构造器都有4个,其中一个构造器的参数数量是5个,其他的都是7个,在实际的开发中,我们一般中7个参数的构造器,这七个参数是线程池的核心线程数,线程池的最大线程数,非核心线程的空闲存活时间,存活时间的单位,任务的队列,创建线程池中线程的工厂,拒绝策略.</span><br></pre></td></tr></table></figure><p>核心线程数和最大线程数如何设置</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">如果线程主要执行的是计算的任务,CPU利用率高,核心线程数等于CPU核心数</span><br><span class="line">如果线程主要执行的是IO操作,CPU利用率不高,核心线程数等于2倍的CPU核心数</span><br><span class="line">最大线程数都设置为核心线程数+1</span><br></pre></td></tr></table></figure><p>拒绝策略都有哪些</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">拒绝策略一般分为4种,第一种为直接抛出异常,程序结束.第二中为任务从哪个线程来,让它回哪里去.第三种为直接替换阻塞队列中最靠前的任务,直接插队上位.第四种为默默丢弃,直接丢弃任务</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/archives/3d614825.html"/>
      <url>/archives/3d614825.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h2><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">HashMap底层是一个&quot;链表散列&quot;的数据结构,由数组和链表组成</span><br></pre></td></tr></table></figure></blockquote><h2 id="HashMap结构"><a href="#HashMap结构" class="headerlink" title="HashMap结构"></a>HashMap结构</h2><blockquote><p>属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//底层数组的默认长度16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//底层数组的最大长度2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认的加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//初始化底层数组为空数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"><span class="comment">//存放Entry对象引用的数组</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="comment">//数组和链表中元素的总个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="comment">//扩容阈值,元素的个数达到这个值可能就会进行扩容=数组长度*加载因子</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="comment">//加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入底层数组的长度和加载因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">//当传入数组的长度小于0,直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//当传入数组的长度大于数组长度的最大值,就修改为最大值</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//加载因子需要大于0并且类型要为数值类型,否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"><span class="comment">//对加载因子赋值</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//先将传入的数组长度赋值给扩容阈值,不是最终的,后面还会修改</span></span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//LinkedHashMap重写了此方法</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="HashMap的存取"><a href="#HashMap的存取" class="headerlink" title="HashMap的存取"></a>HashMap的存取</h2><h3 id="添加Put方法"><a href="#添加Put方法" class="headerlink" title="添加Put方法"></a>添加Put方法</h3><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//如果底层数组和存放引用的数组地址相同,则初始化引用数组table</span></span><br><span class="line">    <span class="comment">//1.按照公式,重新计算对阈值threshold进行修改 2.计算2的幂次方值初始化引用数组table</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对key为null处理,说明支持存放null值数据</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//调用本类的hash方法对键值进行计算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">//根据hash值和引用数组的长度计算出存放在数组的下标位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//遍历以该数组元素作为头节点的链表,如果有相同的key,则覆盖,返回旧的value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//遍历一变后没有找到key相等的,则执行添加</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①初始化引用数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="comment">//找到&gt;=传入的数组长度的最小的幂次方数,如小于16的,都默认为16</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);</span><br><span class="line"><span class="comment">//重新计算阈值,取数组长度*加载因子和数组长度最大值+1它俩之间的最小值最为阈值</span></span><br><span class="line">    threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//初始化引用数组的长度</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">    <span class="comment">//初始化hash种子</span></span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">roundUpToPowerOf2</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">    <span class="comment">//计算 &gt;= 传入的数组长度的最小2的幂次放数</span></span><br><span class="line">    <span class="comment">//也就是说我们计算一个最小的2的幂次方数,这个幂次方数要大于数组的长度</span></span><br><span class="line">    <span class="comment">//Integer.highestOneBit计算的是&lt;=传入值的最大的2的幂次方数</span></span><br><span class="line">    <span class="comment">//所以为了达到我们的目的,我们要将传入的值翻倍</span></span><br><span class="line">    <span class="comment">//但为什么要-1,为了保证数据不出错,如果数组长度是16,不-1的话,实际传入的数是32,那调用方法计算出来的值也是32,和我们预想的结果16不一致.</span></span><br><span class="line">    <span class="comment">//如果数组长度为16,就返回16</span></span><br><span class="line">    <span class="comment">//17 ==&gt; 32</span></span><br><span class="line">    <span class="comment">//14 ==&gt; 16</span></span><br><span class="line">    <span class="comment">// 2 ==&gt; 16</span></span><br><span class="line">    <span class="comment">// 32 ==&gt; 32</span></span><br><span class="line">    <span class="comment">// 33 ==&gt; 64</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">        ? MAXIMUM_CAPACITY</span><br><span class="line">        : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②null处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">putForNullKey</span><span class="params">(V value)</span> &#123;</span><br><span class="line">    <span class="comment">//将key值为null的元素放在引用数组的第一个位置</span></span><br><span class="line">    <span class="comment">//遍历下标0中的链表,找key为null的元素,找到则覆盖,并且把旧值返回</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//没有找到则将新元素添加到下标0的链表的第一个位置,头插</span></span><br><span class="line"><span class="comment">//key为null的元素的hash默认为0</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="literal">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③计算hash值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//先对key值本身的hashCode进行计算</span></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为对象本身的hash值很可能相同,所以我们需要进行二次hash运算</span></span><br><span class="line">    <span class="comment">//进行一串的异或运算和与运算,我们称为&quot;扰动函数&quot;</span></span><br><span class="line">    <span class="comment">//&quot;扰动函数&quot;的目的是为了降低hash值的冲突,是哈希码更加均匀</span></span><br><span class="line">    <span class="comment">// 4次位运算 + 5次异或运算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//20和12不一定要固定,只要和为32就行,目的都是为了洗牌</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④计算元素的下标</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">//用引用数组的长度-1 和 哈希值 进行与运算</span></span><br><span class="line">    <span class="comment">//为了保证运算的结果在[0,length]之间</span></span><br><span class="line">    <span class="comment">//所以我们之前对数组的长度计算的时候需要时结果为2的幂次方数,保证二进制码只有一个1</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑤添加操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入参数1.哈希码 2.键 3.值 4.新元素下标</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//如果当前元素个数大于阈值 并且 新元素所在数组下标有数据不为null ==&gt;则我们要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">//1.创建新的扩容后的引用数组,将原数组的数据赋值给新数组</span></span><br><span class="line">        <span class="comment">//2.重新计算扩容阈值</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">//重新计算hash值</span></span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//重新计算新元素的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//开始添加</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//保存旧的数组</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="comment">//保存旧数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="comment">//如果旧数组的长度已经到达了最大长度,则将阈值设置为整型的最大值,然后结束退出</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建新的数组,长度为旧数组的两倍</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    <span class="comment">//将旧数组上的数据转移到新数组上</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    <span class="comment">//table的引用指向新的数组上</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">//重新计算阈值并设置</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组转移</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="comment">//新数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="comment">//遍历旧数组table,然后一个一个迁移</span></span><br><span class="line">    <span class="comment">//如果这里涉及到多线程操作的话,可能会出现循环链表,线程会不安全</span></span><br><span class="line">    <span class="comment">//为什么不直接迁移,还要遍历各个链表中的元素,是为了让以前的链表尽量的散列到不用的位置上去</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">//重新hash,一般不用</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算各个元素的下标,迁移</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用头插法进行元素添加</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//保存链表头节点Entry</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">//将新插入节点的next设置为原头节点,原头节点则会变为新头节点的下一个节点,从而形成新的链表</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">//元素个数+1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="读取Get方法"><a href="#读取Get方法" class="headerlink" title="读取Get方法"></a>读取Get方法</h3><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> == entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/archives/66c016fb.html"/>
      <url>/archives/66c016fb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-JVM概述"><a href="#1-JVM概述" class="headerlink" title="1.JVM概述"></a>1.JVM概述</h2><blockquote><p>JVM：Java Virtual Machine，翻译过来是Java虚拟机</p></blockquote><h3 id="JDK、JRE、JVM关系"><a href="#JDK、JRE、JVM关系" class="headerlink" title="JDK、JRE、JVM关系"></a>JDK、JRE、JVM关系</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">JDK: Java开发工具包==&gt;JRE+Java开发辅助工具</span><br><span class="line">JRE: Java运行环境==&gt;JVM+Java运行时类库</span><br></pre></td></tr></table></figure></blockquote><h3 id="JVM工作机制"><a href="#JVM工作机制" class="headerlink" title="JVM工作机制"></a>JVM工作机制</h3><blockquote><p>编译过程</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Java源文件(.java)→编译→字节码文件(.class)→放到JVM上运行</span><br></pre></td></tr></table></figure><p>工作机制</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.使用功能区的类加载器将编译好的字节码文件加载到JVM内存中</span><br><span class="line">2.在JVM内存空间存储相关的数据(方法区,堆,栈,本地方法栈)</span><br><span class="line">3.使用功能区的执行引擎将字节码文件翻译为机器能懂的机器码,也就是一个个CPU执行指令</span><br><span class="line">4.执行引擎将执行指令发送个CPU执行</span><br></pre></td></tr></table></figure></blockquote><h3 id="JVM内存架构"><a href="#JVM内存架构" class="headerlink" title="JVM内存架构"></a>JVM内存架构</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209131843770.png" alt="JVM"></p><p>内存区域划分</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.功能区</span><br><span class="line">类加载器</span><br><span class="line">执行引擎</span><br><span class="line">垃圾回收机制GC</span><br><span class="line">2.线程私有区域</span><br><span class="line">线程栈</span><br><span class="line">本地方法栈</span><br><span class="line">程序计数器</span><br><span class="line">3.线程共享区域</span><br><span class="line">堆</span><br><span class="line">方法区(1.7永久代,1.8元空间)</span><br><span class="line">直接内存(堆外内存)</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-功能区"><a href="#2-功能区" class="headerlink" title="2.功能区"></a>2.功能区</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><blockquote><p>ClassLoader: 加载字节码文件</p></blockquote><blockquote><p>分类</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.启动类加载器(Bootstrap)</span><br><span class="line">=&gt;由C++编写,所以Java环境下看不到,加载JRE/lib/*.jar中的核心类库</span><br><span class="line">2.扩展类加载器(Extension)</span><br><span class="line">==&gt;由Java编写,加载的是JRE/lib/ext/*.jar</span><br><span class="line">3.应用类加载器(AppClassLoader)</span><br><span class="line">==&gt;也叫系统类加载器,负责加载classpath中指定的jar包及目录中的class</span><br><span class="line">4.自定义加载器()</span><br><span class="line">==&gt;程序员自己开发一个类继承 java.lang.ClassLoader，定制类加载方式</span><br></pre></td></tr></table></figure><p>类加载器之间的关系</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">上下级关系</span><br></pre></td></tr></table></figure><p>双亲委派机制</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209131900441.png" alt="img002.cb2a07a4"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.加载某一范围的类的时候,会找到范围对应的类加载器</span><br><span class="line">2.对应的类加载器不会立马开始查找这个类,会将任务交给上一级类加载器</span><br><span class="line">3.上级类加载器将任务继续上交,直到任务给到了启动类加载器</span><br><span class="line">4.启动类开始在自己复制的范围内查找,找到则加载,否则交给下一级类加载器</span><br><span class="line">5.下一级类加载器同上</span><br><span class="line">6.知道重新交给应用类加载器上,应用类加载器也找不到则抛出异常(ClassNotFoundException)</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">1.保护Java核心.class不被篡改(沙箱安全机制)</span><br><span class="line">2.避免重复加载: 父加载器加载了,就不必让子加载器再加载,也保证了类的全类名是唯一标识</span><br></pre></td></tr></table></figure></blockquote><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><blockquote><p>作用</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">将字节码转换为机器码,即一条条Cpu指令</span><br></pre></td></tr></table></figure><p>分类</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.解释型</span><br><span class="line">==&gt;执行效率低,一代JVM</span><br><span class="line">2.即时编译型</span><br><span class="line">==&gt;JIT,二代JVM</span><br><span class="line">3.混合型(Java默认引擎)</span><br><span class="line">==&gt;汲取一代二代经验,一开始对代码进行解释,若一段代码被频繁调用,则对此代码进行即时编译,热度降后,取消即使编译</span><br></pre></td></tr></table></figure></blockquote><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><blockquote><p>Stop-The-World</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Stop-The-World：字面意思让整个世界停止。在 GC 机制中，Stop-The-World 表示挂起整个 JVM 程序，等执行完垃圾回收之后，再继续执行 JVM 程序。Stop-The-World 通常也会简称为 STW。</span><br></pre></td></tr></table></figure></blockquote><h4 id="基本算法-四个"><a href="#基本算法-四个" class="headerlink" title="基本算法(四个)"></a>基本算法(四个)</h4><blockquote><p>概述</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;意为垃圾回收,释放不再使用的内存空间,清理不再使用的对象</span><br><span class="line">2.为什么</span><br><span class="line">==&gt;不清理可能会导致内存耗尽,通过GC,把不需要占用内存清理,释放空间,让项目持续的运行</span><br><span class="line">3.垃圾对象是什么</span><br><span class="line">==&gt;不再使用,或获取不到的对象就是垃圾对象</span><br></pre></td></tr></table></figure><p>引用计数法</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;在对象t中分配一个空间来保存对象被引用的次数</span><br><span class="line">==&gt;如果对象被引用,则引用次数+1</span><br><span class="line">==&gt;如果删除对象引用,则引用次数-1</span><br><span class="line">==&gt;当对象引用次数为0时,则对象会被回收</span><br><span class="line">2.优点</span><br><span class="line">==&gt;比较实时,不用等到内存不够才回收</span><br><span class="line">==&gt;不用STW,不影响程序的正常运行</span><br><span class="line">3.缺点：</span><br><span class="line">==&gt;回收时不STW会造成内存碎片问题.</span><br><span class="line">==&gt;不能解决对象间的循环引用问题</span><br><span class="line">4.小结：</span><br><span class="line">==&gt;正是由于引用计数法不能解决对象间的循环引用问题，所以事实上并没有哪一款 JVM 产品采用这个机制。</span><br></pre></td></tr></table></figure><p>标记清除法(老年代)</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;当堆中的有效内存被耗尽时触发</span><br><span class="line">==&gt;进行STW,标记存活的对象</span><br><span class="line">==&gt;遍历堆中所有的对象,清除没被标记的对象</span><br><span class="line">2.优点</span><br><span class="line">==&gt;实现比较简单</span><br><span class="line">3.缺点</span><br><span class="line">==&gt;应为要遍历所以对象,所以效率低</span><br><span class="line">==&gt;只是清除了垃圾对象,没有重新排列,容易造成内存碎片</span><br><span class="line">==&gt;STW时,程序要暂时挂起,停止运行</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209132047345.png" alt="image-20220913204726272"></p><p>标记压缩法(老年代)</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;在标记清除的基础上做优化,在清理阶段,不是简单的清理未标记的对象</span><br><span class="line">==&gt;将标记的对象移动到内存一段,然后清理标记对象边界以外的垃圾</span><br><span class="line">2.优点</span><br><span class="line">==&gt;解决了碎片化的问题</span><br><span class="line">3.缺点</span><br><span class="line">==&gt;效率比标记清除法都慢</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209132057906.png" alt="image-20220913205702840"></p><p>复制算法(年轻代)</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;将原有的内存空间一分为二,每次只有其中一块</span><br><span class="line">==&gt;将存活的对象复制到另一块内存空间,并排列,然后将此块内存空间清空</span><br><span class="line">2.优点</span><br><span class="line">==&gt;年轻代垃圾较多的时候,效率会高很多</span><br><span class="line">==&gt;没有内存碎片</span><br><span class="line">3.缺点</span><br><span class="line">==&gt;浪费了一块内存的空间</span><br><span class="line">==&gt;老年代垃圾较少的时候,效率比较差</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209132103775.png" alt="image-20220913210327657"></p></blockquote><h4 id="综合算法-两个"><a href="#综合算法-两个" class="headerlink" title="综合算法(两个)"></a>综合算法(两个)</h4><blockquote><p>分代算法</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&gt;1.每个算法都有自己的优缺点,不能互相替代.</span><br><span class="line">&gt;2.对不同的垃圾对象选择不同的算法是正确的</span><br><span class="line">&gt;3.新生代适合使用复制算法</span><br><span class="line">&gt;4.老年代适合使用标记清除或标记压缩算法</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209132111051.png" alt="image-20220913211113991"></p><p>分区算法</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&gt;1.因为随着堆内存空间的增大,一次GC的时间也会越长,GC产生的停顿时间也约长</span><br><span class="line">&gt;2.为了更好的控制停顿时间,将堆空间划分不同的小区间,每个小区间独立使用,独立回收</span><br><span class="line">&gt;3.不是回收整个堆空间,所以减少一次停顿所消耗的时间</span><br></pre></td></tr></table></figure></blockquote><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="串行垃圾回收器"><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h5><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&gt;在一个线程内执行垃圾回收操作</span><br><span class="line"></span><br><span class="line">年轻代用复制算法、老年代用标记压缩法</span><br></pre></td></tr></table></figure><p>SerialGC[新生]</p><p>SerialOldGC[老年]</p></blockquote><h5 id="并行垃圾回收器"><a href="#并行垃圾回收器" class="headerlink" title="并行垃圾回收器"></a>并行垃圾回收器</h5><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&gt;在多个线程中执行垃圾回收操作</span><br><span class="line"></span><br><span class="line">年轻代用复制算法、老年代用标记压缩法</span><br></pre></td></tr></table></figure><p>ParNew[新生]</p><p>ParallelScavengeGC[新生]</p><p>ParallelOldGC[老年]</p></blockquote><h5 id="G1回收器-好用"><a href="#G1回收器-好用" class="headerlink" title="G1回收器[好用]"></a>G1回收器[好用]</h5><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">G1(Garbage-First)是并发垃圾回收器, 主要目标用于配备多颗CPU的服务器，治理大内存。是JDK1.7提供的一个新收集器，是当今收集器技术发展的最前沿成果之一。</span><br><span class="line"></span><br><span class="line">G1将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了, 它们都是一部分Region(不需要连续)的集合。</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.优先回收垃圾多的区域(Region)</span><br><span class="line">2.保证了在有效的时间内达到更高的效率</span><br><span class="line"></span><br><span class="line">特点</span><br><span class="line">1.一整块堆内存被分成多个独立的区域Regions</span><br><span class="line">2.存活对象被拷贝到新的Survivor区</span><br><span class="line">3.新生代内存由一组不连续的堆heap区组成，使得可以动态调整各个区域</span><br><span class="line">4.多线程并发GC</span><br><span class="line">5.young GC会有STW</span><br></pre></td></tr></table></figure></blockquote><h5 id="垃圾回器对比"><a href="#垃圾回器对比" class="headerlink" title="垃圾回器对比"></a>垃圾回器对比</h5><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209141950404.png" alt="image-20220914195010322"></p></blockquote><h2 id="3-线程私有区域"><a href="#3-线程私有区域" class="headerlink" title="3.线程私有区域"></a>3.线程私有区域</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">用来保存下一条要执行的CPU指令的地址</span><br></pre></td></tr></table></figure><h5 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h5><p>方法栈帧</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.方法出口</span><br><span class="line">谁引用此方法,存储谁的地址</span><br><span class="line">2.动态链接</span><br><span class="line">存储指向方法区对应方法的地址</span><br><span class="line">3.操作数栈</span><br><span class="line">临时的空间,存储计算,复制等操作用到的操作数</span><br><span class="line">4.局部变量表</span><br><span class="line">储存方法参数,和局部变量</span><br></pre></td></tr></table></figure><p>main方法栈帧</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.局部变量表</span><br></pre></td></tr></table></figure><h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">native修饰的方法形成的栈</span><br></pre></td></tr></table></figure></blockquote><h2 id="4-线程公有区域"><a href="#4-线程公有区域" class="headerlink" title="4.线程公有区域"></a>4.线程公有区域</h2><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote><p>具体实现</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.=  1.7 永久代</span><br><span class="line">2.&gt;= 1.8元空间（Meta Space）</span><br><span class="line"></span><br><span class="line">区别</span><br><span class="line">1.永久代向JVM申请内存空间,元空间直接向内存申请空间</span><br><span class="line">2.永久代存在字符串常量池,元空间不存在字符串常量池</span><br></pre></td></tr></table></figure><p>元空间</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.类信息：类中定义的构造器、接口定义</span><br><span class="line">2.静态变量</span><br><span class="line">3.常量</span><br><span class="line">4.运行时常量池</span><br><span class="line">5.类中方法的代码</span><br></pre></td></tr></table></figure></blockquote><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote><p>数据结构</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.对象</span><br><span class="line">2.数组</span><br></pre></td></tr></table></figure><p>空间结构</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209141911452.png" alt="image-20220914191127362"></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.新生代(堆内存1/3)</span><br><span class="line">&gt;.Eden区[伊甸园区](新生代8/10)</span><br><span class="line">&gt;.幸存者区(新生代2/10)</span><br><span class="line">==&gt;Survivor0(From)</span><br><span class="line">==&gt;Survivor1(To)</span><br><span class="line">2.老年代(堆内存2/3)</span><br><span class="line">3.永久代[非堆]</span><br></pre></td></tr></table></figure><p>工作机制</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.新创建的对象会放在Eden区</span><br><span class="line">2.当Eden区使用的空间到达了一定的比例,会触发MinorGC清除垃圾对象,剩下来的对象被称为幸存者</span><br><span class="line">3.幸存者会被转移到幸存者区(幸存者区将会轮转清空,重新和Eden区对象组合一起重新排列)</span><br><span class="line">4.如果一个对象15次GC还幸存,转移到老年区</span><br><span class="line">5.如果幸存者区满了,Eden区的幸存者会转移到老年区</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.Eden区主要是生命周期很短的对象来来往往</span><br><span class="line">2.老年代主要是生命周期很长的对象，例如：IOC容器对象、线程池对象、数据库连接池对象等等</span><br><span class="line">3.幸存者区作为二者之间的过渡地带</span><br><span class="line"></span><br><span class="line">关于永久代</span><br><span class="line">从理论上来说属于堆</span><br><span class="line">从具体实现上来说不属于堆</span><br></pre></td></tr></table></figure></blockquote><h3 id="直接内存-堆外内存"><a href="#直接内存-堆外内存" class="headerlink" title="直接内存(堆外内存)"></a>直接内存(堆外内存)</h3><blockquote><p>含义</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">直接去内存条申请的内存,仅供NIO使用</span><br></pre></td></tr></table></figure></blockquote><h2 id="5-优化"><a href="#5-优化" class="headerlink" title="5.优化"></a>5.优化</h2><h3 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h3><blockquote><p>堆</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.majorGC(针对年轻代) 一两个月一次，如果业务量比较大，majorGC最少也要几天一次GC</span><br><span class="line">2.minorGC(针对老年代) 几个小时发生一次</span><br><span class="line">3.年轻代占整个堆的3/8,可以在附近微调</span><br></pre></td></tr></table></figure><p>元空间</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.8G内存，建议将元空间设置为256M，随着服务器内存大小的变化，元空间依次按比例变化即可.</span><br></pre></td></tr></table></figure></blockquote><h3 id="GC-1"><a href="#GC-1" class="headerlink" title="GC"></a>GC</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.选择合适的垃圾回收器：G1</span><br><span class="line">2.调节并行垃圾回收的线程数：和cpu的核数保持一致</span><br></pre></td></tr></table></figure></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.尽量使用StringBuffer、StringBuilder</span><br><span class="line">2.对于大对象用完及时释放、Connection、FIS、FOS、Map、List</span><br><span class="line">3.尽量少使用try...catch，尤其是不要在for循环内部使用try...catch</span><br></pre></td></tr></table></figure></blockquote><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><blockquote><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.加内存</span><br><span class="line">2.选择合适磁盘[固态、机械]</span><br><span class="line">3.选择合适的CPU</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
