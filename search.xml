<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HashMap</title>
      <link href="/archives/3d614825.html"/>
      <url>/archives/3d614825.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h2><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap底层是一个&quot;链表散列&quot;的数据结构,由数组和链表组成</span><br></pre></td></tr></table></figure></blockquote><h2 id="HashMap结构"><a href="#HashMap结构" class="headerlink" title="HashMap结构"></a>HashMap结构</h2><blockquote><p>属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层数组的默认长度16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//底层数组的最大长度2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认的加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//初始化底层数组为空数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"><span class="comment">//存放Entry对象引用的数组</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="comment">//数组和链表中元素的总个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="comment">//扩容阈值,元素的个数达到这个值可能就会进行扩容=数组长度*加载因子</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="comment">//加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入底层数组的长度和加载因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">//当传入数组的长度小于0,直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//当传入数组的长度大于数组长度的最大值,就修改为最大值</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//加载因子需要大于0并且类型要为数值类型,否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"><span class="comment">//对加载因子赋值</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//先将传入的数组长度赋值给扩容阈值,不是最终的,后面还会修改</span></span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//LinkedHashMap重写了此方法</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="HashMap的存取"><a href="#HashMap的存取" class="headerlink" title="HashMap的存取"></a>HashMap的存取</h2><h3 id="添加Put方法"><a href="#添加Put方法" class="headerlink" title="添加Put方法"></a>添加Put方法</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//如果底层数组和存放引用的数组地址相同,则初始化引用数组table</span></span><br><span class="line">    <span class="comment">//1.按照公式,重新计算对阈值threshold进行修改 2.计算2的幂次方值初始化引用数组table</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对key为null处理,说明支持存放null值数据</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//调用本类的hash方法对键值进行计算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">//根据hash值和引用数组的长度计算出存放在数组的下标位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//遍历以该数组元素作为头节点的链表,如果有相同的key,则覆盖,返回旧的value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//遍历一变后没有找到key相等的,则执行添加</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①初始化引用数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="comment">//找到&gt;=传入的数组长度的最小的幂次方数,如小于16的,都默认为16</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);</span><br><span class="line"><span class="comment">//重新计算阈值,取数组长度*加载因子和数组长度最大值+1它俩之间的最小值最为阈值</span></span><br><span class="line">    threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//初始化引用数组的长度</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">    <span class="comment">//初始化hash种子</span></span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">roundUpToPowerOf2</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">    <span class="comment">//计算 &gt;= 传入的数组长度的最小2的幂次放数</span></span><br><span class="line">    <span class="comment">//也就是说我们计算一个最小的2的幂次方数,这个幂次方数要大于数组的长度</span></span><br><span class="line">    <span class="comment">//Integer.highestOneBit计算的是&lt;=传入值的最大的2的幂次方数</span></span><br><span class="line">    <span class="comment">//所以为了达到我们的目的,我们要将传入的值翻倍</span></span><br><span class="line">    <span class="comment">//但为什么要-1,为了保证数据不出错,如果数组长度是16,不-1的话,实际传入的数是32,那调用方法计算出来的值也是32,和我们预想的结果16不一致.</span></span><br><span class="line">    <span class="comment">//如果数组长度为16,就返回16</span></span><br><span class="line">    <span class="comment">//17 ==&gt; 32</span></span><br><span class="line">    <span class="comment">//14 ==&gt; 16</span></span><br><span class="line">    <span class="comment">// 2 ==&gt; 16</span></span><br><span class="line">    <span class="comment">// 32 ==&gt; 32</span></span><br><span class="line">    <span class="comment">// 33 ==&gt; 64</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">        ? MAXIMUM_CAPACITY</span><br><span class="line">        : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②null处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">putForNullKey</span><span class="params">(V value)</span> &#123;</span><br><span class="line">    <span class="comment">//将key值为null的元素放在引用数组的第一个位置</span></span><br><span class="line">    <span class="comment">//遍历下标0中的链表,找key为null的元素,找到则覆盖,并且把旧值返回</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//没有找到则将新元素添加到下标0的链表的第一个位置,头插</span></span><br><span class="line"><span class="comment">//key为null的元素的hash默认为0</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="literal">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③计算hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//先对key值本身的hashCode进行计算</span></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为对象本身的hash值很可能相同,所以我们需要进行二次hash运算</span></span><br><span class="line">    <span class="comment">//进行一串的异或运算和与运算,我们称为&quot;扰动函数&quot;</span></span><br><span class="line">    <span class="comment">//&quot;扰动函数&quot;的目的是为了降低hash值的冲突,是哈希码更加均匀</span></span><br><span class="line">    <span class="comment">// 4次位运算 + 5次异或运算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//20和12不一定要固定,只要和为32就行,目的都是为了洗牌</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④计算元素的下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">//用引用数组的长度-1 和 哈希值 进行与运算</span></span><br><span class="line">    <span class="comment">//为了保证运算的结果在[0,length]之间</span></span><br><span class="line">    <span class="comment">//所以我们之前对数组的长度计算的时候需要时结果为2的幂次方数,保证二进制码只有一个1</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑤添加操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入参数1.哈希码 2.键 3.值 4.新元素下标</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//如果当前元素个数大于阈值 并且 新元素所在数组下标有数据不为null ==&gt;则我们要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">//1.创建新的扩容后的引用数组,将原数组的数据赋值给新数组</span></span><br><span class="line">        <span class="comment">//2.重新计算扩容阈值</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">//重新计算hash值</span></span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//重新计算新元素的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//开始添加</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//保存旧的数组</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="comment">//保存旧数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="comment">//如果旧数组的长度已经到达了最大长度,则将阈值设置为整型的最大值,然后结束退出</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建新的数组,长度为旧数组的两倍</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    <span class="comment">//将旧数组上的数据转移到新数组上</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    <span class="comment">//table的引用指向新的数组上</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">//重新计算阈值并设置</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组转移</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="comment">//新数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="comment">//遍历旧数组table,然后一个一个迁移</span></span><br><span class="line">    <span class="comment">//如果这里涉及到多线程操作的话,可能会出现循环链表,线程会不安全</span></span><br><span class="line">    <span class="comment">//为什么不直接迁移,还要遍历各个链表中的元素,是为了让以前的链表尽量的散列到不用的位置上去</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">//重新hash,一般不用</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算各个元素的下标,迁移</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用头插法进行元素添加</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//保存链表头节点Entry</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">//将新插入节点的next设置为原头节点,原头节点则会变为新头节点的下一个节点,从而形成新的链表</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">//元素个数+1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="读取Get方法"><a href="#读取Get方法" class="headerlink" title="读取Get方法"></a>读取Get方法</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> == entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/archives/66c016fb.html"/>
      <url>/archives/66c016fb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-JVM概述"><a href="#1-JVM概述" class="headerlink" title="1.JVM概述"></a>1.JVM概述</h2><blockquote><p>JVM：Java Virtual Machine，翻译过来是Java虚拟机</p></blockquote><h3 id="JDK、JRE、JVM关系"><a href="#JDK、JRE、JVM关系" class="headerlink" title="JDK、JRE、JVM关系"></a>JDK、JRE、JVM关系</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK: Java开发工具包==&gt;JRE+Java开发辅助工具</span><br><span class="line">JRE: Java运行环境==&gt;JVM+Java运行时类库</span><br></pre></td></tr></table></figure></blockquote><h3 id="JVM工作机制"><a href="#JVM工作机制" class="headerlink" title="JVM工作机制"></a>JVM工作机制</h3><blockquote><p>编译过程</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java源文件(.java)→编译→字节码文件(.class)→放到JVM上运行</span><br></pre></td></tr></table></figure><p>工作机制</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.使用功能区的类加载器将编译好的字节码文件加载到JVM内存中</span><br><span class="line">2.在JVM内存空间存储相关的数据(方法区,堆,栈,本地方法栈)</span><br><span class="line">3.使用功能区的执行引擎将字节码文件翻译为机器能懂的机器码,也就是一个个CPU执行指令</span><br><span class="line">4.执行引擎将执行指令发送个CPU执行</span><br></pre></td></tr></table></figure></blockquote><h3 id="JVM内存架构"><a href="#JVM内存架构" class="headerlink" title="JVM内存架构"></a>JVM内存架构</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209131843770.png" alt="JVM"></p><p>内存区域划分</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.功能区</span><br><span class="line">类加载器</span><br><span class="line">执行引擎</span><br><span class="line">垃圾回收机制GC</span><br><span class="line">2.线程私有区域</span><br><span class="line">线程栈</span><br><span class="line">本地方法栈</span><br><span class="line">程序计数器</span><br><span class="line">3.线程共享区域</span><br><span class="line">堆</span><br><span class="line">方法区(1.7永久代,1.8元空间)</span><br><span class="line">直接内存(堆外内存)</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-功能区"><a href="#2-功能区" class="headerlink" title="2.功能区"></a>2.功能区</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><blockquote><p>ClassLoader: 加载字节码文件</p></blockquote><blockquote><p>分类</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.启动类加载器(Bootstrap)</span><br><span class="line">=&gt;由C++编写,所以Java环境下看不到,加载JRE/lib/*.jar中的核心类库</span><br><span class="line">2.扩展类加载器(Extension)</span><br><span class="line">==&gt;由Java编写,加载的是JRE/lib/ext/*.jar</span><br><span class="line">3.应用类加载器(AppClassLoader)</span><br><span class="line">==&gt;也叫系统类加载器,负责加载classpath中指定的jar包及目录中的class</span><br><span class="line">4.自定义加载器()</span><br><span class="line">==&gt;程序员自己开发一个类继承 java.lang.ClassLoader，定制类加载方式</span><br></pre></td></tr></table></figure><p>类加载器之间的关系</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上下级关系</span><br></pre></td></tr></table></figure><p>双亲委派机制</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209131900441.png" alt="img002.cb2a07a4"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.加载某一范围的类的时候,会找到范围对应的类加载器</span><br><span class="line">2.对应的类加载器不会立马开始查找这个类,会将任务交给上一级类加载器</span><br><span class="line">3.上级类加载器将任务继续上交,直到任务给到了启动类加载器</span><br><span class="line">4.启动类开始在自己复制的范围内查找,找到则加载,否则交给下一级类加载器</span><br><span class="line">5.下一级类加载器同上</span><br><span class="line">6.知道重新交给应用类加载器上,应用类加载器也找不到则抛出异常(ClassNotFoundException)</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">1.保护Java核心.class不被篡改(沙箱安全机制)</span><br><span class="line">2.避免重复加载: 父加载器加载了,就不必让子加载器再加载,也保证了类的全类名是唯一标识</span><br></pre></td></tr></table></figure></blockquote><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><blockquote><p>作用</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将字节码转换为机器码,即一条条Cpu指令</span><br></pre></td></tr></table></figure><p>分类</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.解释型</span><br><span class="line">==&gt;执行效率低,一代JVM</span><br><span class="line">2.即时编译型</span><br><span class="line">==&gt;JIT,二代JVM</span><br><span class="line">3.混合型(Java默认引擎)</span><br><span class="line">==&gt;汲取一代二代经验,一开始对代码进行解释,若一段代码被频繁调用,则对此代码进行即时编译,热度降后,取消即使编译</span><br></pre></td></tr></table></figure></blockquote><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><blockquote><p>Stop-The-World</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stop-The-World：字面意思让整个世界停止。在 GC 机制中，Stop-The-World 表示挂起整个 JVM 程序，等执行完垃圾回收之后，再继续执行 JVM 程序。Stop-The-World 通常也会简称为 STW。</span><br></pre></td></tr></table></figure></blockquote><h4 id="基本算法-四个"><a href="#基本算法-四个" class="headerlink" title="基本算法(四个)"></a>基本算法(四个)</h4><blockquote><p>概述</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;意为垃圾回收,释放不再使用的内存空间,清理不再使用的对象</span><br><span class="line">2.为什么</span><br><span class="line">==&gt;不清理可能会导致内存耗尽,通过GC,把不需要占用内存清理,释放空间,让项目持续的运行</span><br><span class="line">3.垃圾对象是什么</span><br><span class="line">==&gt;不再使用,或获取不到的对象就是垃圾对象</span><br></pre></td></tr></table></figure><p>引用计数法</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;在对象t中分配一个空间来保存对象被引用的次数</span><br><span class="line">==&gt;如果对象被引用,则引用次数+1</span><br><span class="line">==&gt;如果删除对象引用,则引用次数-1</span><br><span class="line">==&gt;当对象引用次数为0时,则对象会被回收</span><br><span class="line">2.优点</span><br><span class="line">==&gt;比较实时,不用等到内存不够才回收</span><br><span class="line">==&gt;不用STW,不影响程序的正常运行</span><br><span class="line">3.缺点：</span><br><span class="line">==&gt;回收时不STW会造成内存碎片问题.</span><br><span class="line">==&gt;不能解决对象间的循环引用问题</span><br><span class="line">4.小结：</span><br><span class="line">==&gt;正是由于引用计数法不能解决对象间的循环引用问题，所以事实上并没有哪一款 JVM 产品采用这个机制。</span><br></pre></td></tr></table></figure><p>标记清除法(老年代)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;当堆中的有效内存被耗尽时触发</span><br><span class="line">==&gt;进行STW,标记存活的对象</span><br><span class="line">==&gt;遍历堆中所有的对象,清除没被标记的对象</span><br><span class="line">2.优点</span><br><span class="line">==&gt;实现比较简单</span><br><span class="line">3.缺点</span><br><span class="line">==&gt;应为要遍历所以对象,所以效率低</span><br><span class="line">==&gt;只是清除了垃圾对象,没有重新排列,容易造成内存碎片</span><br><span class="line">==&gt;STW时,程序要暂时挂起,停止运行</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209132047345.png" alt="image-20220913204726272"></p><p>标记压缩法(老年代)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;在标记清除的基础上做优化,在清理阶段,不是简单的清理未标记的对象</span><br><span class="line">==&gt;将标记的对象移动到内存一段,然后清理标记对象边界以外的垃圾</span><br><span class="line">2.优点</span><br><span class="line">==&gt;解决了碎片化的问题</span><br><span class="line">3.缺点</span><br><span class="line">==&gt;效率比标记清除法都慢</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209132057906.png" alt="image-20220913205702840"></p><p>复制算法(年轻代)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;将原有的内存空间一分为二,每次只有其中一块</span><br><span class="line">==&gt;将存活的对象复制到另一块内存空间,并排列,然后将此块内存空间清空</span><br><span class="line">2.优点</span><br><span class="line">==&gt;年轻代垃圾较多的时候,效率会高很多</span><br><span class="line">==&gt;没有内存碎片</span><br><span class="line">3.缺点</span><br><span class="line">==&gt;浪费了一块内存的空间</span><br><span class="line">==&gt;老年代垃圾较少的时候,效率比较差</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209132103775.png" alt="image-20220913210327657"></p></blockquote><h4 id="综合算法-两个"><a href="#综合算法-两个" class="headerlink" title="综合算法(两个)"></a>综合算法(两个)</h4><blockquote><p>分代算法</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;1.每个算法都有自己的优缺点,不能互相替代.</span><br><span class="line">&gt;2.对不同的垃圾对象选择不同的算法是正确的</span><br><span class="line">&gt;3.新生代适合使用复制算法</span><br><span class="line">&gt;4.老年代适合使用标记清除或标记压缩算法</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209132111051.png" alt="image-20220913211113991"></p><p>分区算法</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;1.因为随着堆内存空间的增大,一次GC的时间也会越长,GC产生的停顿时间也约长</span><br><span class="line">&gt;2.为了更好的控制停顿时间,将堆空间划分不同的小区间,每个小区间独立使用,独立回收</span><br><span class="line">&gt;3.不是回收整个堆空间,所以减少一次停顿所消耗的时间</span><br></pre></td></tr></table></figure></blockquote><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="串行垃圾回收器"><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h5><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;在一个线程内执行垃圾回收操作</span><br><span class="line"></span><br><span class="line">年轻代用复制算法、老年代用标记压缩法</span><br></pre></td></tr></table></figure><p>SerialGC[新生]</p><p>SerialOldGC[老年]</p></blockquote><h5 id="并行垃圾回收器"><a href="#并行垃圾回收器" class="headerlink" title="并行垃圾回收器"></a>并行垃圾回收器</h5><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;在多个线程中执行垃圾回收操作</span><br><span class="line"></span><br><span class="line">年轻代用复制算法、老年代用标记压缩法</span><br></pre></td></tr></table></figure><p>ParNew[新生]</p><p>ParallelScavengeGC[新生]</p><p>ParallelOldGC[老年]</p></blockquote><h5 id="G1回收器-好用"><a href="#G1回收器-好用" class="headerlink" title="G1回收器[好用]"></a>G1回收器[好用]</h5><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G1(Garbage-First)是并发垃圾回收器, 主要目标用于配备多颗CPU的服务器，治理大内存。是JDK1.7提供的一个新收集器，是当今收集器技术发展的最前沿成果之一。</span><br><span class="line"></span><br><span class="line">G1将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了, 它们都是一部分Region(不需要连续)的集合。</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.优先回收垃圾多的区域(Region)</span><br><span class="line">2.保证了在有效的时间内达到更高的效率</span><br><span class="line"></span><br><span class="line">特点</span><br><span class="line">1.一整块堆内存被分成多个独立的区域Regions</span><br><span class="line">2.存活对象被拷贝到新的Survivor区</span><br><span class="line">3.新生代内存由一组不连续的堆heap区组成，使得可以动态调整各个区域</span><br><span class="line">4.多线程并发GC</span><br><span class="line">5.young GC会有STW</span><br></pre></td></tr></table></figure></blockquote><h5 id="垃圾回器对比"><a href="#垃圾回器对比" class="headerlink" title="垃圾回器对比"></a>垃圾回器对比</h5><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209141950404.png" alt="image-20220914195010322"></p></blockquote><h2 id="3-线程私有区域"><a href="#3-线程私有区域" class="headerlink" title="3.线程私有区域"></a>3.线程私有区域</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用来保存下一条要执行的CPU指令的地址</span><br></pre></td></tr></table></figure><h5 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h5><p>方法栈帧</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.方法出口</span><br><span class="line">谁引用此方法,存储谁的地址</span><br><span class="line">2.动态链接</span><br><span class="line">存储指向方法区对应方法的地址</span><br><span class="line">3.操作数栈</span><br><span class="line">临时的空间,存储计算,复制等操作用到的操作数</span><br><span class="line">4.局部变量表</span><br><span class="line">储存方法参数,和局部变量</span><br></pre></td></tr></table></figure><p>main方法栈帧</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.局部变量表</span><br></pre></td></tr></table></figure><h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">native修饰的方法形成的栈</span><br></pre></td></tr></table></figure></blockquote><h2 id="4-线程公有区域"><a href="#4-线程公有区域" class="headerlink" title="4.线程公有区域"></a>4.线程公有区域</h2><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote><p>具体实现</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.=  1.7 永久代</span><br><span class="line">2.&gt;= 1.8元空间（Meta Space）</span><br><span class="line"></span><br><span class="line">区别</span><br><span class="line">1.永久代向JVM申请内存空间,元空间直接向内存申请空间</span><br><span class="line">2.永久代存在字符串常量池,元空间不存在字符串常量池</span><br></pre></td></tr></table></figure><p>元空间</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.类信息：类中定义的构造器、接口定义</span><br><span class="line">2.静态变量</span><br><span class="line">3.常量</span><br><span class="line">4.运行时常量池</span><br><span class="line">5.类中方法的代码</span><br></pre></td></tr></table></figure></blockquote><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote><p>数据结构</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.对象</span><br><span class="line">2.数组</span><br></pre></td></tr></table></figure><p>空间结构</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209141911452.png" alt="image-20220914191127362"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.新生代(堆内存1/3)</span><br><span class="line">&gt;.Eden区[伊甸园区](新生代8/10)</span><br><span class="line">&gt;.幸存者区(新生代2/10)</span><br><span class="line">==&gt;Survivor0(From)</span><br><span class="line">==&gt;Survivor1(To)</span><br><span class="line">2.老年代(堆内存2/3)</span><br><span class="line">3.永久代[非堆]</span><br></pre></td></tr></table></figure><p>工作机制</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.新创建的对象会放在Eden区</span><br><span class="line">2.当Eden区使用的空间到达了一定的比例,会触发MinorGC清除垃圾对象,剩下来的对象被称为幸存者</span><br><span class="line">3.幸存者会被转移到幸存者区(幸存者区将会轮转清空,重新和Eden区对象组合一起重新排列)</span><br><span class="line">4.如果一个对象15次GC还幸存,转移到老年区</span><br><span class="line">5.如果幸存者区满了,Eden区的幸存者会转移到老年区</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.Eden区主要是生命周期很短的对象来来往往</span><br><span class="line">2.老年代主要是生命周期很长的对象，例如：IOC容器对象、线程池对象、数据库连接池对象等等</span><br><span class="line">3.幸存者区作为二者之间的过渡地带</span><br><span class="line"></span><br><span class="line">关于永久代</span><br><span class="line">从理论上来说属于堆</span><br><span class="line">从具体实现上来说不属于堆</span><br></pre></td></tr></table></figure></blockquote><h3 id="直接内存-堆外内存"><a href="#直接内存-堆外内存" class="headerlink" title="直接内存(堆外内存)"></a>直接内存(堆外内存)</h3><blockquote><p>含义</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接去内存条申请的内存,仅供NIO使用</span><br></pre></td></tr></table></figure></blockquote><h2 id="5-优化"><a href="#5-优化" class="headerlink" title="5.优化"></a>5.优化</h2><h3 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h3><blockquote><p>堆</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.majorGC(针对年轻代) 一两个月一次，如果业务量比较大，majorGC最少也要几天一次GC</span><br><span class="line">2.minorGC(针对老年代) 几个小时发生一次</span><br><span class="line">3.年轻代占整个堆的3/8,可以在附近微调</span><br></pre></td></tr></table></figure><p>元空间</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.8G内存，建议将元空间设置为256M，随着服务器内存大小的变化，元空间依次按比例变化即可.</span><br></pre></td></tr></table></figure></blockquote><h3 id="GC-1"><a href="#GC-1" class="headerlink" title="GC"></a>GC</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.选择合适的垃圾回收器：G1</span><br><span class="line">2.调节并行垃圾回收的线程数：和cpu的核数保持一致</span><br></pre></td></tr></table></figure></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.尽量使用StringBuffer、StringBuilder</span><br><span class="line">2.对于大对象用完及时释放、Connection、FIS、FOS、Map、List</span><br><span class="line">3.尽量少使用try...catch，尤其是不要在for循环内部使用try...catch</span><br></pre></td></tr></table></figure></blockquote><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.加内存</span><br><span class="line">2.选择合适磁盘[固态、机械]</span><br><span class="line">3.选择合适的CPU</span><br></pre></td></tr></table></figure></blockquote><h2 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6.面试题"></a>6.面试题</h2><h3 id="谈谈你对JVM的理解"><a href="#谈谈你对JVM的理解" class="headerlink" title="谈谈你对JVM的理解"></a>谈谈你对JVM的理解</h3><blockquote><blockquote><ul><li>JVM 技术的作用：提升、优化项目性能</li><li>JVM 结构<ul><li>类加载机制</li><li>Java栈</li><li>堆<ul><li>新生代<ul><li>Eden 区</li><li>幸存者区：S0+S1</li></ul></li><li>老年代</li></ul></li><li>元空间</li></ul></li><li>GC<ul><li>垃圾对象的标记<ul><li>引用技术法</li><li>GC Roots：概念→原理（堆外指向堆内）→GC Root 对象</li></ul></li><li>垃圾回收算法</li></ul></li><li>JVM 常用参数</li></ul></blockquote></blockquote><h3 id="Java-8-的虚拟机有什么更新"><a href="#Java-8-的虚拟机有什么更新" class="headerlink" title="Java 8 的虚拟机有什么更新"></a>Java 8 的虚拟机有什么更新</h3><blockquote><blockquote><ul><li>永久代取消，变成元空间；</li><li>常量池放入到元空间，但是一直都是在方法区中</li></ul></blockquote></blockquote><h3 id="什么是OOM"><a href="#什么是OOM" class="headerlink" title="什么是OOM"></a>什么是OOM</h3><blockquote><blockquote><ul><li>概念：堆内存溢出错误</li><li>全类名：java.lang.OutofMemoryError</li><li>产生原因：经过多轮 GC，连老年代都已经没了空间，还要继续创建新的对象。</li><li>详细过程：堆空间对象存储、GC 流程。</li><li>相关拓展：StackOverFlowError</li></ul></blockquote></blockquote><h3 id="什么是StackOverflowError"><a href="#什么是StackOverflowError" class="headerlink" title="什么是StackOverflowError"></a>什么是StackOverflowError</h3><blockquote><blockquote><ul><li>概念：栈内存溢出错误</li><li>产生原因：在一个线程中，栈内存分配给它的空间被不断新增的栈帧填满，没有及时释放栈帧。</li><li>详细过程：栈帧概念，栈帧中存储的数据，典型情况（无法退出的递归）</li><li>相关拓展：OOM</li></ul></blockquote></blockquote><h3 id="JVM-的常用参数调优你知道哪些"><a href="#JVM-的常用参数调优你知道哪些" class="headerlink" title="JVM 的常用参数调优你知道哪些?"></a>JVM 的常用参数调优你知道哪些?</h3><blockquote><blockquote><table><thead><tr><th>参数名</th><th>参数作用</th></tr></thead><tbody><tr><td>-Xms</td><td>★堆内存的初始大小</td></tr><tr><td>-Xmx</td><td>★堆内存的最大值（最多能够向操作系统申请多少）</td></tr><tr><td>-Xmn</td><td>新生代大小</td></tr><tr><td>-XX:PermSize</td><td>设置永久代(perm gen)初始值</td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td></tr></tbody></table></blockquote></blockquote><h3 id="谈谈-JVM-中，对类加载器你的认识"><a href="#谈谈-JVM-中，对类加载器你的认识" class="headerlink" title="谈谈 JVM 中，对类加载器你的认识"></a>谈谈 JVM 中，对类加载器你的认识</h3><blockquote><blockquote><p>双亲委派机制</p><ul><li>类加载器分类<ul><li>启动类加载器</li><li>扩展类加载器</li><li>应用类加载器</li><li>自定义加载器</li></ul></li><li>父子关系<ul><li>关系一：启动类加载器是扩展类加载器的父亲</li><li>关系二：扩展类加载器是应用类加载器的父亲</li></ul></li><li>查找机制：先让父加载器查找，如果找不到再让子加载器加载</li><li>好处<ul><li>好处1：避免重复操作</li><li>好处2：避免恶意替换核心 API</li></ul></li></ul></blockquote></blockquote><h3 id="堆内存空间大小设置的建议"><a href="#堆内存空间大小设置的建议" class="headerlink" title="堆内存空间大小设置的建议"></a>堆内存空间大小设置的建议</h3><blockquote><blockquote><ul><li>最大堆内存和初始化堆内存设置为一致：直接一步到位设置为能够使用的最大值，免除频繁申请空间的操作。<ul><li>空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制</li><li>空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</li></ul></li><li>新生代大小：Sun官方推荐配置为整个堆的 3/8</li></ul></blockquote></blockquote><h3 id="Java-栈每个线程占用空间大小如何设置"><a href="#Java-栈每个线程占用空间大小如何设置" class="headerlink" title="Java 栈每个线程占用空间大小如何设置"></a>Java 栈每个线程占用空间大小如何设置</h3><blockquote><blockquote><p>JDK5.0 以后每个线程所占用的栈内存大小为 1M，以前是 256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。一般小的应用， 如果栈不是很深， 应该是128k够用的。大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。</p></blockquote></blockquote><h3 id="JVM内存分哪几个区，每个区的作用是什么"><a href="#JVM内存分哪几个区，每个区的作用是什么" class="headerlink" title="JVM内存分哪几个区，每个区的作用是什么?"></a>JVM内存分哪几个区，每个区的作用是什么?</h3><blockquote><blockquote><p><strong>（1****）方法区</strong>：</p><p>   a. 有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载</p><p>   b. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。</p><p>   c. 该区域是被线程共享的。</p><p>   d. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</p><p><strong>（2****）虚拟机栈</strong>: </p><p>   a. 虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</p><p>   b. 虚拟机栈是线程私有的，它的生命周期与线程相同。</p><p>   c. 局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定</p><p>   d. 操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</p><p>   e. 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</p><p><strong>（3****）本地方法栈</strong>：<br> 本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。</p><p><strong>（4****）堆</strong>：</p><p>java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。</p><p><strong>（2）****程序计数器：</strong></p><p>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。</p></blockquote></blockquote><h3 id="Java中垃圾收集的方法有哪些"><a href="#Java中垃圾收集的方法有哪些" class="headerlink" title="Java中垃圾收集的方法有哪些?"></a>Java中垃圾收集的方法有哪些?</h3><blockquote><blockquote><p>采用分区分代回收思想：</p><p><strong>1****）复制算法</strong> 年轻代中使用的是Minor GC，这种GC算法采用的是复制算法(Copying)</p><p>a) 效率高，缺点：需要内存容量大，比较耗内存</p><p>b) 使用在占空间比较小、刷新次数多的新生区</p><p><strong>2****）标记-清除</strong> 老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p><p>a) 效率比较低，会差生碎片。</p><p><strong>3****）标记-整理</strong> 老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p><p>a) 效率低速度慢，需要移动对象，但不会产生碎片。</p></blockquote></blockquote><h3 id="如何判断一个对象是否存活-或者GC对象的判定方法"><a href="#如何判断一个对象是否存活-或者GC对象的判定方法" class="headerlink" title="如何判断一个对象是否存活?(或者GC对象的判定方法)"></a>如何判断一个对象是否存活?(或者GC对象的判定方法)</h3><blockquote><blockquote><p>判断一个对象是否存活有两种方法: </p><p><strong>（1****）引用计数法</strong></p><p>所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收. </p><p>引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。</p><p>*<em>（2</em>***）可达性算法(**<strong>引用链法)</strong> </p><p>该算法的基本思路就是通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。</p><p>在java中可以作为GC Roots的对象有以下几种：虚拟机栈中引用的对象、方法区类静态属性引用的对象、方法区常量池引用的对象、本地方法栈JNI引用的对象。</p></blockquote></blockquote><h3 id="Java类加载过程"><a href="#Java类加载过程" class="headerlink" title="Java类加载过程?"></a>Java类加载过程?</h3><blockquote><blockquote><p>Java类加载需要经历一下几个过程：</p><p><strong>（1****）加载</strong></p><p>加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：</p><p>   a. 通过一个类的全限定名获取该类的二进制流。</p><p>   b. 将该二进制流中的静态存储结构转化为方法去运行时数据结构。 </p><p>   c. 在内存中生成该类的Class对象，作为该类的数据访问入口。</p><p><strong>（2****）验证</strong></p><p>验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证: </p><p>   a. 文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型. </p><p>   b. 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</p><p>   c. 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</p><p>   d. 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</p><p>   e. 准备</p><p>准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><p><strong>（3****）解析</strong></p><p>该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。</p><p><strong>（4****）初始化</strong></p><p>初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</p></blockquote></blockquote><h3 id="简述java内存分配与回收策略以及Minor-GC和Major-GC（full-GC）"><a href="#简述java内存分配与回收策略以及Minor-GC和Major-GC（full-GC）" class="headerlink" title="简述java内存分配与回收策略以及Minor GC和Major GC（full GC）"></a>简述java内存分配与回收策略以及Minor GC和Major GC（full GC）</h3><blockquote><blockquote><p><strong>内存分配：</strong></p><p><strong>（1****）栈区</strong>：栈分为java虚拟机栈和本地方法栈</p><p><strong>（2****）堆区</strong>：堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，主要放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。</p><p><strong>（3****）方法区</strong>：被所有线程共享区域，用于存放已被虚拟机加载的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（permanment generation）</p><p><strong>（4****）程序计数器</strong>：当前线程所执行的行号指示器。通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。线程私有的。</p><p><strong>回收策略以及Minor GC<strong><strong>和Major GC</strong></strong>：</strong></p><p>（1）对象优先在堆的Eden区分配。</p><p>（2）大对象直接进入老年代。</p><p>（3）长期存活的对象将直接进入老年代。</p><p>当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过节了`过节了</title>
      <link href="/archives/4129657f.html"/>
      <url>/archives/4129657f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="中秋快乐"><a href="#中秋快乐" class="headerlink" title="中秋快乐"></a>中秋快乐</h2><blockquote><p>故事`小剧场</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">中秋节吃月饼相传始于元代。据说，当时，中原广大人民不堪忍受元朝统治阶级的残酷统治，纷纷起义抗元。</span><br><span class="line">朱元璋联合各路反抗力量准备起义。但朝庭官兵搜查的十分严密，传递消息十分困难。</span><br><span class="line">军师刘伯温便想出一计策，命令属下把藏有“八月十五夜起义”的纸条藏入饼子里面，</span><br><span class="line">再派人分头传送到各地起义军中，通知他们在八月十五日晚上起义响应。到了起义的那天，</span><br><span class="line">各路义军一齐响应。很快，徐达就攻下元大都，起义成功了。消息传来，朱元璋高兴得连忙传下口谕，</span><br><span class="line">在即将来临的中秋节，让全体将士与民同乐，并将当年起兵时以秘密传递信息的“月饼”，</span><br><span class="line">作为节令糕点赏赐群臣。此后，“月饼”制作越发精细，品种更多。</span><br><span class="line">之后中秋节吃月饼的习俗便在民间流传开来。</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209101652279.png" alt="202209101652279"></p></blockquote><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209101642909.png" alt="202209101642909"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中秋节 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今日图片2022-09-07</title>
      <link href="/archives/3aecd444.html"/>
      <url>/archives/3aecd444.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🚗"><a href="#🚗" class="headerlink" title="🚗"></a>🚗</h1><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/2ec1089a880511ebb6edd017c2d2eca2.jpg" alt="2ec1089a880511ebb6edd017c2d2eca2"></p></blockquote><h1 id="🚓"><a href="#🚓" class="headerlink" title="🚓"></a>🚓</h1><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/wallhaven-x8jj9o.png" alt="wallhaven-x8jj9o"></p></blockquote><h1 id="🚕"><a href="#🚕" class="headerlink" title="🚕"></a>🚕</h1><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/wallhaven-8ovykj.jpg" alt="wallhaven-8ovykj"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 今日图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql高级</title>
      <link href="/archives/af491aa0.html"/>
      <url>/archives/af491aa0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySql高级"><a href="#MySql高级" class="headerlink" title="MySql高级"></a>MySql高级</h1><h2 id="1️⃣配置文件"><a href="#1️⃣配置文件" class="headerlink" title="1️⃣配置文件"></a>1️⃣配置文件</h2><blockquote><p>配置文件所在位置</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/mysql/my.cnf</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>设置字符集为UTF-8</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8<span class="built_in">_</span>general<span class="built_in">_</span>ci</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>查询引擎</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure></blockquote><h2 id="2️⃣逻辑架构"><a href="#2️⃣逻辑架构" class="headerlink" title="2️⃣逻辑架构"></a>2️⃣逻辑架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209071946247.png" alt="image-20220907194606113"></p></blockquote><h3 id="逻辑四层"><a href="#逻辑四层" class="headerlink" title="逻辑四层"></a>逻辑四层</h3><blockquote><p>连接层</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.当客户端访问Mysql服务器的时候,要建立TCP连接</span><br><span class="line">2.经过三次握手成功建立连接后,服务器会对TCP传输过来的账号数据进行获取.</span><br><span class="line">3.对账号密码进行认证</span><br><span class="line">4.在权限表中对账号的权限进行认证</span><br><span class="line">5.TCP分配专门的线程做与客户端的交互</span><br></pre></td></tr></table></figure><p>服务层</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SQL接口</span><br><span class="line">1.接受用户的SQL命令</span><br><span class="line">2.返回用户需要查询的结果</span><br><span class="line"></span><br><span class="line">Parser解析器</span><br><span class="line">1.对用户SQL语法进行解析</span><br><span class="line">2.将SQL语法分解成数据结构</span><br><span class="line">3.进行语法优化</span><br><span class="line">4.讲数据结果传给后续步骤</span><br><span class="line"></span><br><span class="line">Optimizer查询优化器</span><br><span class="line">1.确定使用什么索引进行查询</span><br><span class="line">2.生成SQL语句的执行计划</span><br><span class="line"></span><br><span class="line">Caches<span class="built_in">&amp;</span>Buffers查询缓存组件</span><br><span class="line">1.缓存一条SQL语句的返回结果</span><br></pre></td></tr></table></figure><p>引擎层</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.插拔式的存储引擎</span><br><span class="line">2.负责数据的存储和提取</span><br><span class="line">3.通过API与存储引擎进行通信</span><br></pre></td></tr></table></figure><p>存储层</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.数据库所有的数据都是存储在文件系统上面的</span><br><span class="line">2.存储层与存储引擎进行交互</span><br></pre></td></tr></table></figure><p>小结</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端</span><br><span class="line">2.SQL层(服务层)：对 SQL 语句进行查询处理,与数据库文件的存储方式无关</span><br><span class="line">3.存储引擎层：与数据库文件打交道，负责数据的存储和读取</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209072008840.png" alt="image-20220907200839776"></p></blockquote><h2 id="3️⃣SQL执行流程"><a href="#3️⃣SQL执行流程" class="headerlink" title="3️⃣SQL执行流程"></a>3️⃣SQL执行流程</h2><h3 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209072012175.png" alt="image-20220907201247048"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.查询缓存</span><br><span class="line">===&gt;如果在查询缓存中发现了相同的SQL语句,会将缓存的结果直接返回</span><br><span class="line">===&gt;因为查询缓存的命中率不高,所以在8版本去掉了</span><br><span class="line">2.解析器</span><br><span class="line">===&gt;对SQL语句进行语法解析,判断用户的SQL是否满足SQL语法</span><br><span class="line">===&gt;如果用户语法正确,会生对应的语法树</span><br><span class="line">3.优化器</span><br><span class="line">===&gt;确定SQL的执行路径,是全文检索还是索引检索</span><br><span class="line">===&gt;优化器可以分为逻辑查询和物理查询优化</span><br><span class="line">===&gt;生成执行计划</span><br><span class="line">4.执行器</span><br><span class="line">===&gt;根据执行计划调用存储引擎接口</span><br><span class="line">===&gt;将满足条件的结果集返回</span><br></pre></td></tr></table></figure></blockquote><h2 id="4️⃣xxx"><a href="#4️⃣xxx" class="headerlink" title="4️⃣xxx"></a>4️⃣xxx</h2><h2 id="5️⃣xxx"><a href="#5️⃣xxx" class="headerlink" title="5️⃣xxx"></a>5️⃣xxx</h2><h2 id="6️⃣xxx"><a href="#6️⃣xxx" class="headerlink" title="6️⃣xxx"></a>6️⃣xxx</h2><h2 id="7️⃣xxx"><a href="#7️⃣xxx" class="headerlink" title="7️⃣xxx"></a>7️⃣xxx</h2><h2 id="8️⃣xxx"><a href="#8️⃣xxx" class="headerlink" title="8️⃣xxx"></a>8️⃣xxx</h2><h2 id="9️⃣xxx"><a href="#9️⃣xxx" class="headerlink" title="9️⃣xxx"></a>9️⃣xxx</h2><h2 id="🔟xxx"><a href="#🔟xxx" class="headerlink" title="🔟xxx"></a>🔟xxx</h2>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql高级 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
