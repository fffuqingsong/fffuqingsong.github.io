<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySql高级</title>
      <link href="/archives/af491aa0.html"/>
      <url>/archives/af491aa0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote><p>配置文件所在位置</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/mysql/my.cnf</span><br></pre></td></tr></table></figure><p>设置字符集为UTF-8</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8<span class="built_in">_</span>general<span class="built_in">_</span>ci</span><br></pre></td></tr></table></figure><p>查询引擎</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure></blockquote><h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209071946247.png" alt="image-20220907194606113"></p></blockquote><h3 id="逻辑四层"><a href="#逻辑四层" class="headerlink" title="逻辑四层"></a>逻辑四层</h3><blockquote><p>连接层</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.当客户端访问Mysql服务器的时候,要建立TCP连接</span><br><span class="line">2.经过三次握手成功建立连接后,服务器会对TCP传输过来的账号数据进行获取.</span><br><span class="line">3.对账号密码进行认证</span><br><span class="line">4.在权限表中对账号的权限进行认证</span><br><span class="line">5.TCP分配专门的线程做与客户端的交互</span><br></pre></td></tr></table></figure><p>服务层</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SQL接口</span><br><span class="line">1.接受用户的SQL命令</span><br><span class="line">2.返回用户需要查询的结果</span><br><span class="line"></span><br><span class="line">Parser解析器</span><br><span class="line">1.对用户SQL语法进行解析</span><br><span class="line">2.将SQL语法分解成数据结构</span><br><span class="line">3.进行语法优化</span><br><span class="line">4.讲数据结果传给后续步骤</span><br><span class="line"></span><br><span class="line">Optimizer查询优化器</span><br><span class="line">1.确定使用什么索引进行查询</span><br><span class="line">2.生成SQL语句的执行计划</span><br><span class="line"></span><br><span class="line">Caches<span class="built_in">&amp;</span>Buffers查询缓存组件</span><br><span class="line">1.缓存一条SQL语句的返回结果</span><br></pre></td></tr></table></figure><p>引擎层</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.插拔式的存储引擎</span><br><span class="line">2.负责数据的存储和提取</span><br><span class="line">3.通过API与存储引擎进行通信</span><br></pre></td></tr></table></figure><p>存储层</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.数据库所有的数据都是存储在文件系统上面的</span><br><span class="line">2.存储层与存储引擎进行交互</span><br></pre></td></tr></table></figure><p>小结</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端</span><br><span class="line">2.SQL层(服务层)：对 SQL 语句进行查询处理,与数据库文件的存储方式无关</span><br><span class="line">3.存储引擎层：与数据库文件打交道，负责数据的存储和读取</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209072008840.png" alt="image-20220907200839776"></p></blockquote><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209072012175.png" alt="image-20220907201247048"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.建立连接</span><br><span class="line">MySQL 客户端通过协议与 MySQL 服务器建连接，发送查询语句。</span><br><span class="line">2.查询缓存</span><br><span class="line">===&gt;如果在查询缓存中发现了相同的SQL语句,会将缓存的结果直接返回</span><br><span class="line">===&gt;因为查询缓存的命中率不高,所以在8版本去掉了</span><br><span class="line">3.解析器</span><br><span class="line">===&gt;对SQL语句进行语法解析,判断用户的SQL是否满足SQL语法</span><br><span class="line">===&gt;如果用户语法正确,会生对应的语法树</span><br><span class="line">4.优化器</span><br><span class="line">===&gt;确定SQL的执行路径,是全文检索还是索引检索</span><br><span class="line">===&gt;优化器可以分为逻辑查询和物理查询优化</span><br><span class="line">===&gt;生成执行计划</span><br><span class="line">5.执行器</span><br><span class="line">===&gt;根据执行计划调用存储引擎接口</span><br><span class="line">===&gt;将满足条件的结果集返回</span><br></pre></td></tr></table></figure></blockquote><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><blockquote><p>查看MySQl支持的引擎</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209231348894.png" alt="image-20220923134845764"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure><p>查看默认的存储引擎</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209231350052.png" alt="image-20220923135007940"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;%storage_engine&quot;;</span><br></pre></td></tr></table></figure></blockquote><h3 id="引擎分类"><a href="#引擎分类" class="headerlink" title="引擎分类"></a>引擎分类</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.InnoDB</span><br><span class="line">==&gt; mysql 5.5 版本之后默认使用InnoDB引擎</span><br><span class="line">==&gt; 用来处理短期事务,可以确保事务的完整提交和回滚</span><br><span class="line">==&gt; 除了增查操作,还需要更新和删除操作,优先选择 InnoDB 存储引擎。</span><br><span class="line">2.MyISAM</span><br><span class="line">==&gt; mysql 5.5 版本之前默认使用MyISAM引擎</span><br><span class="line">==&gt; 提供了全文索引,压缩,空间函数等功能</span><br><span class="line">==&gt; 不支持事务和行级锁,奔溃后无法进行安全恢复</span><br><span class="line">==&gt; 数据文件结构：- .frm 存储定义表 - .MYD 存储数据 - .MYI 存储索引</span><br><span class="line">3.Archive</span><br><span class="line">==&gt; 只支持添加和查询操作</span><br><span class="line">4.Blackhole</span><br><span class="line">==&gt; 没有实现任何存储机制,丢弃所有插入的数据,不做任何保存</span><br><span class="line">==&gt; 但服务器会记录日志,用于复制数据到备库，或者简单地记录到日志。</span><br><span class="line">5.CSV</span><br><span class="line">==&gt; 不支持索引</span><br><span class="line">==&gt; 存储的数据可以直接放在操作系统中,可以直接用文本编辑器或者Excel读取</span><br><span class="line">6.Memory</span><br><span class="line">==&gt; 如果需要快速地访问数据，且这些数据不会被修改，重启以后丢失也没有关系，那么使用 Memory 表是非常有用。</span><br><span class="line">==&gt; Memory 表至少比 MyISAM 表要快一个数量级。</span><br></pre></td></tr></table></figure><p>InnoDB与MyISAM对比</p><table><thead><tr><th><strong>对比项</strong></th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td><strong>外键</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>事务</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>行表锁</strong></td><td>支持表锁  <br>即使操作一条记录也会锁住整个表，  <br>不适合高并发操作</td><td>支持行锁<br>操作时只锁某一行，不对其它行有影响，  <br>适合高并发操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，  <br>对内存要求较高， <br>而且内存大小对性能有决定性的影响</td></tr><tr><td>系统提供预创建数据库表  <br>给用户使用</td><td>是</td><td>否</td></tr><tr><td>关注点</td><td>性能：节省资源、消耗少、简单业务</td><td>事务：并发写、事务、需要更大资源</td></tr><tr><td>默认安装</td><td>是</td><td>是</td></tr><tr><td>默认使用</td><td>5.5版本前</td><td>5.5版本开始</td></tr></tbody></table></blockquote><h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><blockquote><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><table><thead><tr><th>索引类型</th><th>索引特点</th></tr></thead><tbody><tr><td>单列索引</td><td>即一个索引是只根据一个字段创建的，里面只包含单个列，  <br>一个表可以有多个单值索引（也叫单列索引）</td></tr><tr><td>联合索引</td><td>即一个索引包含多个列（也叫多值索引、多列索引）</td></tr><tr><td>唯一索引</td><td>索引列的值必须唯一，但允许有空值，空值可以有多个</td></tr><tr><td>主键索引</td><td>设定为主键后数据库会自动建立索引，InnoDB 为聚簇索引</td></tr></tbody></table><h4 id="基本操作语法"><a href="#基本操作语法" class="headerlink" title="基本操作语法"></a>基本操作语法</h4><p>创建单值索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index 索引名 on 字段所在表(字段);</span><br></pre></td></tr></table></figure><p>创建唯一索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create unique index 索引名 on 字段所在表(字段);</span><br></pre></td></tr></table></figure><p>联合索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index 索引名 on 字段所在表(字段1,字段2);</span><br></pre></td></tr></table></figure><p>删除索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index 要删除的索引名 on 索引所在的表;</span><br></pre></td></tr></table></figure></blockquote><h3 id="创建索引的情况"><a href="#创建索引的情况" class="headerlink" title="创建索引的情况"></a>创建索引的情况</h3><blockquote><p>需要创建索引的情况</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.主键自动建立唯一索引</span><br><span class="line">2.频繁作为查询条件的字段应该创建索引</span><br><span class="line">3.表之间关联查询的情况</span><br><span class="line">  -涉及的表不能大于3张以上</span><br><span class="line">  -给大表的关联字段创建索引</span><br><span class="line">  -关联字段在各个表中的类型要一致</span><br><span class="line">4.因为一条SQL语句只能用到一个索引,所以多个字段查询的应创建组合索引而不是单列索引</span><br><span class="line">5.查询中排序的字段</span><br><span class="line">6.查询中统计和分组的字段</span><br></pre></td></tr></table></figure><p>下列情况创建索引效果更好</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.字段的数值有唯一性限制</span><br><span class="line">2.类型小（字节宽度小）的字段</span><br></pre></td></tr></table></figure><p>不要创建索引的情况</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.数据库表中记录数量小于 300 万条时,创建索引也不会让搜索速度有明显提升。</span><br><span class="line">2.经常增删改的表,建立索引是为了提高查询的速度.建立索引会降低更新表的速度,因为更新表要重排索引,重排索引要全表扫描,所以非常的耗时间</span><br><span class="line">3.条件,排序,分组查询都用不到的字段</span><br><span class="line">4.无法排序的字段</span><br><span class="line">5.不要创建重复的索引</span><br></pre></td></tr></table></figure></blockquote><h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><h3 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.InnoDb引擎最小的存储单位是页,不是所有页都是数据页,只有存放原始数据的页称为数据页</span><br><span class="line">2.一页默认大小为16KB,假设一条记录占1KB,那一个数据页大概能存16条记录一个数据库需要很多数据页来存放数据</span><br></pre></td></tr></table></figure></blockquote><h3 id="数据页内部"><a href="#数据页内部" class="headerlink" title="数据页内部"></a>数据页内部</h3><blockquote><p>主键排序</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据页内部是根据主键来排序的,当我们在数据页中查找数据时是根据二分法来查找的</span><br></pre></td></tr></table></figure><p>数据页编号</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个数据库有很多数据页,每个数据页都有自己的唯一编号,相当于这个数据页的地址</span><br></pre></td></tr></table></figure></blockquote><h3 id="数据页如何便于查找"><a href="#数据页如何便于查找" class="headerlink" title="数据页如何便于查找"></a>数据页如何便于查找</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.排序</span><br><span class="line">==&gt; 根据主键值对所有数据页的数据进行排序</span><br><span class="line">2.双向链表</span><br><span class="line">==&gt; 将所有的数据页组成双向链表</span><br></pre></td></tr></table></figure></blockquote><h3 id="数据页设定目录"><a href="#数据页设定目录" class="headerlink" title="数据页设定目录"></a>数据页设定目录</h3><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了能够更快速的查找到数据,我们可以给数据页设置目录</span><br></pre></td></tr></table></figure><p>第一层目录</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209232110898.png" alt="image-20220923211031817"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.如何设置?</span><br><span class="line">==&gt; 将一个数据页中最小主键值和数据页编号组成一个目录页</span><br><span class="line">==&gt; 目录页因为主键值,所以目录页中的记录是有序的</span><br><span class="line"></span><br><span class="line">2.搜索</span><br><span class="line">==&gt; 假设目录页中有3条记录,依次最小主键为1,11,21,这样就有三个区间[1,11),[11,21),[21, ...)</span><br><span class="line">情景:</span><br><span class="line">1.搜索主键值为11的数据</span><br><span class="line">2.11在[11,21)中,因为[11,21)区间对应的数据页码为2</span><br><span class="line">3.进入页码为2的数据页,在数据页内部根据二分法进行主键的查找</span><br><span class="line"></span><br><span class="line">小贴士💖</span><br><span class="line">1.不管是目录页还是数据页都是页,默认大小都是16KB</span><br><span class="line">2.一个主键值8字节,一个页码8个字节,一个目录页大概能存1024条记录</span><br></pre></td></tr></table></figure><p>第二层目录</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209240855200.png" alt="image-20220924085544116"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.如何设置？</span><br><span class="line">==&gt; 为了更进一步的查找，我们可以给目录页再设置目录页，多层级的目录页</span><br><span class="line"></span><br><span class="line">2.搜索</span><br><span class="line">用户搜索的主键值是：60。现在 13 号目录页中包含的区间：</span><br><span class="line"></span><br><span class="line">- [1,51)</span><br><span class="line">- [51,150)</span><br><span class="line">- [150,...)</span><br><span class="line"></span><br><span class="line">所以 60 会落在 [51,150) 区间，所以继续查找页码为 8 的目录页：</span><br><span class="line"></span><br><span class="line">- [51,81)</span><br><span class="line">- [81,100)</span><br><span class="line">- [100,...)</span><br><span class="line"></span><br><span class="line">所以 60 会落在 [51,81) 区间，所以继续查找页码为 5 的数据页，根据主键执行二分法查找。</span><br></pre></td></tr></table></figure></blockquote><h4 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a>树型结构</h4><blockquote><p>1.示意图</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209240903306.png" alt="image-20220924090316218"></p><p>2.对接概念</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.B+Tree</span><br><span class="line">上图其实就是B+Tree的结构,多层目录页和最终的数据页组成,每页,无论是目录页还是数据页都是一个节点</span><br><span class="line">2.聚簇索引</span><br><span class="line">聚簇索引就是将主键作为索引值,且树形结构中存在数据页[原始数据]</span><br></pre></td></tr></table></figure><p>3.B+Tree 能够存储的记录数量</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.当结构只有一层的时候</span><br><span class="line">==&gt; 只有一个节点,并且这个节点是根节点,并且这个节点是数据页</span><br><span class="line">==&gt; 一个数据页默认大小16kb,假设一条记录占1kb,那一个数据页能存储16条数据</span><br><span class="line">2.当结构有4层时</span><br><span class="line">==&gt; 根节点是目录页,目录页一条记录占16B(主键8B+数据也页码8B),所以一页目录页16kb/16b=1024</span><br><span class="line">==&gt; 最后一层一定为数据页,数据页一页大概能存16条数据,那四层能存: 1024*1024*1024*16≈170亿</span><br></pre></td></tr></table></figure><p>4.B+Tree 层次对性能的影响</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.根节点数据常驻在内存中</span><br><span class="line">2.其他层的数据常驻于磁盘</span><br><span class="line">3.访问第一层下一层的节点会进行一次IO,访问硬盘</span><br><span class="line">4.所以层数越少,IO次数就越少,性能就越好</span><br></pre></td></tr></table></figure><p>5.BTree 为什么高瘦？</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.BTree 的每个节点都是数据页</span><br><span class="line">2.数据页因为存的都是数据,所以条数很少,按照每条记录1kb,大概只能存16条记录</span><br><span class="line">3.而B+Tree因为节点有目录页,目录页一条记录由『主键8B+页码8B』组成,一条记录16B,一页存1024条,所以宽</span><br><span class="line">4.因为BTree一个节点容纳条数少,所以数据量大的话,只能一层一层向下分,导致深度增加</span><br><span class="line">5.对于查询来说,深度增加一层,就会导致IO次数+1,所以BTree的性能不如B+Tree</span><br></pre></td></tr></table></figure><p>6.BTree 为什么每个节点都存原始数据？</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为BTree是将所有的主键排序,父节点出现过的主键不会在子节点中出现,所以每个主键只能出现在一个节点中,而每个节点都有对应的数据,所以每个节点都要存储数据,每个节点都是数据页</span><br></pre></td></tr></table></figure><p>7.BTree 和 B+Tree 的区别总结</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.BTree节点没有目录页,全是数据页</span><br><span class="line">2.BTree节点存储主键值,原始数据地址值,数据页页码引用</span><br><span class="line">3.BTree每个主键值只能在一个节点上出现,所以每个节点都需要保存原始数据</span><br><span class="line">4.BTree每个节点都要保存原始数据,所以一个节点保存的记录时很少,导致保存的子节点引用也就很少</span><br><span class="line">5.BTree的层数要比B+Tree多得多</span><br></pre></td></tr></table></figure><p>8.有数据表和索引表之分吗？</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这要看索引表具体指的是哪种类型的索引。</span><br><span class="line"></span><br><span class="line">- 聚簇索引：那就没有额外的数据表，数据本身就是按照 B+Tree 的形式组成了聚簇索引——以主键作为索引值。</span><br><span class="line">- 非聚簇索引：非聚簇索引相对于聚簇索引来说可以称之为是另外一张表。</span><br></pre></td></tr></table></figure></blockquote><h4 id="B-Tree-和-BTree图示"><a href="#B-Tree-和-BTree图示" class="headerlink" title="B+Tree 和 BTree图示"></a>B+Tree 和 BTree图示</h4><blockquote><p>BTree</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209271659829.png" alt="image-20220927165932732"></p><p>B+Tree</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209271700082.png" alt="image-20220927170016004"></p></blockquote><h3 id="非主键字段创建索引"><a href="#非主键字段创建索引" class="headerlink" title="非主键字段创建索引"></a>非主键字段创建索引</h3><blockquote><p>1.不同数据类型的搜索方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#数值类型:用这个数值字段本身值作为索引</span><br><span class="line">select emp_id,emp_name,emp_age from t_emp where emp_age=20;</span><br><span class="line">#字符串类型:用这个字符串字段本身值作为索引</span><br><span class="line">select emp_id,emp_name,emp_age from t_emp where emp_name=&#x27;tom&#x27;;</span><br><span class="line">#较长的字符串类型:用字符串开头一部分值作为索引</span><br><span class="line">select emp_id,emp_name,emp_age from t_emp where emp_decs like &quot;I come from UK%&quot;;</span><br></pre></td></tr></table></figure><p>2.单列索引</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个索引只包含单列字段,一个表可以有多个单列索引</span><br><span class="line"></span><br><span class="line">存储结构</span><br><span class="line">当前节点页码值+一条记录(索引值[索引字段对应的值],字段所在的主键)</span><br></pre></td></tr></table></figure><p>3.多列索引(组合索引)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">顾名思义,多个字段值组成的索引,叫多列索引.</span><br></pre></td></tr></table></figure><p>4.回表</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们以非聚簇索引只能查找到记录对应的主键值,所以我们任要回到聚簇索引中再查一遍,这个过程叫做回表操作,也就是我们根据非聚簇索引列的值查询一条完整的用户原始数据记录需要用到两颗B+树</span><br><span class="line"></span><br><span class="line">为什么要进行回表操作,直接把原始数据放到非聚簇索引的叶子节点不行吗?</span><br><span class="line">1.直接放是可以,但是太占用地方了,那每颗B+树都要把用户原始数据拷一边,太占用空间了</span><br><span class="line">2.会导致数据不一致,在保存两条数据的情况下,我们执行uodate操作,不能只改一个,两个都要改,浪费性能.</span><br></pre></td></tr></table></figure></blockquote><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mysql索引包括普通索引,唯一索引,全文索引,多列和单列索引以及空间索引</span><br><span class="line"></span><br><span class="line">- &quot;功能逻辑&quot; 普通索引、唯一索引、主键索引和全文索引。</span><br><span class="line">- &quot;物理实现&quot; 聚簇索引,非聚簇索引</span><br><span class="line">- &quot;字段个数&quot; 单列和多列索引</span><br></pre></td></tr></table></figure><p>1.普通索引</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任何数据类型都可以创建普通索引,普通索引允许出现相同的索引内容,允许Null值</span><br></pre></td></tr></table></figure><p>2.唯一索引</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这个字段中的内容唯一,我们可以根据这个字段创建唯一索引,不可以出现相同的数据内容,但可以为Null值</span><br></pre></td></tr></table></figure><p>3.主键索引</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实就是特殊的唯一索引,增加一个不能为Null的限制</span><br></pre></td></tr></table></figure><p>4.单列索引</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在单个字段上面创建的索引,可以是普通索引,唯一索引,主键索引,也可以是全文索引,一个表可以有多个单列索引</span><br></pre></td></tr></table></figure><p>5.多列索引</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多个字段创建组合索引,在实际查询中只会最左字段的索引</span><br></pre></td></tr></table></figure><p>6.全文索引</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">目前是搜索引擎使用的关键技术,利用了分词技术,按照一定算法智能筛选出我们想要的结果,允许列中存在重复值和Null值,全文索引只能创建在char,varchar,text类型和其系列类型上,查询数据量很大的字符串类型的字段的时候,使用全文索引可以加快查询速度,全文索引技术也叫倒排索引技术.</span><br><span class="line"></span><br><span class="line">- 自然语言的全文索引</span><br><span class="line">计算数据查询的相关度,相关度是基于关键词的个数和关键词在文档中出现的次数,在搜索记录中出现次数越少的词,匹配度就越高,反而一个词在50<span class="comment">%的搜索记录中都存在,那自然语言搜索不会搜索这类词语</span></span><br><span class="line">- 布尔全文索引</span><br><span class="line">可以自定义搜索的词语的相关性</span><br><span class="line"></span><br><span class="line">随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被 solr、elasticSearch等专门的搜索引擎所替代。</span><br></pre></td></tr></table></figure><p>7.空间索引</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空间索引建立在空间数据类型上,可以提高系统获取空间数据的效率,Mysql中空间数据类型包括geometry[几何]、point[坐标点]、linestring[线]和polygon[多边形]等,目前只有MyISAM支持空间索引,索引的字段不能Null.</span><br></pre></td></tr></table></figure></blockquote><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在实际的开发过程中,我们需要尽量准确的将查询消耗时间比较久的SQL语句找到,然后再针对性的对其建立索引,再使用explain命令查看这个sql语句的执行详情,查看有没有用到索引,有没有做全表扫描等,对由此分析出的结果,我们进行优化.</span><br></pre></td></tr></table></figure><p>1.日志开启,设置阈值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#默认情况下slow_query_log的值为OFF</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#开启慢日志</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#慢查询日志阈值[超过这个时间的<span class="keyword">sql</span>将被记录在日志中]</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time<span class="operator">=</span><span class="number">0.1</span>; </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果希望修改后永久生效，那就修改my.cnf文件，[mysqld]下增加或修改参数slow_query_log 和slow_query_log_file后，然后重启MySQL服务器。也即将如下四行配置进my.cnf文件</span></span><br><span class="line"></span><br><span class="line">slow_query_log=1</span><br><span class="line">slow_query_log_file=/var/lib/mysql/atguigu-slow.log </span><br><span class="line">long_query_time=3</span><br><span class="line">log_output=FILE</span><br></pre></td></tr></table></figure><p>2.查看慢查询记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查看系统中有多少条慢查询记录</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>; </span><br><span class="line"></span><br><span class="line">#查看日志信息内容</span><br><span class="line">#去我们日志存放路径下,用cat命令查看其内容</span><br></pre></td></tr></table></figure><p>3.使用mysqldumpslow命令导出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g <span class="string">&quot;left join&quot;</span> /var/lib/mysql/atguigu-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-a: 不将数字抽象成N，字符串抽象成S</span><br><span class="line"></span><br><span class="line">-s: 是表示按照何种方式排序；</span><br><span class="line"></span><br><span class="line">c: 访问次数</span><br><span class="line"></span><br><span class="line">l: 锁定时间</span><br><span class="line"></span><br><span class="line">r: 返回记录</span><br><span class="line"></span><br><span class="line">t: 查询时间</span><br><span class="line"></span><br><span class="line">al:平均锁定时间</span><br><span class="line"></span><br><span class="line">ar:平均返回记录数</span><br><span class="line"></span><br><span class="line">at:平均查询时间</span><br><span class="line"></span><br><span class="line">-t: 即为返回前面多少条的数据；</span><br><span class="line"></span><br><span class="line">-g: 后边搭配一个正则匹配模式，大小写不敏感的；</span><br></pre></td></tr></table></figure></blockquote><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><h4 id="最左原则"><a href="#最左原则" class="headerlink" title="最左原则"></a>最左原则</h4><blockquote><p>1.创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_deptid_name <span class="keyword">ON</span> emp(age, deptid, NAME);</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-查询 age</span><br><span class="line">索引生效</span><br><span class="line">-查询 age 和 deptId</span><br><span class="line">索引生效</span><br><span class="line">-查询 age、deptId 和 name</span><br><span class="line">索引生效</span><br><span class="line">-查询 deptId、name 和 age</span><br><span class="line">索引生效,但原本遵循最左原则是不生效的,但SQL的优化器调整了解析树,使得查询字段符合了索引的顺序,使得索引生效</span><br><span class="line">-仅查询 deptId</span><br><span class="line">索引失效,违背最左原则</span><br></pre></td></tr></table></figure><p>2.为什么MySQL 会如此执着于『最左』字段？</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.因为在B+Tree创建的时候,需要对索引值进行排序,如果我们指定的是联合索引,那就要涉及到多个字段的排序,排序的时候肯定是优先根据最左字段进行排序,当最左字段值有相同数据时再对后一个字段进行排序,以此类推.</span><br><span class="line">2.在实际的查询中如果查询条件没有提供最左字段,那么联合索引将不会生效,因为我们首先要根据最左字段通过二分法进行查找.</span><br></pre></td></tr></table></figure><p>3.结论</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要遵循最左原则，查询字段中至少要有索引中的最左字段作为过滤条件存在。而且就最左原则本身来说，它要求索引最左字段在查询顺序中也最左。只不过只要最左字段出现，优化器会帮我们调整到查询顺序中的最左。而且还有一个要求是：中间不能断。中间一旦断开，后面的就都无法使用索引了。</span><br><span class="line">口诀：带头大哥不能死，中间兄弟不能断</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209292029060.png" alt="image-20220929202931979"></p></blockquote><h4 id="索引失效的其他情况"><a href="#索引失效的其他情况" class="headerlink" title="索引失效的其他情况"></a>索引失效的其他情况</h4><blockquote><p>1.范围查询</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 注意点1：创建索引时应该把容易做范围查询的字段往后放</span><br><span class="line">- 注意点2：实际编写 SQL 语句时，做范围查询的字段参照索引中的顺序，也是往后放</span><br></pre></td></tr></table></figure><p>2.where中使用函数</p><p>3.不等于</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">所有不等于操作都会导致索引失效：</span><br><span class="line"></span><br><span class="line">- !=</span><br><span class="line">- &lt;&gt;</span><br><span class="line">- not</span><br></pre></td></tr></table></figure><p>4.like</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">like 条件把 <span class="comment">% 放左边不生效,其他都生效</span></span><br></pre></td></tr></table></figure><p>5.类型转换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#我们给查询条件传入的参数和原本的类型不一致。但是这种情况不是必然会导致索引失效。</span><br><span class="line"><span class="keyword">where</span> name<span class="operator">=</span><span class="number">123</span>;</span><br></pre></td></tr></table></figure></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.对于单列索引,我们尽量来选择过滤性较好的字段来创建索引,比如手机号,一下能过滤掉很数据</span><br><span class="line">2.对于组合索引,我们尽量使过滤性较好的字段位置靠前,这样可以提前过滤掉很多数据</span><br><span class="line">3.对于组合索引出现了范围查询的时候,我们尽量将范围字段放到最后</span><br><span class="line">4.我们要尽量避免索引失效的情况</span><br><span class="line">5.创建索引字段的时候,我们尽量选择经常查询的字段,并字段值很少改动.因为字段值一改,索引也要跟着修改</span><br><span class="line">6.当一个特殊的查询场景包含多个字段的时候,创建组合索引比单列索引查询快.</span><br><span class="line">7.大部分情况下,一条SQL语句只能用到一个索引,所以索引并不是创建的越多越好.</span><br></pre></td></tr></table></figure></blockquote><h3 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">小表驱动大表</span><br><span class="line">- 小表：相对来说记录较少的表</span><br><span class="line">- 大表：相对来说记录较多的表</span><br><span class="line">驱动方式识别</span><br><span class="line">- left join：左边驱动右边（此时把小表放在左边）</span><br><span class="line">- right join：右边驱动左边（此时把小表放在右边）</span><br><span class="line">加索引的方式</span><br><span class="line">- 通常建议在大表（被驱动）的关联字段上加索引，效率提升更明显。</span><br></pre></td></tr></table></figure></blockquote><h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在实际开发中，能够不用子查询就尽量不用。</span><br></pre></td></tr></table></figure></blockquote><h3 id="排序分组优化"><a href="#排序分组优化" class="headerlink" title="排序分组优化"></a>排序分组优化</h3><blockquote><p>排序</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- order by 子句需要配合 limit 子句才能让索引生效。</span><br><span class="line">- 如果涉及多个字段的排序，那么这些字段排序的方向要一致（要升序都升序，要降序都降序），否则索引失效。</span><br></pre></td></tr></table></figure><p>分组</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能写在 where 限定的条件就不要写在 having 中,实现尽早过滤</span><br></pre></td></tr></table></figure></blockquote><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.视图是一张虚表,本身不具有数据</span><br><span class="line">2.视图表建立在已有的基表上</span><br><span class="line">3.视图创建和删除不会影响基表</span><br><span class="line">4.视图数据的更改,基表数据会响应更改,反之亦然.</span><br></pre></td></tr></table></figure></blockquote><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.帮助我们使用表的一部分</span><br><span class="line">2.提供给用户部分的数据</span><br><span class="line">3.保护敏感字段</span><br></pre></td></tr></table></figure></blockquote><h3 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h3><blockquote><p>创建视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW 视图名称</span><br><span class="line">AS 查询语句</span><br></pre></td></tr></table></figure><p>查看视图详情信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE VIEW 视图名称;</span><br></pre></td></tr></table></figure><p>删除视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称;</span><br></pre></td></tr></table></figure><p>更新,删除视图数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将 from 后的表名换成视图名 </span><br></pre></td></tr></table></figure></blockquote><p>总结</p><blockquote><p>优点</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 简化操作</span><br><span class="line">经常查询的操作,创建为一个视图,这样的话以后只用对视图进行操作即可,不用再去关心视图对应的基表的结构,表和表的关联关系,简化开发过程.</span><br><span class="line">2. 减少数据冗余</span><br><span class="line">视图本身不存储数据,只存储查询语句,用过查询语句获取结果集,不占用存储的资源,减少数据冗余.</span><br><span class="line">3. 保护数据安全</span><br><span class="line">用户对数据的访问限制在视图上,视图再通过查询语句获取基表的结果集,避免了用户直接访问基表,保障了数据的安全性.</span><br><span class="line">4. 适应多变的需求 </span><br><span class="line">业务需求发生变化,需要改动基表的结构,工作量比较大,可以使用视图减少改动量</span><br></pre></td></tr></table></figure><p>不足</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.如果基表的结构变了，我们就需要及相关的视图进行相应的维护.</span><br><span class="line">2.实际项目中，如果视图过多，会导致数据库维护成本的问题.</span><br></pre></td></tr></table></figure></blockquote><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209081057462.png" alt="image-20220908105738396"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主从复制,是用来建立一个和主数据库完全一样的数据库环境,称为从数据库</span><br></pre></td></tr></table></figure></blockquote><h3 id="为什么-1"><a href="#为什么-1" class="headerlink" title="为什么"></a>为什么</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209081057736.png" alt="image-20220908105752684"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.读写分离。</span><br><span class="line">2.数据备份。</span><br><span class="line">3.具有高可用性。</span><br><span class="line">4.提高数据库的吞吐量</span><br></pre></td></tr></table></figure></blockquote><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><blockquote><p>主机配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[必须]主服务器唯一ID</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[必须]启用二进制日志,指名路径。比如：自己本地的路径/log/mysqlbin</span></span><br><span class="line">log-bin=atguigu-bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选] 0（默认）表示读写（主机），1表示只读（从机）</span></span><br><span class="line">read-only=0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]设置日志文件保留的时长，单位是秒</span></span><br><span class="line">binlog_expire_logs_seconds=6000</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]控制单个二进制日志大小。此参数的最大和默认值是1GB</span></span><br><span class="line">max_binlog_size=200M</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]设置不要复制的数据库</span></span><br><span class="line">binlog-ignore-db=test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]设置需要复制的数据库,默认全部记录。比如：binlog-do-db=atguigu_master_slave</span></span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]设置binlog格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure><p>从机配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[必须]从服务器唯一ID</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure><p>重启Mysql服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意：主从机都关闭防火墙,或开放端口号</span><br><span class="line">systemctl stop firewalld.service #CentOS 7</span><br></pre></td></tr></table></figure><p>主机:建立账户并授权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在主机MySQL里执行授权主从复制的命令</span></span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;slave1&#x27;@&#x27;从机器数据库IP&#x27; IDENTIFIED BY &#x27;abc123&#x27;;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5.5,5.7</span></span><br></pre></td></tr></table></figure><p>主机查看同步状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><p>从机:配置需要复制的主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端执行命令</span></span><br><span class="line">CHANGE MASTER TO</span><br><span class="line">MASTER_HOST=&#x27;主机的IP地址&#x27;,</span><br><span class="line">MASTER_USER=&#x27;主机用户名&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;主机用户名的密码&#x27;,</span><br><span class="line">MASTER_LOG_FILE=&#x27;mysql-bin.具体数字&#x27;,</span><br><span class="line">MASTER_LOG_POS=具体值;</span><br></pre></td></tr></table></figure><p>从机启动slave同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端执行命令</span></span><br><span class="line">START SLAVE;</span><br></pre></td></tr></table></figure><p>从机查看同步状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端执行命令</span></span><br><span class="line">SHOW SLAVE STATUS\G;</span><br></pre></td></tr></table></figure></blockquote><h2 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h2><h3 id="垂直拆分-分库"><a href="#垂直拆分-分库" class="headerlink" title="垂直拆分-分库"></a>垂直拆分-分库</h3><h4 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h4><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.将数据库中的表按照业务逻辑拆分到不同的数据库中.</span><br><span class="line">2.垂直拆分:对表做分类</span><br></pre></td></tr></table></figure></blockquote><h4 id="为什么-2"><a href="#为什么-2" class="headerlink" title="为什么"></a>为什么</h4><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.不同业务逻辑的表在相同的数据库中,会加大数据库的压力.</span><br><span class="line">2.垂直拆分数据表,降数据库的压力.</span><br></pre></td></tr></table></figure></blockquote><h3 id="水平拆分-分表"><a href="#水平拆分-分表" class="headerlink" title="水平拆分-分表"></a>水平拆分-分表</h3><h4 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h4><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.按照字段,将一个表拆分为多个表</span><br><span class="line">2.水平拆分:按照字段将表分散到各个库中</span><br></pre></td></tr></table></figure></blockquote><h4 id="为什么-3"><a href="#为什么-3" class="headerlink" title="为什么"></a>为什么</h4><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.当一张表的数据达到千万时,查询一次花费的时间会很久,分表可以缩短查询时间.</span><br><span class="line">2.Mysql具有锁机制,当对表或者行进行操作时,其他用户就不能操作表或行,分表可以加大可操作性</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seata</title>
      <link href="/archives/8d9a091c.html"/>
      <url>/archives/8d9a091c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h2><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多条SQL语句对数据库进行操作,要么都成功,要么都失败,事务提供了一种机制(&quot;全套&quot;),这个机制将所有涉及到活动的操作纳入到一个不可分割的单元,任何一个操作失败都会导致所有的操作进行回滚.</span><br></pre></td></tr></table></figure></blockquote><h2 id="数据库本地事务"><a href="#数据库本地事务" class="headerlink" title="数据库本地事务"></a>数据库本地事务</h2><h3 id="四大特性-ACID"><a href="#四大特性-ACID" class="headerlink" title="四大特性(ACID)"></a>四大特性(ACID)</h3><blockquote><p>原子性</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事务开始之后的所有操作,要么全部完成,要么全部不做,所有操作中的某一个操作失败,都会导致所有的操作回滚到事务开始前的状态,事务是一个不可分割的单元,类似于化学中的原子</span><br></pre></td></tr></table></figure><p>一致性</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事务开始前和事务结束后,数据库的数据的完整性必须保证一致,例如A向B转账,不能A扣了前B却没收到钱</span><br></pre></td></tr></table></figure><p>隔离性</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个事务之间都是独立个体的存在,它干它的,我干我的,同一个时间内,只允许一个事务对同一个数据进行操作,当一个事务对同一个数据进行操作的时候,要把这个数据隔离起来,别的事务不能对其数据进行操作</span><br></pre></td></tr></table></figure><p>持久性</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事务结束后,事务对数据库所有的更新将会被保存到数据库中,不能回滚,对数据库的改变是永久性的</span><br></pre></td></tr></table></figure></blockquote><h3 id="事务并发出现的问题"><a href="#事务并发出现的问题" class="headerlink" title="事务并发出现的问题"></a>事务并发出现的问题</h3><blockquote><p>脏读</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事务A读取到事务B还未提交的数据,当事务B对数据库进行操作的过程中,还没有提交事务的时候,事务A来读取未提交的数据,会出现脏读的数据,这个数据不一定是最终数据.</span><br></pre></td></tr></table></figure><p>不可重复读</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个事务中两次读取了某一个数据,每次读取的结果不同.当A事务第一次读取某一个数据后,B事务将此数据更新并提交了,导致A事务第二次读取时数据前后不一致.导致A事务发生疑惑,我也没修改数据啊,怎么就突然变了.重复读取数据会不一致,我还是不重复读了吧.</span><br></pre></td></tr></table></figure><p>幻读</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个事务中两次读取的记录数不一致,在A事务第一个读取表记录数后,B事务添加或删除了一条数据,导致A事务第二次读取表记录数时,数据和第一次不同,导致A事务以为自己出现了幻觉,突然多了,突然少了.</span><br></pre></td></tr></table></figure><p>小贴士💖</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.不可重复读侧重于修改，解决不可重复读只需锁住满足条件的行</span><br><span class="line">2.幻读侧重于新增或删除。解决幻读需要锁表.</span><br></pre></td></tr></table></figure></blockquote><h3 id="四大隔离级别"><a href="#四大隔离级别" class="headerlink" title="四大隔离级别"></a>四大隔离级别</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209221635254.png" alt="image-20220922163525190"></p><p>小贴士💘</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.读未提交</span><br><span class="line">可以说性能是最好的了,压根不加锁,其实谈不上隔离,什么都没隔离.</span><br><span class="line">2.串行化</span><br><span class="line">事务的操作中会加锁,对读的操作加共享锁,别的线程也能来读,可以实现并发读,对写的操作加排它锁,我在写的时候,别的事务不能读也不能写,都等着去.</span><br><span class="line"></span><br><span class="line">Mysql默认事务隔离级别为可重复读</span><br></pre></td></tr></table></figure></blockquote><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跨库的事务,可以称为分布式事务,分布式事务可以理解为一个包含多个本地事务分支的全局事务,所有的本地事务要么一起成功提交,要么一起回滚失败.</span><br></pre></td></tr></table></figure></blockquote><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><blockquote><p>C(一致性)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两台机器之间的数据是实时一致的,每台机器可以看作一个节点,从任一个节点上读取的数据都是最新的数据</span><br></pre></td></tr></table></figure><p>A(可用性)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两台机器之间的数据不是实时一致的,从任一个节点上读取的数据可能是旧数据</span><br></pre></td></tr></table></figure><p>P(分区容错性)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某一台机器因为某些问题宕机,有其他的机器提供相同的服务</span><br></pre></td></tr></table></figure></blockquote><h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><blockquote><p>BA</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Basic Available 基本可用</span><br><span class="line">1.在一定的时间内任然能够返回一个明确的结果</span><br></pre></td></tr></table></figure><p>S</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Soft State 柔性状态</span><br><span class="line">1.同一数据的不同副本的状态，可以不需要实时一致</span><br></pre></td></tr></table></figure><p>E</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eventual Consisstency 最终一致性</span><br><span class="line">1.同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。</span><br></pre></td></tr></table></figure></blockquote><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.强一致性</span><br><span class="line">某个节点更新过的数据,能保证此数据在后续节点的访问都能访问到最新的数据</span><br><span class="line">2.弱一致性</span><br><span class="line">某个节点更新过的数据,可能一段时间能访问,也可能一直访问不到最新消息</span><br><span class="line">3.最终一致性[弱一直性的分支]</span><br><span class="line">某个节点更新过的数据,能保证在某个时间端内一定被访问到</span><br></pre></td></tr></table></figure></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="2PC-两端-XA事务模式"><a href="#2PC-两端-XA事务模式" class="headerlink" title="2PC(两端)(XA事务模式)"></a>2PC(两端)(XA事务模式)</h4><blockquote><p>成功情况</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209230844863.png" alt="image-20220923084403788"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;1.准备阶段</span><br><span class="line">&gt;事务管理器向资源管理器发送准备请求,资源管理器开始执行事务操作,事务操作执行完成后返回给事务管理器已完成</span><br><span class="line">&gt;2.提交执行阶段</span><br><span class="line">&gt;事务管理器收到资源管理器的回复的成功消息后向资源管理器发送提交请求,资源管理器收到提交请求后就开始执行事务的提交</span><br></pre></td></tr></table></figure><p>失败情况</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209230844879.png" alt="image-20220923084417823"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;1.准备阶段</span><br><span class="line">&gt;事务管理器向资源管理器发送准备请求,资源管理器开始执行事务操作,事务操作执行过程中出现错误导致执行失败,返回失败消息给事务管理器</span><br><span class="line">&gt;2.提交执行阶段</span><br><span class="line">&gt;如果事务管理器收到任何一个资源管理器执行失败的消息,则向每个资源管理器发送回滚的消息,每个资源管理器收到回滚消息后,根据指令回滚本地事务,释放所有锁的资源</span><br><span class="line">&gt;如果事务管理器收到了任何一个资源管理器失败的消息，则向每个资源管理器发送回滚消息。资源管理器根据事务管理器的指令回滚本地事务操作，释放所有事务处理过程中使用的锁资源。</span><br></pre></td></tr></table></figure><p>小结</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;1.阻塞问题</span><br><span class="line">&gt;一旦一个资源管理器一直失败,则会导致其他资源管理器一直无法提交完成自己的事务</span><br><span class="line">&gt;2.单点故障问题</span><br><span class="line">&gt;一旦一个事务管理器挂掉了,则会导致整个系统不可用</span><br><span class="line">&gt;3.一致性问题</span><br><span class="line">&gt;当事务管理器发送提交消息后,有的资源管理器可能提交失败,所以会导致整个事务不一致,每个节点是数据不一致</span><br></pre></td></tr></table></figure></blockquote><h4 id="3PC-三端"><a href="#3PC-三端" class="headerlink" title="3PC(三端)"></a>3PC(三端)</h4><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3PC比2PC多了一个询问的阶段,在准备阶段之前多了一个询问阶段,先询问资源管理器能不能执行事务的操作</span><br></pre></td></tr></table></figure><p>小结</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.3PC引入了超时机制,在准备阶段超时的资源管理器,则任务失败,在提交阶段超时的资源管理器,则其他资源管理器不会等待</span><br><span class="line">2.解决了阻塞和单点故障问题</span><br></pre></td></tr></table></figure></blockquote><h4 id="本地消息表-MQ"><a href="#本地消息表-MQ" class="headerlink" title="本地消息表+MQ"></a>本地消息表+MQ</h4><blockquote><p>暂略</p></blockquote><h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2007的老古董,分为三个阶段,尝试,确定,取消,市面上基本没人用</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. try 尝试阶段 尝试锁定资源</span><br><span class="line">2. confirm 确认阶段 尝试将锁定的资源进行提交</span><br><span class="line">3. cancel 取消阶段 其中某个环节执行失败，将发起事务取消动作</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCC适合严格一致性的业务活动,TCC有三个阶段,对应的三个动作,每个动作都要保证幂等性,例如转账业务,三个阶段对应的是冻结,扣钱,解冻</span><br></pre></td></tr></table></figure><p>幂等性</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多次对数据库的操作,结果都是一直的.</span><br><span class="line">例如:</span><br><span class="line">用户进行支付,因为网络问题,用户多点击了一次支付,系统不会因为用户多点击一次,不会多扣款</span><br></pre></td></tr></table></figure></blockquote><h4 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h4><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Saga的历史比TCC还悠远,可以追述到1987年,核心思想是将长事务拆分为多个短事务,</span><br></pre></td></tr></table></figure></blockquote><h4 id="最大努力补偿"><a href="#最大努力补偿" class="headerlink" title="最大努力补偿"></a>最大努力补偿</h4><blockquote><p>暂略</p></blockquote><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是一款阿里巴巴开源的分布式事务的解决方案,提供了多种事务模式,(AT、TCC、SAGA 和 XA 等)</span><br></pre></td></tr></table></figure></blockquote><h3 id="三个组件"><a href="#三个组件" class="headerlink" title="三个组件"></a>三个组件</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.Transaction Coordinator (TC)</span><br><span class="line">事务的协调者,维护全局事务和分支事务的运行状态,负责驱动全局事务的提交和回滚</span><br><span class="line">2.Transaction Manager (TM)</span><br><span class="line">事务管理器,复制开启全局事务,提交和回滚事务</span><br><span class="line">3.Resource Manager (RM)</span><br><span class="line">资源管理器,负责本地分支事务的注册,接收事务协调者指令,驱动本地分支事务的提交和回滚</span><br></pre></td></tr></table></figure></blockquote><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.事务管理器向事务协调者申请开启一个全局事务,事务管理器会创建一个全局事务并生成一个全局唯一的XID</span><br><span class="line">2.XID在各个微服务之间调用传递</span><br><span class="line">3.资源管理器向事务协调者注册本地分支事务,并将分支事务纳入到XID对应的全局事务的管辖中</span><br><span class="line">4.事务管理器向事务协调者发起针对XID所绑定的全局事务的全局提交和回滚决议</span><br><span class="line">5.事务协调者调度XID所管辖的全部分支事务使它们完成提交和回滚的请求</span><br></pre></td></tr></table></figure></blockquote><h3 id="两个阶段"><a href="#两个阶段" class="headerlink" title="两个阶段"></a>两个阶段</h3><blockquote><h4 id="一阶段"><a href="#一阶段" class="headerlink" title="一阶段"></a>一阶段</h4><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209230955148.png" alt="image-20220923095551033"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.解析SQL语句,生成一条SQL,先查询当前数据库镜像,保存原镜像</span><br><span class="line">2.执行解析后的SQL语句,查询新的数据库镜像,保存新镜像</span><br><span class="line">3.将两个镜像组成回滚日志,将业务数据的更新和回滚日志放在同一个事务中进行提交,放别插入到不同的表中</span><br><span class="line">4.将提交事务的结果上报给事务协调者</span><br></pre></td></tr></table></figure><h4 id="二阶段-做提交和回滚"><a href="#二阶段-做提交和回滚" class="headerlink" title="二阶段(做提交和回滚)"></a>二阶段(做提交和回滚)</h4><p>全局提交</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209231010446.png" alt="image-20220923101020299"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.各分支事务提交提交完成,之后事务协调者会向分支发送第二阶段请求,分支收到请求会把该请求放在异步队列中</span><br><span class="line">2.异步队列会根据分支的ID查找并删除回滚日志</span><br></pre></td></tr></table></figure><p>全局回滚</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209231010021.png" alt="image-20220923101029847"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.全局回滚会进行查找回滚日志,并解析回滚日志,执行回滚反向更新,完成分支的回滚</span><br></pre></td></tr></table></figure></blockquote><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.添加seata依赖</span><br><span class="line">2.添加配置文件</span><br><span class="line">3.注入数据源</span><br><span class="line">4.每个微服务中添加yml配置 </span><br><span class="line">5.使用@GlobalTransactional开启事务</span><br></pre></td></tr></table></figure></blockquote><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>MySQL的事务</p><p>简述在MySQL数据库中MyISAM和InnoDB的区别</p><p>请描述一下Spring 的事务管理</p><p>Redis有事务吗?</p><p>如何使用RabbitMQ解决分布式事务？</p><p>讲讲spring事务</p><p>你们是怎么使用spring事务的</p><p>spring事务失效情况</p><p>spring事务原理</p><p>@Transactional注解加在什么地方都可以吗</p><p>MQ解决分布式事务问题的</p><p>数据库事务？什么是事务？什么时候用？怎么用？为什么用它</p><p>分布式事务有几种实现方式</p><p>spring事务传播机制</p><p>mysql的事务级别</p><p>事务：隔离级别，传播行为</p><p>redis的事务说明一下</p><p>Redis集群下的分布式事务</p><p>事务管理@Transactinal里的参数</p><p>JDBC的连接Collercion 怎么创建事务</p><p>事务实现的原理是什么</p><p>Transactional 传播行为是nested的子事务放在主事务不同位置对主事务的回滚来说，有没有不同</p><p>mysql事务的acid分别由哪些重要操作保证，mvcc和lbcc的机制</p><p>redis事务和spring事务在一起时,如何处理</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Seata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/archives/aa55683f.html"/>
      <url>/archives/aa55683f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="程序-进程-线程"><a href="#程序-进程-线程" class="headerlink" title="程序 进程 线程"></a>程序 进程 线程</h3><blockquote><p>程序 </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.静态的概念</span><br><span class="line">2.源程序,应用程序,都可笼统的称为程序</span><br></pre></td></tr></table></figure><p>进程 </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.动态的概念</span><br><span class="line">2.程序运行起就是一个进程</span><br><span class="line">3.QQ,WChat,都是一个个进程</span><br></pre></td></tr></table></figure><p>线程</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.一个进程中有多个任务,每单独的一个任务需要一个线程来处理</span><br><span class="line">2.笼统的可以称为进程是线程的容器</span><br></pre></td></tr></table></figure></blockquote><h3 id="串行-并行-并发"><a href="#串行-并行-并发" class="headerlink" title="串行 并行 并发"></a>串行 并行 并发</h3><blockquote><p>串行</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个线程执行多个操作,多个操作要排队等待执行</span><br></pre></td></tr></table></figure><p>并行 </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多个CPU核同时执行多个任务,核数和任务数一一对应</span><br></pre></td></tr></table></figure><p>并发<br> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单个CPU核同时执行多个任务</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="sleep-和wait-区别"><a href="#sleep-和wait-区别" class="headerlink" title="sleep()和wait()区别"></a>sleep()和wait()区别</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.sleep()会让线程拿着锁去睡</span><br><span class="line">2.wait()会让线程放开锁去睡</span><br></pre></td></tr></table></figure></blockquote><h2 id="多线程创建"><a href="#多线程创建" class="headerlink" title="多线程创建"></a>多线程创建</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><blockquote><p>步骤</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.继承 Thread 类</span><br><span class="line">2.重写 run() 方法</span><br><span class="line">3.创建 Thread 子类对象</span><br><span class="line">4.调用 start() 方法启动线程</span><br></pre></td></tr></table></figure><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoThread</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoThread</span>(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">        demo.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoThread</span><span class="params">(String threadName)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(threadName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; thread working ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><blockquote><p> 实现 Runnable 接口形式</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><p> 匿名内部类形式</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><p> Lambda 表达式形式</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure></blockquote><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><blockquote><p>步骤</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.使用Executors.newFixedThreadPool(线程池数量)创建ExecutorService对象</span><br><span class="line">2.使用ExecutorService对象的execute()分配任务,每个任务就是一个线程</span><br><span class="line">3.execute()方法参数实现Runnable接口,写具体的线程操作.</span><br></pre></td></tr></table></figure><p>参考代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建线程池对象</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.给线程池对象分配任务，每一个任务是一个线程</span></span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h3 id="FutureTask-Callable"><a href="#FutureTask-Callable" class="headerlink" title="FutureTask+Callable"></a>FutureTask+Callable</h3><blockquote><p>和Runnable区别</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209151508761.png" alt="image-20220915150859690"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.我们直接再new Thread()的第一个参数中实现Runnable接口,在接口中写线程执行的操作,这样我们拿不到线程执行后的结果,因为Runnable接口中的run方法是没有返回值的</span><br><span class="line">2.Callable接口中的call方法是可以指定返回值的</span><br></pre></td></tr></table></figure><p>FutureTask 类的构造器</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209151511941.png" alt="image-20220915151124892"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="built_in">this</span>.callable = callable;</span><br><span class="line">  <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据这个构造器，我们知道，创建 FutureTask 对象时，传入一个 Callable 类型的对象即可</span></span><br></pre></td></tr></table></figure><p>Callable 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从 call() 方法的声明我们可以看出，它有一个返回值。这个返回值可以将当前线程内计算结果返回</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建三个FutureTask对象，封装三个线程的执行逻辑</span></span><br><span class="line">FutureTask&lt;Integer&gt; task01 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * Math.random() * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line">FutureTask&lt;Integer&gt; task02 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * Math.random() * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line">FutureTask&lt;Integer&gt; task03 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * Math.random() * <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建三个线程对象，然后启动线程</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task01, <span class="string">&quot;thread01&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task02, <span class="string">&quot;thread02&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task03, <span class="string">&quot;thread03&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.上面三个线程执行完成后，可以收集它们各自运算的结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">task01Result</span> <span class="operator">=</span> task01.get();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">task02Result</span> <span class="operator">=</span> task02.get();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">task03Result</span> <span class="operator">=</span> task03.get();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;task01Result = &quot;</span> + task01Result);</span><br><span class="line">System.out.println(<span class="string">&quot;task02Result = &quot;</span> + task02Result);</span><br><span class="line">System.out.println(<span class="string">&quot;task03Result = &quot;</span> + task03Result);</span><br></pre></td></tr></table></figure></blockquote><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明成员变量维护票库存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line">    <span class="comment">// 变量类型：java.util.concurrent.locks.Lock 接口</span></span><br><span class="line">    <span class="comment">// 对象类型：Lock 接口的最常用的实现类 ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明卖票的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saleTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            lock.lock(); <span class="comment">// synchronized (this) &#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 卖票的核心操作</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖了一张，还剩 &quot;</span> + --stock + <span class="string">&quot; 张票。&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖完了。&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock(); <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建当前类对象</span></span><br><span class="line">        <span class="type">Demo01HelloWorld</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo01HelloWorld</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开启三个线程调用卖票方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                demo.saleTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-01&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                demo.saleTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-02&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                demo.saleTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-03&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.确保锁被释放</span><br><span class="line"></span><br><span class="line">使用 Lock API 实现同步操作，是一种面向对象的编码风格。这种风格有很大的灵活性，同时可以在常规操作的基础上附加更强大的功能。但是也要求编写代码更加谨慎：如果忘记调用 lock.unlock() 方法则锁不会被释放，从而造成程序运行出错。</span><br><span class="line"></span><br><span class="line">2.加锁和解锁操作对称执行</span><br><span class="line"></span><br><span class="line">不管同步操作是一层还是多层，有多少个加锁操作，就应该相应的有多少个解锁操作。</span><br><span class="line"></span><br><span class="line">3.避免锁对象的线程私有化</span><br><span class="line"></span><br><span class="line">锁对象如果是线程内部自己创建的，是自己独占的，其它线程访问不到这个对象，那么这个锁将无法实现『排他』效果，说白了就是：锁不住。</span><br></pre></td></tr></table></figure></blockquote><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>void lock()</td><td>加同步锁，如果没有得到锁会一直等</td></tr><tr><td>void unlock()</td><td>解除同步锁</td></tr><tr><td>boolean tryLock()</td><td>尝试获取锁。如果没有获取到则立即返回，不做任何等待<br>返回 true：表示获取成功  <br>返回 false：表示获取失败</td></tr><tr><td>boolean tryLock(long time, TimeUnit unit)</td><td>尝试获取锁，且等待指定时间<br>返回 true：表示获取成功  <br>返回 false：表示获取失败</td></tr><tr><td>void lockInterruptibly()</td><td>以『支持响应中断』的模式获取锁</td></tr><tr><td>Condition newCondition()</td><td>获取用于线程间通信的 Condition 对象</td></tr></tbody></table></blockquote><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全类名：java.util.concurrent.locks.ReentrantLock</span><br><span class="line"></span><br><span class="line">这是 Lock 接口最典型、最常用的一个实现类。</span><br></pre></td></tr></table></figure><p>基本用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.将解锁操作lock.unlock()放在finally&#123;&#125;中</span></span><br><span class="line"><span class="comment">//2.加锁和解锁的操作要对称,加速后一定要解锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步代码部分</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证可重入性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;外层加锁成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;内层加锁成功&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;内层解锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;外层解锁成功&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><blockquote><p>概念</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.在实际的开发场景中,线程的读操作不会改变数据的值,所以多个线程进行读操作是不会存在线程安全问题的</span><br><span class="line">2.但如果很多个线程同时在进行读操作,一个线程来进行写操作时,就不应该允许其他线程进行任何操作</span><br><span class="line"></span><br><span class="line">实现</span><br><span class="line">1.Java并发包java.util.concurrent下提供了读写锁ReentrantReadWriteLock</span><br><span class="line">2.它表示了两个锁,一个读锁(共享锁),一个写锁(独占锁,互斥锁,排它锁)</span><br></pre></td></tr></table></figure><p>重要特性</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.公平选择性</span><br><span class="line">支持公平和非公平锁,默认非公平锁,因为非公平锁的吞吐量高</span><br><span class="line">2.重进入</span><br><span class="line">两个锁都单方面的支持线程的可重入性</span><br><span class="line">一个线程中加读锁后还能继续加读锁</span><br><span class="line">一个线程中加写锁后还能继续加写锁</span><br><span class="line">3.锁降级</span><br><span class="line">一个线程中,读锁不能升级为写锁</span><br><span class="line">一个线程中,写锁可以降级为读锁</span><br><span class="line"></span><br><span class="line">提示</span><br><span class="line">1.一个线程占用了读锁,另外的一个线程如果想要申请写锁的话,要等读锁的这个线程将读锁释放才行,但另外一个线程想申请读锁的话时可以的.</span><br><span class="line">2.一个线程占用了写锁,另外的一个线程如果想要申请写锁或读锁都是不可以的,都要等待写锁释放</span><br></pre></td></tr></table></figure></blockquote><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><blockquote><p>入门</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockConditionWayDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建同步锁对象</span></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//创建条件对象(控制线程间通信)</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">//操作数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data + 1 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doIncr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为了避免虚假唤醒问题：使用 while 结构进行循环判断</span></span><br><span class="line">            <span class="comment">// 判断当前线程是否满足执行核心操作的条件</span></span><br><span class="line">            <span class="keyword">while</span> (data == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 满足条件时，不该当前线程干活，所以进入等待状态</span></span><br><span class="line">                condition.await();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不满足上面的条件时，说明该当前线程干活了，所以执行核心操作</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行 + 1 操作，data = &quot;</span> + ++data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自己的任务完成后，叫醒其它线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data - 1 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doDecr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为了避免虚假唤醒问题：使用 while 结构进行循环判断</span></span><br><span class="line">            <span class="comment">// 判断当前线程是否满足执行核心操作的条件</span></span><br><span class="line">            <span class="keyword">while</span> (data == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 满足条件时，不该当前线程干活，所以进入等待状态</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不满足上面的条件时，说明该当前线程干活了，所以执行核心操作</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行 - 1 操作，data = &quot;</span> + --data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自己的任务完成后，叫醒其它线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建当前类的对象</span></span><br><span class="line">        <span class="type">LockConditionWayDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockConditionWayDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建四个线程，两个 + 1，两个 - 1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.doIncr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-add A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.doDecr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-sub A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.doIncr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-add B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.doDecr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-sub B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义线程间通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockConditionWayDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建同步锁对象</span></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//创建条件对象(控制线程间通信)</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (data % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                conditionA.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;A&quot;</span>);</span><br><span class="line">            data++;</span><br><span class="line">            conditionB.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (data % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                conditionB.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;B&quot;</span>);</span><br><span class="line">            data++;</span><br><span class="line">            conditionA.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建当前类的对象</span></span><br><span class="line">        <span class="type">LockConditionWayDemo1</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockConditionWayDemo1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                demo.toA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                demo.toB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Lock-与-synchronized-对比"><a href="#Lock-与-synchronized-对比" class="headerlink" title="Lock 与 synchronized 对比"></a>Lock 与 synchronized 对比</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在实际开发时，如果synchronized能够满足需要，那就使用synchronized，毕竟它自动加锁、解锁，代码简单。</span><br><span class="line">如果synchronized无法满足需求，只能使用Lock。</span><br></pre></td></tr></table></figure><p>相同点</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.都支持独占锁</span><br><span class="line">2.都支持可重入</span><br></pre></td></tr></table></figure><p>不同点</p><table><thead><tr><th></th><th>Lock 系列 API 用法</th><th>synchronized 用法</th></tr></thead><tbody><tr><td>加锁/解锁</td><td>手动</td><td>自动</td></tr><tr><td>支持共享锁</td><td>√</td><td>×</td></tr><tr><td>支持尝试获取锁失败  <br>后执行特定操作</td><td>√</td><td>×</td></tr><tr><td>灵活</td><td>√</td><td>×</td></tr><tr><td>便捷</td><td>×</td><td>√</td></tr><tr><td>响应中断</td><td>lockInterruptibly()  <br>方式支持阻塞状态响应中断</td><td>sleep()  <br>睡眠后支持响应中断</td></tr><tr><td>代码风格</td><td>面向对象</td><td>面向过程</td></tr><tr><td>底层机制</td><td>AQS（volatile + CAS + 线程的双向链表）= 非阻塞同步</td><td>阻塞同步</td></tr></tbody></table></blockquote><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><h3 id="锁膨胀机制"><a href="#锁膨胀机制" class="headerlink" title="锁膨胀机制"></a>锁膨胀机制</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在JDK1.6之前,synchronized锁的底层工作机制只有重量级锁,从1.6开始,为了减少重量级锁频繁的获得锁和释放锁带来的性能的消耗,所以引入了『偏向锁』和『轻量级锁』</span><br></pre></td></tr></table></figure><p>锁的状态</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.无锁</span><br><span class="line">锁所在的那个对象刚创建出来,还没有线程来执行同步代码块</span><br><span class="line">2.偏向锁</span><br><span class="line">只有唯一的一个线程来访问对象,没有必要获得锁和释放锁,例如世界就一个房子,没有必要锁门,我们只需要在这个对象头中的偏向锁的Mark Word结构中在thread上把这个线程的ID记录下来,等到这个线程下次再来,就无需获得锁,可以随意穿梭,省去大量关于锁的操作.</span><br><span class="line">3.轻量级锁</span><br><span class="line">当有第二个线程来申请锁,两个线程不存在竞争关系,一前一后交替执行同步块,</span><br><span class="line">4.重量级锁</span><br><span class="line">多个线程来竞争锁,各个线程之间存在竞争关系</span><br></pre></td></tr></table></figure></blockquote><h3 id="对象存储结构"><a href="#对象存储结构" class="headerlink" title="对象存储结构"></a>对象存储结构</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.对象头</span><br><span class="line">非数组对象</span><br><span class="line">    Mark Word</span><br><span class="line">    类型指针</span><br><span class="line">数组</span><br><span class="line">    Mark Word</span><br><span class="line">    类型指针</span><br><span class="line">    数组长度</span><br><span class="line">2.对象体</span><br><span class="line">3.对齐字节</span><br></pre></td></tr></table></figure><p>对象头</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.分类</span><br><span class="line">==&gt;非数组对象 MarkWord, 类型指针</span><br><span class="line">==&gt;数组      MarkWord, 类型指针, 数组长度</span><br><span class="line">2.MarkWord</span><br><span class="line">对象的运行时信息,对不中不同的锁状态有五种不同的结构</span><br><span class="line">3.类型指针</span><br><span class="line">指向这个对象对应方法区的类</span><br><span class="line">4.数组长度</span><br></pre></td></tr></table></figure><p>对象体</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象本身的数据</span><br></pre></td></tr></table></figure><p>对齐字节</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">填充数据,让这个对象的大小为8字节的整数倍</span><br></pre></td></tr></table></figure></blockquote><h3 id="MarkWord五种状态"><a href="#MarkWord五种状态" class="headerlink" title="MarkWord五种状态"></a>MarkWord五种状态</h3><blockquote><p>1.无锁</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162057391.png" alt="image-20220916205753316"></p><p>2.偏向锁</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162058607.png" alt="image-20220916205808541"></p><p>3.轻量级锁</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162058209.png" alt="image-20220916205819138"></p><p>4.重量级锁</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162058496.png" alt="image-20220916205828434"></p><p>5.GC</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162058173.png" alt="image-20220916205838107"></p></blockquote><h3 id="对象监视器"><a href="#对象监视器" class="headerlink" title="对象监视器"></a>对象监视器</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>;  <span class="comment">// 锁计数器</span></span><br><span class="line">    _waiters      = <span class="number">0</span>;</span><br><span class="line">    _recursions   = <span class="number">0</span>; <span class="comment">// 锁的重入次数</span></span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL; <span class="comment">// 指向持有 ObjectMonitor 对象的线程</span></span><br><span class="line">    _WaitSet      = NULL; <span class="comment">// 处于 wait 状态的线程，会被加入到 _WaitSet（等待队列）</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">// 处于等待锁 block 状态的线程，会被加入到该列表（阻塞队列）</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Lock底层原理"><a href="#Lock底层原理" class="headerlink" title="Lock底层原理"></a>Lock底层原理</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><p>概念</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.Java内存模型</span><br><span class="line">2.CPU和内存之间的一层高速缓存层,这个缓存层存在与CPU内</span><br><span class="line">3.CPU从高速缓存中读取数据,对数据修改后,再通过高速缓存区同步给内存</span><br></pre></td></tr></table></figure><p>Java内存模型</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.主内存</span><br><span class="line">各线程之间共享的数据区域</span><br><span class="line">2.本地内存</span><br><span class="line">每个线程自己私有的数据区域</span><br></pre></td></tr></table></figure><p>作用</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.为了解决缓存一致性的问题</span><br><span class="line">不同的线程会从主内存读取同一个数据,又做了不同的修改,那么各个线程从本地内存同步给主内存的时候,又以哪个线程的修改结果为准呢?这就是缓存一致性的问题</span><br></pre></td></tr></table></figure><p>缓存一致性涉及的三个具体问题</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.原子性</span><br><span class="line">2.可见性</span><br><span class="line">3.有序性</span><br></pre></td></tr></table></figure></blockquote><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote><p>概念</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.一个操作是不可分割的,拿我们就可以说这个操作是原子操作</span><br><span class="line">2.非原子性的操作会引发线程安全问题,比如i++,++i等,看似一步操作,实则底层有两步操作</span><br><span class="line">3.有例如再JMM内存结构中,两个线程同时读取主内存的数据,各自修改后push将修改的数据返回给主内存的时候,会出现数据覆盖现象,</span><br><span class="line"></span><br><span class="line">怎么解决</span><br><span class="line">1.使用同步锁</span><br><span class="line">2.使用Java的concurrent包下面的原子类</span><br></pre></td></tr></table></figure><p>使用同步锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将累加方法修改为同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; data = &quot;</span> + ++data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用原子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明成员变量作为操作对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 累加方法还是非同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; data = &quot;</span> + data.incrementAndGet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种解决方案的比较</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.当使用同步锁机制,先生产环境下,并发量的增加会导致锁的状态升级为重量级锁,重量级锁会涉及到锁的获取和释放,比较消耗性能</span><br><span class="line">2.原子类结合AQS和CAS使得减少消耗系统的性能</span><br></pre></td></tr></table></figure></blockquote><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><blockquote><p>概念</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.每个线程对自己本地内存的操作,其他线程是不可见的.</span><br><span class="line">2.使用volatile关键字修饰变量,可以使得一个线程对数据的修改是其他线程知道</span><br><span class="line">3.一个线程对本地内存数据的修改其他线程是否可见</span><br></pre></td></tr></table></figure></blockquote><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在CPU执行指令,JVM编译源程序之后,系统内部会进行指令重排.</span><br><span class="line">2.保证程序的运行结果一致的情况下,优化系统内部的效率</span><br></pre></td></tr></table></figure></blockquote><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><blockquote><p>概念</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.当一个线程对被volatile修饰的变量进行操作的时候,JMM会将该线程对应的本地内存的变量的值flush到主内存中</span><br><span class="line">2.当一个线程对被volatile修饰的变量的值进行读取操作时,JMM会将该线程的本地内存的变量只置为无效,然后再去读取主内存中的变量的值</span><br><span class="line">3.所以volatile关键字可以保证各个线程之间的变量值的操作时可见性的</span><br><span class="line">4.volatile关键字能保证有序性</span><br></pre></td></tr></table></figure></blockquote><h3 id="CAS机制"><a href="#CAS机制" class="headerlink" title="CAS机制"></a>CAS机制</h3><blockquote><p>概念</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.比较交换</span><br><span class="line">2.原子类中我们大量的用到了CAS</span><br></pre></td></tr></table></figure><p>具体过程</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.当一个线程对本地内存中的数据进行修改的过程中,会调用Atomic原子类中的方法,方法又会调用Unsafe类对象中的方法进行操作,再调用这个类方法的时候会将此变量在主内存中的地址值和旧值和新值传入</span><br><span class="line">4.在Unsafe对象在进行操作的时候,会使用到CAS机制,先去找到主内存中地址值所对应的变量的值,然后再去判断旧值是否和主内存中的值是否一直.如果一致则将本地内存的旧值改为新值,再执行store指令将新值同步给主内存,然后再执行write指令将新值写入主内存对应的地址值中.</span><br><span class="line">5.如果CAS机制比较后值不相同,则不能修改,随后开始自旋,重新尝试修改</span><br></pre></td></tr></table></figure><p>非阻塞同步</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.不用阻塞线程就能达到同步的效果</span><br><span class="line"></span><br><span class="line">为什么AtomicInteger方式对比synchronized方式性能优势非常明显?</span><br><span class="line">1.AtomicInteger搭配CAS机制不需要阻塞线程就能达到同步的效果</span><br><span class="line">2.synchronized因为需要加锁解锁操作所以会比较慢,需要阻塞线程实现同步效果</span><br></pre></td></tr></table></figure><p>ABA问题</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个不允许线程执行的操作,因为数据发生的变化,又可以进行操作了</span><br><span class="line"></span><br><span class="line">解决方法</span><br><span class="line">1.加版本号</span><br></pre></td></tr></table></figure><p>AtomicInteger类</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">整合了CAS机制和volatile,解决了缓存不一致问题</span><br><span class="line"></span><br><span class="line">满足JMM三大特性</span><br><span class="line">1.原子性: 俺原子类嘞</span><br><span class="line">2.可见性: 有volatile</span><br><span class="line">3.有序性: 有volatile</span><br></pre></td></tr></table></figure></blockquote><h3 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.ReentrantLock是Lock接口最常用的一个实现类,这个实现类内部又有多个内部类,这几个内部类是公平锁和非公平锁等,我们一般默认使用的是非公平锁NonfairSync,NonfairSync继承了Sync,Sync继承了AQS,NonfairSync重写了夫类的tryAcquire方法</span><br><span class="line">2.当一个线程进入lock方法时候,会先判断是否有其他线程占用,如果没有,则将当前线程设置为独占,state值+1</span><br><span class="line">3.当一个线程再次进入lock方法的时候,此时发现当前资源已被其他线程占用,则进入else执行acquire(1);</span><br><span class="line">4.acquire方法内部执行if(!tryAcquire(arg) <span class="built_in">&amp;</span><span class="built_in">&amp;</span> acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">5.tryAcquire方法是本类重写的方法,tryAcquire方法又调用了父类Sync的nonfairTryAcquire()方法</span><br><span class="line">6.nonfairTryAcquire()方法中先再次判断了资源是否被独占,如果没有被独占,则当前线程就独占它</span><br><span class="line">7.如果还是被独占,那就判断独占的线程是不是自己本身,如果是的话,可重入次数+1,也就是state值+1</span><br><span class="line">8.如果不是自己,那就返回false;回到acquire方法执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">9.addWaiter方法中将当前线程封装成一个节点对象,然后判断双向链表最后一个节点是否有值,如果有值,就把最后一个节点向前移一位,自己放在最后一个节点上</span><br><span class="line">10.解锁的时候调用ReentrantLock的unlock方法,中调用Sync的tryRelease方法,state减去相应的值,释放锁</span><br></pre></td></tr></table></figure></blockquote><h2 id="集合线程安全"><a href="#集合线程安全" class="headerlink" title="集合线程安全"></a>集合线程安全</h2><blockquote><p>List</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList</span><br><span class="line">1.使用写时复制技术,向集合中写入数据时,先把整个集合复制一份</span><br><span class="line">2.将新数据写入的复制的集合中</span><br><span class="line">3.再让旧集合变量指向新集合2</span><br><span class="line"></span><br><span class="line">优点：写操作还是要加独占锁(一个一个)，这方面没区别；读操作允许并发执行，效率提升。</span><br><span class="line">缺点：由于需要把集合对象整体复制一份，所以对内存的消耗很大</span><br></pre></td></tr></table></figure><p>Set</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArraySet</span><br><span class="line">//同理CopyOnWriteArrayList</span><br></pre></td></tr></table></figure><p>Map</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap</span><br><span class="line">加入锁分段技术</span><br><span class="line">1.将一个集合中的数据分段来加锁</span><br><span class="line">2.降低线程间的竞争概率</span><br><span class="line"></span><br><span class="line">假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</span><br></pre></td></tr></table></figure></blockquote><h2 id="工具类和Fork-Join框架"><a href="#工具类和Fork-Join框架" class="headerlink" title="工具类和Fork-Join框架"></a>工具类和Fork-Join框架</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定一个操作步骤数量，在各个子线程中，每完成一个任务就给步骤数量 - 1；在步骤数量减到0之前，CountDownLatch 可以帮我们把最后一步操作抑制住（阻塞），让最后一步操作一直等到步骤被减到 0 的时候执行。</span><br></pre></td></tr></table></figure><p>班长锁门(有六名同学在值日，班长负责锁门。班长必须确保所有同学都离开教室再锁门)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个变量，用来保存同学的数量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">stuNum</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建CountDownLatch对象</span></span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(stuNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建和同学数量相等的线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stuNum; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> String.valueOf(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成一次操作</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + num + <span class="string">&quot;号同学离开教室&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让countDownLatch管理的数量-1</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让countDownLatch负责将最后一步操作抑制住</span></span><br><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;班长锁门&quot;</span>);</span><br></pre></td></tr></table></figure><p>集齐七颗龙珠召唤神龙</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明龙珠数量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dragonBall</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建CountdownLatch对象</span></span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(dragonBall);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建七个线程收集龙珠</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;现在拿到了&quot;</span> + num + <span class="string">&quot;号龙珠&quot;</span>);</span><br><span class="line"></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让countDownLatch对象抑制最后一步</span></span><br><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;龙珠集齐，召唤神龙&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">支持多线程在执行各自任务的时候，到达某个状态点就等待，等所有线程都到达这个状态点再继续执行后步骤。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoO19CyclicBarrierTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; matrix = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        matrix.add(Arrays.asList(<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;special&quot;</span>,<span class="string">&quot;end&quot;</span>));</span><br><span class="line">        matrix.add(Arrays.asList(<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;special&quot;</span>,<span class="string">&quot;end&quot;</span>));</span><br><span class="line">        matrix.add(Arrays.asList(<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;special&quot;</span>,<span class="string">&quot;end&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建CyclicBarrier对象</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建3个线程分别执行各自的任务</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;String&gt; list = matrix.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String value : list) &#123;</span><br><span class="line"></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; value = &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;special&quot;</span>.equals(value)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遇到特殊任务标记，就让当前线程等一下</span></span><br><span class="line">                        barrier.await();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;thread01&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;String&gt; list = matrix.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String value : list) &#123;</span><br><span class="line"></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; value = &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;special&quot;</span>.equals(value)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遇到特殊任务标记，就让当前线程等一下</span></span><br><span class="line">                        barrier.await();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;thread02&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;String&gt; list = matrix.get(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String value : list) &#123;</span><br><span class="line"></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; value = &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;special&quot;</span>.equals(value)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遇到特殊任务标记，就让当前线程等一下</span></span><br><span class="line">                        barrier.await();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;thread03&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote><p>入门使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建 Semaphore 对象，指定资源数量为 3</span></span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建 10 个线程争夺这 3 个资源</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 申请资源</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拿到资源执行操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】号车辆【驶入】车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】号车辆【驶出】车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 操作完成释放资源</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, i + <span class="string">&quot;&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入超时机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、设定车位数量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">carPositionCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建 Semaphore 对象</span></span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(carPositionCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、创建 50 个线程抢车位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">carNum</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">acquireResult</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 线程开始时先申请资源，申请不到会进入等待状态</span></span><br><span class="line">            <span class="comment">// 申请资源方式一：不见不散，等不到资源就一直等</span></span><br><span class="line">            <span class="comment">// semaphore.acquire();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 申请资源方式二：过时不候</span></span><br><span class="line">            acquireResult = semaphore.tryAcquire(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (acquireResult) &#123;</span><br><span class="line">                <span class="comment">// 申请到资源时，线程会继续执行</span></span><br><span class="line">                System.out.println(carNum + <span class="string">&quot;号车辆驶入车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 车辆在车位停放一段时间</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 停放完成离开车位</span></span><br><span class="line">                System.out.println(carNum + <span class="string">&quot;号车辆驶出车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(carNum + <span class="string">&quot;号车辆放弃等待&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断当前线程释放拿到了资源</span></span><br><span class="line">            <span class="keyword">if</span> (acquireResult) &#123;</span><br><span class="line">                <span class="comment">// 任务执行完成释放资源</span></span><br><span class="line">                semaphore.release();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景举例</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">借助Semaphore实现『限流』操作。</span><br><span class="line"></span><br><span class="line">- 当前服务器实例能够承受多大的访问量——设置为资源的数量。</span><br><span class="line">- 根据资源的数量创建Semaphore对象。</span><br><span class="line">- 服务器实例接收到请求通过Semaphore对象管理处理请求数量。</span><br><span class="line">    - 在能力范围内：处理请求。</span><br><span class="line">    - 超过能力范围：设定等待时间，看是否能够得到别的请求处理完成释放资源。</span><br></pre></td></tr></table></figure></blockquote><h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork Join"></a>Fork Join</h3><blockquote><p>概念</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209211809076.png" alt="image-20220921180905006"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用 Fork Join 框架能够帮助我们把一个大型任务，根据一定规律，拆分成小任务执行。如果拆分后的任务还不够小，可以以递归模式继续拆分，直到拆分到可以执行的程度。然后再把各个子任务执行的结果汇总到一起。</span><br><span class="line"></span><br><span class="line">- Fork：拆分：把大任务拆分成小任务。</span><br><span class="line">- Join：合并：把小任务执行的结果合并到一起。</span><br></pre></td></tr></table></figure><p>框架中 API 介绍</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.RecursiveTask</span><br><span class="line">我们使用 Fork Join 框架只需要继承 RecursiveTask，然后重写 compute() 方法即可。在 compute() 方法中需要包含：</span><br><span class="line"></span><br><span class="line">- 任务拆分的逻辑</span><br><span class="line">- 任务拆分的操作：调用 fork() 方法</span><br><span class="line">- 已拆分任务的合并：调用 join() 方法</span><br><span class="line">- 子任务结果的合并：将 join() 方法的返回值合并起来</span><br><span class="line">2.ForkJoinTask</span><br><span class="line">ForkJoinTask 类是 RecursiveTask 的父类。</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.需求</span><br><span class="line">完成从 1~100 的累加。</span><br><span class="line">2.思路</span><br><span class="line">通过任务拆分、合并的方式来实现。拆分的逻辑是：</span><br><span class="line"></span><br><span class="line">- 将大范围数值累加拆分为小范围数值累加。</span><br><span class="line">- 在 1~10 区间范围内执行计算。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间开始位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间结束位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间调整值：要通过拆分任务将区间调整到 10 以内</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ADJUST_VALUE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前任务的结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明构造器，设定当前任务的开始和结束位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、判断当前区间是否是原子任务中可以执行计算的范围</span></span><br><span class="line">        <span class="keyword">if</span> (end - begin &lt;= ADJUST_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;= end ; i++) &#123;</span><br><span class="line">                result  = result + i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、计算新拆分任务的区间范围</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftBegin</span> <span class="operator">=</span> begin;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftEnd</span> <span class="operator">=</span> (begin + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">rightBegin</span> <span class="operator">=</span> leftEnd + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightEnd</span> <span class="operator">=</span> end;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、创建两个新的任务（子任务）</span></span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">myTaskLeft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(leftBegin, leftEnd);</span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">myTaskRight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(rightBegin, rightEnd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、调用框架提供的 fork() 进一步拆分任务</span></span><br><span class="line">            myTaskLeft.fork();</span><br><span class="line">            myTaskRight.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5、调用框架提供的 join() 获取子任务计算的结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftResult</span> <span class="operator">=</span> (<span class="type">int</span>) myTaskLeft.join();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightResult</span> <span class="operator">=</span> (<span class="type">int</span>) myTaskRight.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6、把子任务的结果合并到一起</span></span><br><span class="line">            result = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建 Fork Join 任务池</span></span><br><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建任务对象</span></span><br><span class="line"><span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、将任务对象提交到任务池</span></span><br><span class="line"><span class="type">ForkJoinTask</span> <span class="variable">forkJoinTask</span> <span class="operator">=</span> pool.submit(myTask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、获取任务执行结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">finalResult</span> <span class="operator">=</span> (<span class="type">int</span>) forkJoinTask.get();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;finalResult = &quot;</span> + finalResult);</span><br></pre></td></tr></table></figure></blockquote><h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">线程池就是一个容器,存放多个线程对象的容器,当我们需要用到线程的时候,只用区线程池拿就行,不需要new新的线程,可以节省开辟线程的空间,提高代码的效率.</span><br><span class="line">2.有哪些</span><br><span class="line">newCachedThreadPool</span><br><span class="line">线程会根据需要创建多线程,并可以重用之前创建的线程,可扩容,适合执行短期的异步任务.</span><br><span class="line">newFixedThreadPool(线程数)</span><br><span class="line">指定固定的线程数,适合执行长期的任务</span><br><span class="line">newScheduledThreadPool(线程数)</span><br><span class="line">指定固定的线程数,支持周期性的任务执行</span><br><span class="line">newSingleThreadExecutor</span><br><span class="line">一个任务一个任务的执行，一池一线程。</span><br><span class="line">3.实际开发</span><br><span class="line">在实际的开发中,我们采用由ThreadPoolExecutor自定义的线程池</span><br></pre></td></tr></table></figure><p>为什么</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程的主要作用就是为了控制线程的数量,在开发过程中,我们将需要线程处理的任务放入到队列中,等待线程创建之后启动这些在队列中排队的任务,如果队列已满,我们就将任务交由非核心线程处理,线程池的主要特点是在线程池中的线程能够复用,能够控制最大的并发数量,任务总数超过了核心线程和非核心线程的数量,那就拒绝这个任务,拒绝也有四种策略,一个是默认的,直接抛出异常,阻止线程池接受新的任务,还有一种是让任务从哪里来,回哪里去,不用抛弃自己的任务,也不用抛出异常,另一种是替换自己队列中等待最久的那个任务,最后一种是默默丢弃,不去抛异常,</span><br><span class="line">线程池中的线程的重复利用能够降低资源的消耗,任务不用去等待线程的创建才被执行,线程创建时间的减少可以提高任务的响应速度,也可以更好的管理线程,应为如果线程无限制,无休止的创建,反反复复,会影响到系统的性能,降低系统的稳定性,所以我们用线程池堆线程进行管理,提高可管理性.</span><br></pre></td></tr></table></figure><p>底层原理</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在线程池刚刚创建的时候,里面是没有任何线程的,等任务来的时候,才会创建线程,当然也可以调用方法提前创建线程,当提交一个任务的时候,如果还有空闲的核心线程数或还未被创建的核心线程数,那我们就直接用这个核心线程或创建这个核心线程执行我们的这个任务,如果没有空闲的核心线程,且队列没有满的情况下,我们就把这个任务放在核心线程中排队等待,等待有空闲的核心线程后来处理队列中排队的任务,如果队列已经满了,但非核心线程还有空闲,我们就用非核心线程去处理这个任务,核心线程和非核心线程的区别是,核心线程一直都存在,非核心线程在一定的时间内没干活了,那么这个非核心线程就会被停掉,线程池在创建了很多的非核心任务后,在任务量核心线程和队列能解决的情况下,会在一定的时间内停止掉非核心线程的数量,线程池中的线程数会慢慢缩减到核心线程的数量,当队列已满的情况下,再来任务,这个任务会被指定的拒绝策略拒绝掉.</span><br></pre></td></tr></table></figure><p>七大参数</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个类的构造器都有4个,其中一个构造器的参数数量是5个,其他的都是7个,在实际的开发中,我们一般中7个参数的构造器,这七个参数是线程池的核心线程数,线程池的最大线程数,非核心线程的空闲存活时间,存活时间的单位,任务的队列,创建线程池中线程的工厂,拒绝策略.</span><br></pre></td></tr></table></figure><p>核心线程数和最大线程数如何设置</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果线程主要执行的是计算的任务,CPU利用率高,核心线程数等于CPU核心数</span><br><span class="line">如果线程主要执行的是IO操作,CPU利用率不高,核心线程数等于2倍的CPU核心数</span><br><span class="line">最大线程数都设置为核心线程数+1</span><br></pre></td></tr></table></figure><p>拒绝策略都有哪些</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拒绝策略一般分为4种,第一种为直接抛出异常,程序结束.第二中为任务从哪个线程来,让它回哪里去.第三种为直接替换阻塞队列中最靠前的任务,直接插队上位.第四种为默默丢弃,直接丢弃任务</span><br></pre></td></tr></table></figure></blockquote><h2 id="CompletableFuture-异步编排"><a href="#CompletableFuture-异步编排" class="headerlink" title="CompletableFuture(异步编排)"></a>CompletableFuture(异步编排)</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="什么是线程池-有哪些-怎么创建"><a href="#什么是线程池-有哪些-怎么创建" class="headerlink" title="什么是线程池,有哪些,怎么创建?"></a>什么是线程池,有哪些,怎么创建?</h3><blockquote><blockquote><p>线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率</p><p>在 JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法。</p><p>ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</p><p>ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(4);</p><p>ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(4);</p><p>ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();</p><p>然后调用他们的 execute 方法即可。</p><p><strong>（<strong><strong>1</strong></strong>）****newCachedThreadPool</strong></p><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是：</p><p>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</p><p>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p><p>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</p><p><strong>（<strong><strong>2</strong></strong>）****newFixedThreadPool</strong></p><p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p><p><strong>（<strong><strong>3</strong></strong>）****newSingleThreadExecutor</strong></p><p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p><p><strong>（<strong><strong>4</strong></strong>）****newScheduleThreadPool</strong></p><p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行。例如延迟3秒执行。</p><p>这4种线程池底层 全部是ThreadPoolExecutor对象的实现，阿里规范手册中规定线程池采用ThreadPoolExecutor自定义的，实际开发也是。</p></blockquote><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">线程池就是一个容器,存放多个线程对象的容器,当我们需要用到线程的时候,只用区线程池拿就行,不需要new新的线程,可以节省开辟线程的空间,提高代码的效率.</span><br><span class="line">2.有哪些</span><br><span class="line">newCachedThreadPool</span><br><span class="line">线程会根据需要创建多线程,并可以重用之前创建的线程,可扩容,适合执行短期的异步任务.</span><br><span class="line">newFixedThreadPool(线程数)</span><br><span class="line">指定固定的线程数,适合执行长期的任务</span><br><span class="line">newScheduledThreadPool(线程数)</span><br><span class="line">指定固定的线程数,支持周期性的任务执行</span><br><span class="line">newSingleThreadExecutor</span><br><span class="line">一个任务一个任务的执行，一池一线程。</span><br><span class="line">3.实际开发</span><br><span class="line">在实际的开发中,我们采用由ThreadPoolExecutor自定义的线程池</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h3><blockquote><blockquote><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最 大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p><p>主要特点:线程复用;控制最大并发数:管理线程。</p><p>第一:降低资源消耗。通过重复利用己创建的线程降低线程创建和销毁造成的消耗。</p><p>第二:提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</p><p>第三:提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进 行统一的分配，调优和监控</p></blockquote><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程的主要作用就是为了控制线程的数量,在开发过程中,我们将需要线程处理的任务放入到队列中,等待线程创建之后启动这些在队列中排队的任务,如果队列已满,我们就将任务交由非核心线程处理,线程池的主要特点是在线程池中的线程能够复用,能够控制最大的并发数量,任务总数超过了核心线程和非核心线程的数量,那就拒绝这个任务,拒绝也有四种策略,一个是默认的,直接抛出异常,阻止线程池接受新的任务,还有一种是让任务从哪里来,回哪里去,不用抛弃自己的任务,也不用抛出异常,另一种是替换自己队列中等待最久的那个任务,最后一种是默默丢弃,不去抛异常,</span><br><span class="line">线程池中的线程的重复利用能够降低资源的消耗,任务不用去等待线程的创建才被执行,线程创建时间的减少可以提高任务的响应速度,也可以更好的管理线程,应为如果线程无限制,无休止的创建,反反复复,会影响到系统的性能,降低系统的稳定性,所以我们用线程池堆线程进行管理,提高可管理性.</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h3><blockquote><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209161825865.png" alt="image-20220916182533785"></p><p>第一步：线程池刚创建的时候，里面没有任何线程，等到有任务过来的时候才会创建线程。当然也可以调用 prestartAllCoreThreads() 或者 prestartCoreThread() 方法预创建corePoolSize个线程</p><p>第二步：调用execute()提交一个任务时，如果当前的工作线程数&lt;corePoolSize，直接创建新的线程执行这个任务</p><p>第三步：如果当时工作线程数量&gt;=corePoolSize，会将任务放入任务队列中缓存</p><p>第四步：如果队列已满，并且线程池中工作线程的数量&lt;maximumPoolSize，还是会创建线程执行这个任务</p><p>第五步：如果队列已满，并且线程池中的线程已达到maximumPoolSize，这个时候会执行拒绝策略，JAVA线程池默认的策略是AbortPolicy，即抛出RejectedExecutionException异常</p></blockquote><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在线程池刚刚创建的时候,里面是没有任何线程的,等任务来的时候,才会创建线程,当然也可以调用方法提前创建线程,当提交一个任务的时候,如果还有空闲的核心线程数或还未被创建的核心线程数,那我们就直接用这个核心线程或创建这个核心线程执行我们的这个任务,如果没有空闲的核心线程,且队列没有满的情况下,我们就把这个任务放在核心线程中排队等待,等待有空闲的核心线程后来处理队列中排队的任务,如果队列已经满了,但非核心线程还有空闲,我们就用非核心线程去处理这个任务,核心线程和非核心线程的区别是,核心线程一直都存在,非核心线程在一定的时间内没干活了,那么这个非核心线程就会被停掉,线程池在创建了很多的非核心任务后,在任务量核心线程和队列能解决的情况下,会在一定的时间内停止掉非核心线程的数量,线程池中的线程数会慢慢缩减到核心线程的数量,当队列已满的情况下,再来任务,这个任务会被指定的拒绝策略拒绝掉.</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？"><a href="#ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？" class="headerlink" title="ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？"></a>ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？</h3><blockquote><blockquote><p><strong>参数与作用：</strong>共7个参数</p><p><strong>corePoolSize****：</strong>核心线程数，在ThreadPoolExecutor中有一个与它相关的配置：allowCoreThreadTimeOut（默认为false），当allowCoreThreadTimeOut为false时，核心线程会一直存活，哪怕是一直空闲着。而当allowCoreThreadTimeOut为true时核心线程空闲时间超过keepAliveTime时会被回收。</p><p><strong>maximumPoolSize****：</strong>最大线程数，线程池能容纳的最大线程数，当线程池中的线程达到最大时，此时添加任务将会采用拒绝策略，默认的拒绝策略是抛出一个运行时错误（RejectedExecutionException）。值得一提的是，当初始化时用的工作队列为LinkedBlockingDeque时，这个值将无效。</p><p><strong>keepAliveTime****：</strong>存活时间，当非核心空闲超过这个时间将被回收，同时空闲核心线程是否回收受allowCoreThreadTimeOut影响。</p><p><strong>unit****：</strong>keepAliveTime的单位。</p><p><strong>workQueue****：</strong>任务队列，常用有三种队列，即SynchronousQueue,LinkedBlockingDeque（无界队列）,ArrayBlockingQueue（有界队列）。</p><p><strong>threadFactory****：</strong>线程工厂，ThreadFactory是一个接口，用来创建worker。通过线程工厂可以对线程的一些属性进行定制。默认直接新建线程。</p><p><strong>RejectedExecutionHandler****：</strong>也是一个接口，只有一个方法，当线程池中的资源已经全部使用，添加新线程被拒绝时，会调用RejectedExecutionHandler的rejectedExecution法。</p><p>默认是抛出一个运行时异常。</p><p><strong>线程池大小设置：</strong></p><p><strong>核心线程</strong><br><strong>CPU密集型：核心线程数=CPU核心数(或 核心线程数=CPU核心数+1)</strong><br><strong>I/O密集型：核心线程数=2*CPU核心数（或 核心线程数=CPU核心数/（1-阻塞系数))</strong><br><strong>混合型：核心线程数=（线程等待时间/线程CPU时间+1）*CPU核心数</strong></p><p><strong>最大线程</strong><br><strong>IO密集型经验应用，最大线程设置为 2N+1 (N为CPU数量，下同)<br>CPU密集型应用，最大线程设置为 N+1</strong></p><ol><li>需要分析线程池执行的任务的特性： CPU 密集型还是 IO 密集型</li><li>每个任务执行的平均时长大概是多少，这个任务的执行时长可能还跟任务处理逻辑是否涉及到网络传输以及底层系统资源依赖有关系</li></ol><p>如果是 CPU 密集型，主要是执行计算任务，响应时间很快，cpu 一直在运行，这种任务 cpu的利用率很高，那么线程数的配置应该根据 CPU 核心数来决定，CPU 核心数=最大同时执行线程数，加入 CPU 核心数为 4，那么服务器最多能同时执行 4 个线程。过多的线程会导致上下文切换反而使得效率降低。那线程池的最大线程数可以配置为 cpu 核心数+1 如果是 IO 密集型，主要是进行 IO 操作，执行 IO 操作的时间较长，这是 cpu 出于空闲状态，导致 cpu 的利用率不高，这种情况下可以增加线程池的大小。这种情况下可以结合线程的等待时长来做判断，等待时间越高，那么线程数也相对越多。一般可以配置 cpu 核心数的 2 倍。</p><p>一个公式：线程池设定最佳线程数目 = （（线程池设定的线程等待时间+线程 CPU 时间）/<br> 线程 CPU 时间 ）* CPU 数目</p><p>这个公式的线程 cpu 时间是预估的程序单个线程在 cpu 上运行的时间（通常使用 loadrunner测试大量运行次数求出平均值）</p><p><strong>拒绝策略：</strong></p><p>1、AbortPolicy：直接抛出异常，默认策略；<br> 2、CallerRunsPolicy：用调用者所在的线程来执行任务；<br> 3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br> 4、DiscardPolicy：直接丢弃任务；<br> 当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务</p></blockquote><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.ThreadPoolExecutor对象有那些参数</span><br><span class="line">这个类的构造器都有4个,其中一个构造器的参数数量是5个,其他的都是7个,在实际的开发中,我们一般中7个参数的构造器,这七个参数是线程池的核心线程数,线程池的最大线程数,非核心线程的空闲存活时间,存活时间的单位,任务的队列,创建线程池中线程的工厂,拒绝策略.</span><br><span class="line">2.核心线程数和最大线程数如何设置</span><br><span class="line">如果线程主要执行的是计算的任务,CPU利用率高,核心线程数等于CPU核心数</span><br><span class="line">如果线程主要执行的是IO操作,CPU利用率不高,核心线程数等于2倍的CPU核心数</span><br><span class="line">最大线程数都设置为核心线程数+1</span><br><span class="line">3.拒绝策略都有哪些</span><br><span class="line">拒绝策略一般分为4种,第一种为直接抛出异常,程序结束.第二中为任务从哪个线程来,让它回哪里去.第三种为直接替换阻塞队列中最靠前的任务,直接插队上位.第四种为默默丢弃,直接丢弃任务</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="常见线程安全的并发容器有哪些？"><a href="#常见线程安全的并发容器有哪些？" class="headerlink" title="常见线程安全的并发容器有哪些？"></a>常见线程安全的并发容器有哪些？</h3><blockquote><blockquote><p>CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap</p></blockquote><blockquote><p>CopyOnWriteArrayList、CopyOnWriteArraySet采用写时复制实现线程安全</p></blockquote><blockquote><p>ConcurrentHashMap采用分段锁的方式实现线程安全</p></blockquote><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.List</span><br><span class="line">我们使用CopyOnWriteArrayList,采用写时复制实现线程的安全,先读操作把集合整个复制一份,在写入新的集合,最后让原来指向集合的变量全部指向新集合</span><br><span class="line">2.Set</span><br><span class="line">我们使用CopyOnWriteArraySet,也是采用了写时复制实现的线程安全,</span><br><span class="line">3.Map</span><br><span class="line">使用ConcurrentHashMap,采用的时分段锁实现的线程安全.</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="synchronized底层实现是什么？lock底层是什么？有什么区别？"><a href="#synchronized底层实现是什么？lock底层是什么？有什么区别？" class="headerlink" title="synchronized底层实现是什么？lock底层是什么？有什么区别？"></a>synchronized底层实现是什么？lock底层是什么？有什么区别？</h3><blockquote><blockquote><p><strong>Synchronized****原理：</strong></p><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p><p>代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p><p><strong>Lock****原理：</strong></p><p> Lock的存储结构：一个int类型状态值（用于锁的状态变更），一个双向链表（用于存储等待中的线程） </p><p> Lock获取锁的过程：本质上是通过CAS来获取状态值修改，如果当场没获取到，会将该线程放在线程等待链表中。 </p><p> Lock释放锁的过程：修改状态值，调整等待链表。 </p><p> Lock大量使用CAS+自旋。因此根据CAS特性，lock建议使用在低锁冲突的情况下。</p><p><strong>Lock<strong><strong>与synchronized</strong></strong>的区别：</strong></p><p>\1. Lock的加锁和解锁都是由java代码配合native方法（调用操作系统的相关方法）实现的，而synchronize的加锁和解锁的过程是由JVM管理的</p><p>\2. 当一个线程使用synchronize获取锁时，若锁被其他线程占用着，那么当前只能被阻塞，直到成功获取锁。而Lock则提供超时锁和可中断等更加灵活的方式，在未能获取锁的   条件下提供一种退出的机制。</p><p>\3. 一个锁内部可以有多个Condition实例，即有多路条件队列，而synchronize只有一路条件队列；同样Condition也提供灵活的阻塞方式，在未获得通知之前可以通过中断线程以  及设置等待时限等方式退出条件队列。</p><p>\4. synchronize对线程的同步仅提供独占模式，而Lock即可以提供独占模式，也可以提供共享模式</p><table><thead><tr><th>synchronized</th><th>Lock</th></tr></thead><tbody><tr><td>关键字</td><td>类</td></tr><tr><td>自动加锁和释放锁</td><td>需要手动调用unlock方法释放锁</td></tr><tr><td>jvm层面的锁</td><td>API层面的锁</td></tr><tr><td>非公平锁</td><td>可以选择公平或者非公平锁</td></tr><tr><td>锁是一个对象,并且锁的信息保存在了对象中</td><td>代码中通过int类型的state标识</td></tr><tr><td>有一个锁升级的过程</td><td>无</td></tr></tbody></table></blockquote><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.synchronized底层原理</span><br><span class="line">Hotspot虚拟机中的对象结构中,一个在堆中的对象的结构可以分为对象头,对象体,对齐字节,对象头中存在MarkWorld,类型指针,在多线程争抢锁的环境下,MarkWorld会有一个指针指向一个特殊的对象监视器类,在这个对象监视器类的结构中记录了各种关于锁的信息.</span><br><span class="line">当一个线程的执行过程中,遇到了synchronized,它会先去判断锁对象的对象监视器中的<span class="built_in">_</span>count是否为0,如果是0,则当前锁对象是未锁定状态,执行monitorenter指令,对锁对象的对象监视器中的<span class="built_in">_</span>recursions线程重入次数+1,<span class="built_in">_</span>count线程锁的计数器+1,<span class="built_in">_</span>owner指向当前线程.如果对象的对象监视器中的<span class="built_in">_</span>count不为0,则就去判断对象监视器中的<span class="built_in">_</span>owner是否指向自己,如果指向自己,就执行monitorenter指令,如果不指向自己,那就让当前线程进入阻塞队列,在对象监视器中的<span class="built_in">_</span>EntryList记录当前线程</span><br><span class="line">2.lock底层原理</span><br><span class="line">1.ReentrantLock是Lock接口最常用的一个实现类,这个实现类内部又有多个内部类,这几个内部类是公平锁和非公平锁等,我们一般默认使用的是非公平锁NonfairSync,NonfairSync继承了Sync,Sync继承了AQS,NonfairSync重写了夫类的tryAcquire方法</span><br><span class="line">2.当一个线程进入lock方法时候,会先判断是否有其他线程占用,如果没有,则将当前线程设置为独占,state值+1</span><br><span class="line">3.当一个线程再次进入lock方法的时候,此时发现当前资源已被其他线程占用,则进入else执行acquire(1);</span><br><span class="line">4.acquire方法内部执行if(!tryAcquire(arg) <span class="built_in">&amp;</span><span class="built_in">&amp;</span> acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">5.tryAcquire方法是本类重写的方法,tryAcquire方法又调用了父类Sync的nonfairTryAcquire()方法</span><br><span class="line">6.nonfairTryAcquire()方法中先再次判断了资源是否被独占,如果没有被独占,则当前线程就独占它</span><br><span class="line">7.如果还是被独占,那就判断独占的线程是不是自己本身,如果是的话,可重入次数+1,也就是state值+1</span><br><span class="line">8.如果不是自己,那就返回false;回到acquire方法执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">9.addWaiter方法中将当前线程封装成一个节点对象,然后判断双向链表最后一个节点是否有值,如果有值,就把最后一个节点向前移一位,自己放在最后一个节点上</span><br><span class="line">10.解锁的时候调用ReentrantLock的unlock方法,中调用Sync的tryRelease方法,state减去相应的值,释放锁</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos</title>
      <link href="/archives/c383a3c4.html"/>
      <url>/archives/c383a3c4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><blockquote><p>下载源码</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/alibaba/nacos.git</span><br></pre></td></tr></table></figure><p>单机启动</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209201847477.png" alt="image-20220920184753420"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dnacos.standalone=true</span><br></pre></td></tr></table></figure></blockquote><h2 id="核心功能点"><a href="#核心功能点" class="headerlink" title="核心功能点"></a>核心功能点</h2><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.服务注册</span><br><span class="line">Nacos客户端会向服务端发送REST请求并携带自身的元数据(IP,端口等),请求服务端注册自己的服务,当服务端收到客户端请求后会把客户端请求携带的元数据存储在一个双层Map中</span><br><span class="line">2.服务心跳</span><br><span class="line">当客户端的服务被注册后,客户端会添加一个定时心跳任务默认每隔5秒去通知服务端我还活着,处于可用状态</span><br><span class="line">3.服务健康检查</span><br><span class="line">当客户端的服务被注册,服务端会开启一个定时[它的探测周期是2000毫秒+随件数(5000毫秒内)]的服务健康检查任务来检查注册的服务实例的健康状况,对于超过15秒没有收到客户端心跳的实例,将它(Instance)的healthy属性值改为false(服务发现时不会发现此服务),对于超过30秒没有收到客户端心跳的实例,则将此实例从服务端服务注册中心剔除(如果被剔除的实例恢复心跳则会重新注册)</span><br><span class="line">4.服务发现</span><br><span class="line">服务的消费者(Nacos Client1)在调用服务的提供者(Nacos Client2)时,会先发送一个REST请求给服务端,获取服务端的服务注册信息,并缓存在客户端本地,同时会在客户端本地开启一个定时的任务来拉取服务端最新的服务注册信息更新本地的服务注册表缓存</span><br><span class="line">5.服务同步</span><br><span class="line">服务端集群之间的数据的同步</span><br></pre></td></tr></table></figure></blockquote><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><blockquote><p>架构图</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209201939560.png" alt="image-20220920193920450"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Nacos服务端：作用是提供服务注册、服务发现、服务同步以及服务健康检查功能等。</span><br><span class="line">Nacos客户端：作用是给每一个微服务提供调用方法，跟Nacos服务端进行通信。</span><br><span class="line"></span><br><span class="line">客户端如何与服务端做通信? ==&gt; 使用HTTP</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209201946875.png" alt="image-20220920194614797"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;服务注册表的结构</span><br><span class="line">1.Map&lt;String, Map&lt;String, Service&gt;&gt; ==&gt; Map&lt;namespace, Map&lt;ServiceName, Service&gt;&gt;</span><br><span class="line"></span><br><span class="line">Service.clusterMap  ==&gt;  Map&lt;String, Cluster&gt;</span><br><span class="line">Cluster.ephemeralInstances ==&gt; Set&lt;Instance&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209211247202.png" alt="Nacos-导出 (1)"></p></blockquote><h2 id="源码入口"><a href="#源码入口" class="headerlink" title="源码入口"></a>源码入口</h2><blockquote><p>依赖坐标</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209201948249.png" alt="image-20220920194855197"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用SpringBoot的自动装配的原理,依赖对应的包中会有一个spring.factories文件,里面是自动配置的类,找到Key为EnableAutoConfiguration中的NacosDiscoveryAutoConfiguration调用类</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NacosDiscoveryAutoConfiguration类有三个Bean,最后一个Bean是核心Bean</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">又调用了NacosDiscoveryAutoConfiguration父类AbstractAutoServiceRegistration的构造方法,将NacosServiceRegistry赋值给serviceRegistry</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NacosAutoServiceRegistration父类实现了ApplicationListener,意味着微服务启动时会执行本类的onApplicationEvent方法,onApplicationEvent由调用了bind(),bind()中又调用了启动方法start(),start()方法中由调用了核心方法register()</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在日志打印中可以看出register()方法在执行到registerInstance()方法之后,服务完成了注册,所以源码的服务注册入口就找到了</span><br></pre></td></tr></table></figure><p>register()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Registration registration)</span> &#123;</span><br><span class="line">    <span class="comment">//获取服务的ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceId</span> <span class="operator">=</span> registration.getServiceId();</span><br><span class="line">    <span class="comment">//获取默认的服务组(&quot;DEFAULT_GROUP&quot;)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="built_in">this</span>.nacosDiscoveryProperties.getGroup();</span><br><span class="line">    <span class="comment">//获取服务的实例(IP,端口,权重,集群名称,元数据)</span></span><br><span class="line">    <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="built_in">this</span>.getNacosInstanceFromRegistration(registration);</span><br><span class="line"><span class="comment">//执行注册</span></span><br><span class="line">    <span class="built_in">this</span>.namingService.registerInstance(serviceId, group, instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>目前的代码都是客户端提供给微服务的代码,并没有涉及到服务端的代码</p></blockquote></blockquote><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><blockquote><p>NacosNamingService.registerInstance()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">//判断是不是临时的实例</span></span><br><span class="line"><span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">  <span class="comment">//设置心跳信息 == &gt;后面服务心跳会详讲</span></span><br><span class="line">  <span class="type">BeatInfo</span> <span class="variable">beatInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeatInfo</span>();</span><br><span class="line">  beatInfo.setServiceName(NamingUtils.getGroupedName(serviceName, groupName));</span><br><span class="line">  beatInfo.setIp(instance.getIp());</span><br><span class="line">  beatInfo.setPort(instance.getPort());</span><br><span class="line">  beatInfo.setCluster(instance.getClusterName());</span><br><span class="line">  beatInfo.setWeight(instance.getWeight());</span><br><span class="line">  beatInfo.setMetadata(instance.getMetadata());</span><br><span class="line">  beatInfo.setScheduled(<span class="literal">false</span>);</span><br><span class="line">  beatInfo.setPeriod(instance.getInstanceHeartBeatInterval());</span><br><span class="line"></span><br><span class="line">  beatReactor.addBeatInfo(NamingUtils.getGroupedName(serviceName, groupName), beatInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用代理类注册服务</span></span><br><span class="line">serverProxy.registerService(NamingUtils.getGroupedName(serviceName, groupName), groupName, instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamingProxy.registerService()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line"> NAMING_LOGGER.info(<span class="string">&quot;[REGISTER-SERVICE] &#123;&#125; registering service &#123;&#125; with instance: &#123;&#125;&quot;</span>,</span><br><span class="line">                    namespaceId, serviceName, instance);</span><br><span class="line"> <span class="comment">//创建参数集合,放入请求需要携带的参数</span></span><br><span class="line"> <span class="keyword">final</span> Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">9</span>);</span><br><span class="line"> params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line"> params.put(CommonParams.SERVICE_NAME, serviceName);</span><br><span class="line"> params.put(CommonParams.GROUP_NAME, groupName);</span><br><span class="line"> params.put(CommonParams.CLUSTER_NAME, instance.getClusterName());</span><br><span class="line"> params.put(<span class="string">&quot;ip&quot;</span>, instance.getIp());</span><br><span class="line"> params.put(<span class="string">&quot;port&quot;</span>, String.valueOf(instance.getPort()));</span><br><span class="line"> params.put(<span class="string">&quot;weight&quot;</span>, String.valueOf(instance.getWeight()));</span><br><span class="line"> params.put(<span class="string">&quot;enable&quot;</span>, String.valueOf(instance.isEnabled()));</span><br><span class="line"> params.put(<span class="string">&quot;healthy&quot;</span>, String.valueOf(instance.isHealthy()));</span><br><span class="line"> params.put(<span class="string">&quot;ephemeral&quot;</span>, String.valueOf(instance.isEphemeral()));</span><br><span class="line"> params.put(<span class="string">&quot;metadata&quot;</span>, JSON.toJSONString(instance.getMetadata()));</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//向服务端发送请求进行实例的注册,请求地址为&quot;/nacos/v1/ns/instance&quot;,请求方式为POST</span></span><br><span class="line"> reqAPI(UtilAndComs.NACOS_URL_INSTANCE, params, HttpMethod.POST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamingProxy.reqAPI()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reqAPI</span><span class="params">(String api, Map&lt;String, String&gt; params, String body, List&lt;String&gt; servers, String method)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> callServer(api, params, body, nacosDomain, method);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamingProxy.callServer()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">callServer</span><span class="params">(String api, Map&lt;String, String&gt; params, String body, String curServer, String method)</span></span><br><span class="line">        <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">//封装请求头信息</span></span><br><span class="line">    List&lt;String&gt; headers = builderHeaders();</span><br><span class="line"><span class="comment">//拼接请求地址</span></span><br><span class="line">    String url;</span><br><span class="line">   </span><br><span class="line">    url = curServer + api;</span><br><span class="line"></span><br><span class="line">    url = HttpClient.getPrefix() + curServer + api;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    HttpClient.<span class="type">HttpResult</span> <span class="variable">result</span> <span class="operator">=</span> HttpClient.request(url, headers, params, body, UtilAndComs.ENCODING, method);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在服务端中会有一个Controller来接受客户端发送的服务注册请求,在naming模块下的com.alibaba.nacos.naming.controllers下的InstanceController类中的register为服务端注册方法</span><br></pre></td></tr></table></figure><p>InstanceController.register()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanDistro</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@Secured(parser = NamingResourceParser.class, action = ActionTypes.WRITE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//从请求中获取服务名称</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line"> <span class="comment">//从请求中获取namespaceId</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> WebUtils.optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line"> <span class="comment">// 实现注册实例  parseInstance(request)==&gt;解析请求参数中的Instance,并重新赋值</span></span><br><span class="line"> serviceManager.registerInstance(namespaceId, serviceName, parseInstance(request));</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入ServiceManager类的registerInstance方法</span><br><span class="line">ServiceManager类可以想象为一个我们写Service层的某个XXXService</span><br></pre></td></tr></table></figure><p>ServiceManager.registerInstance()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法创建了服务的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">     <span class="comment">//创建注册表,创建空的Service结构</span></span><br><span class="line">     createEmptyService(namespaceId, serviceName, instance.isEphemeral());</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//添加服务实例</span></span><br><span class="line">     addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p>ServiceManager.createEmptyService()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createServiceIfAbsent</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> local, Cluster cluster)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">//从注册表中获取服务</span></span><br><span class="line"> <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line"><span class="comment">//第一次注册的话,服务肯定是获取不到的</span></span><br><span class="line"> <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//创建服务,创建服务注册表,将服务放进服务注册表中</span></span><br><span class="line">   </span><br><span class="line">        <span class="comment">//创建服务</span></span><br><span class="line">        service = <span class="keyword">new</span> <span class="title class_">Service</span>();</span><br><span class="line">        <span class="comment">//对服务名称,命名空间ID,组名...属性进行赋值</span></span><br><span class="line">     service.setName(serviceName);</span><br><span class="line">             service.setNamespaceId(namespaceId);</span><br><span class="line">        service.setGroupName(NamingUtils.getGroupName(serviceName));</span><br><span class="line">        service.setLastModifiedMillis(System.currentTimeMillis());</span><br><span class="line">        service.recalculateChecksum();</span><br><span class="line">        <span class="keyword">if</span> (cluster != <span class="literal">null</span>) &#123;</span><br><span class="line">            cluster.setService(service);</span><br><span class="line">            <span class="comment">//将与当前服务对象绑定的cluster对Service对象的clusterMap属性赋值</span></span><br><span class="line">            service.getClusterMap().put(cluster.getName(), cluster);</span><br><span class="line">        &#125;</span><br><span class="line">        service.validate();</span><br><span class="line">        <span class="comment">// 1.创建服务注册中心表结构,将刚刚创建的Service添加进去</span></span><br><span class="line">        <span class="comment">// 2.执行Service对象的init()方法,执行定时任务,健康检查</span></span><br><span class="line">        <span class="comment">// 3.健康检查,对实例15,或30秒没有收到客户端发送的心跳,进行处理</span></span><br><span class="line">        <span class="comment">// 4.会从线程池中拿一个线程执行我们的延迟任务,初始化5秒后执行,每隔5秒执行一次</span></span><br><span class="line">        putServiceAndInit(service);</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            addOrReplaceService(service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p>ServiceManager.addInstance()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInstance</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> ephemeral, Instance... ips)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建临时的实例key ==&gt; 很长的一个字符串  里面有emph.&quot;xxxxxcemplh.&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line"></span><br><span class="line"> <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">   </span><br><span class="line">     List&lt;Instance&gt; instanceList = addIpAddresses(service, ephemeral, ips);</span><br><span class="line">        <span class="type">Instances</span> <span class="variable">instances</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instances</span>();</span><br><span class="line"></span><br><span class="line">        instances.setInstanceList(instanceList);</span><br><span class="line">          <span class="comment">//调用DelegateConsistencyServiceImpl.put方法 将服务放入内存中,AP,临时存储</span></span><br><span class="line">        consistencyService.put(key, instances);</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>   DelegateConsistencyServiceImpl.put()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">// 调用DistroConsistencyService.put</span></span><br><span class="line"> mapConsistencyService(key).put(key, value);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>   DistroConsistencyServiceImpl.put()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">//1.将内存注册实例更新到内存注册表中</span></span><br><span class="line"> <span class="comment">//2.同步实例信息到其他服务端集群</span></span><br><span class="line">onPut(key, value);</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> taskDispatcher.addTask(key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>   DistroConsistencyServiceImpl.onPut()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPut</span><span class="params">(String key, Record value)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (KeyBuilder.matchEphemeralInstanceListKey(key)) &#123;</span><br><span class="line">    <span class="comment">//1.将实例包装成一个Datum对象并放到dataStore中</span></span><br><span class="line">     <span class="comment">//2.将我们之前生成的实例key赋值给Datum对象的key属性</span></span><br><span class="line">     Datum&lt;Instances&gt; datum = <span class="keyword">new</span> <span class="title class_">Datum</span>&lt;&gt;();</span><br><span class="line">     datum.value = (Instances) value;</span><br><span class="line">        datum.key = key;</span><br><span class="line">        datum.timestamp.incrementAndGet();</span><br><span class="line">        <span class="comment">//暂时存储</span></span><br><span class="line">        dataStore.put(key, datum);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (!listeners.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将我们客户端传入的一些Key 和一些其他参数封装到按一个Pair对象里面去 然后在丢到内存队列里</span></span><br><span class="line"> <span class="comment">// notifier是一个Runnable,开启一个线程,执行任务</span></span><br><span class="line">    notifier.addTask(key, ApplyAction.CHANGE);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>   Notifier.addTask()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tasks是一个阻塞队列，这里就是把注册实例数据任务放入阻塞队列里。</span></span><br><span class="line">&gt;<span class="comment">//异步任务和内存队列操作,对系统性能有很大帮助</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String datumKey, ApplyAction action)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (services.containsKey(datumKey) &amp;&amp; action == ApplyAction.CHANGE) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (action == ApplyAction.CHANGE) &#123;</span><br><span class="line">     services.put(datumKey, StringUtils.EMPTY);</span><br><span class="line">    &#125;</span><br><span class="line">    tasks.add(Pair.with(datumKey, action));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>   Notifier.run()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//不断的从队列中拿任务,一旦没有任务就会阻塞住</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 异步注册 ==&gt; 并且不会占用cpu,一旦队列中没有消息 那么当前线程就会阻塞住,不会消耗cpu</span></span><br><span class="line">                <span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> tasks.take();</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">datumKey</span> <span class="operator">=</span> (String) pair.getValue0();</span><br><span class="line">         <span class="type">ApplyAction</span> <span class="variable">action</span> <span class="operator">=</span> (ApplyAction) pair.getValue1();</span><br><span class="line">            services.remove(datumKey);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!listeners.containsKey(datumKey)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (RecordListener listener : listeners.get(datumKey)) &#123;</span><br><span class="line">   </span><br><span class="line">                count++;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (action == ApplyAction.CHANGE) &#123;</span><br><span class="line">                     <span class="comment">// 从dataStore中拿取我们刚放入的instance   然后开始真正的注册</span></span><br><span class="line">                        listener.onChange(datumKey, dataStore.get(datumKey).value);</span><br><span class="line">                     <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">   </span><br><span class="line">                    <span class="keyword">if</span> (action == ApplyAction.DELETE) &#123;</span><br><span class="line">                        listener.onDelete(datumKey);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    .......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span> (Loggers.DISTRO.isDebugEnabled()) &#123;</span><br><span class="line">                .......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 即使有异常也不会终止 将异常吃掉了</span></span><br><span class="line">         Loggers.DISTRO.error......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>   Service.onChange()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChange</span><span class="params">(String key, Instances value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">.....</span><br><span class="line"> <span class="comment">// 真正的注册方法在这个里面</span></span><br><span class="line">updateIPs(value.getInstanceList(), KeyBuilder.matchEphemeralInstanceListKey(key));</span><br><span class="line"> .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   Service.updateIPs()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateIPs</span><span class="params">(Collection&lt;Instance&gt; instances, <span class="type">boolean</span> ephemeral)</span> &#123;</span><br><span class="line">......</span><br><span class="line"> <span class="comment">// 真正的逻辑 ==&gt; updateIPs(entryIPs, ephemeral)</span></span><br><span class="line">clusterMap.get(entry.getKey()).updateIPs(entryIPs, ephemeral);</span><br><span class="line"> .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   Cluster.updateIPs(entryIPs, ephemeral);</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.将已经注册的实例列表复制一份,将新的实例和老的实例更新到一个集合中</span><br><span class="line">&gt;2.最终再将此集合更新到真正的服务注册表中</span><br><span class="line">3.更新完实例后会主动推送给客户端  PushService.onApplicationEvent方法  ==&gt; UDP发送</span><br><span class="line"></span><br><span class="line">利用了写实复制思想</span><br><span class="line">1.在线程写的过程中,复制一份实例表副本,其他线程读到都是旧数据</span><br><span class="line">2.在线程真正写完后,会将数据更新会服务注册表</span><br><span class="line">3.解决了并发冲突问题</span><br></pre></td></tr></table></figure></blockquote><h2 id="服务心跳"><a href="#服务心跳" class="headerlink" title="服务心跳"></a>服务心跳</h2><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><blockquote><p> NacosNamingService.registerInstance</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">//临时的实例.发送心跳服务</span></span><br><span class="line"><span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">    <span class="comment">//创建心跳对象</span></span><br><span class="line">    <span class="type">BeatInfo</span> <span class="variable">beatInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeatInfo</span>();</span><br><span class="line">    beatInfo.setServiceName(NamingUtils.getGroupedName(serviceName, groupName));</span><br><span class="line">    beatInfo.setIp(instance.getIp());</span><br><span class="line">    beatInfo.setPort(instance.getPort());</span><br><span class="line">    beatInfo.setCluster(instance.getClusterName());</span><br><span class="line">    beatInfo.setWeight(instance.getWeight());</span><br><span class="line">    beatInfo.setMetadata(instance.getMetadata());</span><br><span class="line">    beatInfo.setScheduled(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//设置心跳周期,默认5秒</span></span><br><span class="line">    beatInfo.setPeriod(instance.getInstanceHeartBeatInterval());</span><br><span class="line"><span class="comment">//向服务端发送心跳请求</span></span><br><span class="line">    beatReactor.addBeatInfo(NamingUtils.getGroupedName(serviceName, groupName), beatInfo);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> BeatReactor.addBeatInfo</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeatInfo</span><span class="params">(String serviceName, BeatInfo beatInfo)</span> &#123;</span><br><span class="line">  .....</span><br><span class="line">  <span class="comment">//在线程池中添加一个心跳任务 ==&gt; new BeatTask(beatInfo)</span></span><br><span class="line">  executorService.schedule(<span class="keyword">new</span> <span class="title class_">BeatTask</span>(beatInfo), beatInfo.getPeriod(), TimeUnit.MILLISECONDS);</span><br><span class="line">  MetricsMonitor.getDom2BeatSizeMonitor().set(dom2Beat.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> BeatTask.run</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//设置下一次心跳服务时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">nextTime</span> <span class="operator">=</span> beatInfo.getPeriod();</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//发送心跳服务</span></span><br><span class="line">    serverProxy.sendBeat(beatInfo, BeatReactor.<span class="built_in">this</span>.lightBeatEnabled);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//执行延迟任务,每隔5秒执行一次</span></span><br><span class="line">    executorService.schedule(<span class="keyword">new</span> <span class="title class_">BeatTask</span>(beatInfo), nextTime, TimeUnit.MILLISECONDS);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><blockquote><p> InstanceController.beat</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanDistro</span></span><br><span class="line"> <span class="meta">@PutMapping(&quot;/beat&quot;)</span></span><br><span class="line"> <span class="meta">@Secured(parser = NamingResourceParser.class, action = ActionTypes.WRITE)</span></span><br><span class="line"> <span class="keyword">public</span> JSONObject <span class="title function_">beat</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="comment">//1.解析请求携带的参数</span></span><br><span class="line">     <span class="comment">//2.构建所需参数</span></span><br><span class="line">     <span class="comment">//3.获取Instance实例,没有就注册</span></span><br><span class="line">     <span class="comment">//4.获取Service对象,没有就创建,注册</span></span><br><span class="line">     <span class="comment">//5.processClientBeat ==&gt; 具体处理逻辑</span></span><br><span class="line">     service.processClientBeat(clientBeat);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> Service.processClientBeat</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processClientBeat</span><span class="params">(<span class="keyword">final</span> RsInfo rsInfo)</span> &#123;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    <span class="type">ClientBeatProcessor</span> <span class="variable">clientBeatProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientBeatProcessor</span>();</span><br><span class="line">    clientBeatProcessor.setService(<span class="built_in">this</span>);</span><br><span class="line">    clientBeatProcessor.setRsInfo(rsInfo);</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    HealthCheckReactor.scheduleNow(clientBeatProcessor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ClientBeatProcessor.run()</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    instance.setLastBeat(System.currentTimeMillis());</span><br><span class="line">    <span class="comment">//因为客户端发送了心跳,所以我们要把那些不健康的服务,更新为健康的</span></span><br><span class="line">    <span class="keyword">if</span> (!instance.isMarked()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance.isHealthy()) &#123;</span><br><span class="line">            instance.setHealthy(<span class="literal">true</span>);</span><br><span class="line">            Loggers.EVT_LOG.info(<span class="string">&quot;service: &#123;&#125; &#123;POS&#125; &#123;IP-ENABLED&#125; valid: &#123;&#125;:&#123;&#125;@&#123;&#125;, region: &#123;&#125;, msg: client beat ok&quot;</span>,</span><br><span class="line">                                 cluster.getService().getName(), ip, port, cluster.getName(), UtilsAndCommons.LOCALHOST_SITE);</span><br><span class="line">            <span class="comment">//向客户端重新推送新的健康服务</span></span><br><span class="line">            getPushService().serviceChanged(service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="服务健康检查"><a href="#服务健康检查" class="headerlink" title="服务健康检查"></a>服务健康检查</h2><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在服务注册的时候会服务端会执行一个Service.init()方法,进行服务的健康检查</span><br></pre></td></tr></table></figure><p>Service.init()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行定时任务 ==&gt; 传入参数是我们客户端心跳检测任务</span></span><br><span class="line">    HealthCheckReactor.scheduleCheck(clientBeatCheckTask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Cluster&gt; entry : clusterMap.entrySet()) &#123;</span><br><span class="line">        entry.getValue().setService(<span class="built_in">this</span>);</span><br><span class="line">        entry.getValue().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClientBeatCheckTask.run()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时的服务健康检查任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 获取我们服务端的所有实例</span></span><br><span class="line">    List&lt;Instance&gt; instances = service.allIPs(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历实例,检查所有实例的健康状态</span></span><br><span class="line">    <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line">        <span class="comment">// 如果当前时间=上一次心跳时间&gt;15s 则标记instance.setHealthy(false);</span></span><br><span class="line">        <span class="keyword">if</span> (当前时间 - 上次心跳时间 &gt; 15s) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//超过15秒没有收到客户端心跳,设置健康属性值Healthy=false</span></span><br><span class="line">            instance.setHealthy(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//并向服务请推送新的实例健康状态</span></span><br><span class="line">            getPushService().serviceChanged(service);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (当前时间 - 上次心跳时间 &gt; 30s) &#123;</span><br><span class="line">            <span class="comment">// 剔除实例</span></span><br><span class="line">            deleteIP(instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><blockquote><p>略</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/archives/3d614825.html"/>
      <url>/archives/3d614825.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h2><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap底层是一个&quot;链表散列&quot;的数据结构,由数组和链表组成</span><br></pre></td></tr></table></figure></blockquote><h2 id="HashMap结构"><a href="#HashMap结构" class="headerlink" title="HashMap结构"></a>HashMap结构</h2><blockquote><p>属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层数组的默认长度16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//底层数组的最大长度2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认的加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//初始化底层数组为空数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"><span class="comment">//存放Entry对象引用的数组</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="comment">//数组和链表中元素的总个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="comment">//扩容阈值,元素的个数达到这个值可能就会进行扩容=数组长度*加载因子</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="comment">//加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入底层数组的长度和加载因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">//当传入数组的长度小于0,直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//当传入数组的长度大于数组长度的最大值,就修改为最大值</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//加载因子需要大于0并且类型要为数值类型,否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"><span class="comment">//对加载因子赋值</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//先将传入的数组长度赋值给扩容阈值,不是最终的,后面还会修改</span></span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//LinkedHashMap重写了此方法</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="HashMap的存取"><a href="#HashMap的存取" class="headerlink" title="HashMap的存取"></a>HashMap的存取</h2><h3 id="添加Put方法"><a href="#添加Put方法" class="headerlink" title="添加Put方法"></a>添加Put方法</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//如果底层数组和存放引用的数组地址相同,则初始化引用数组table</span></span><br><span class="line">    <span class="comment">//1.按照公式,重新计算对阈值threshold进行修改 2.计算2的幂次方值初始化引用数组table</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对key为null处理,说明支持存放null值数据</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//调用本类的hash方法对键值进行计算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">//根据hash值和引用数组的长度计算出存放在数组的下标位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//遍历以该数组元素作为头节点的链表,如果有相同的key,则覆盖,返回旧的value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//遍历一变后没有找到key相等的,则执行添加</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①初始化引用数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="comment">//找到&gt;=传入的数组长度的最小的幂次方数,如小于16的,都默认为16</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);</span><br><span class="line"><span class="comment">//重新计算阈值,取数组长度*加载因子和数组长度最大值+1它俩之间的最小值最为阈值</span></span><br><span class="line">    threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//初始化引用数组的长度</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">    <span class="comment">//初始化hash种子</span></span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">roundUpToPowerOf2</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">    <span class="comment">//计算 &gt;= 传入的数组长度的最小2的幂次放数</span></span><br><span class="line">    <span class="comment">//也就是说我们计算一个最小的2的幂次方数,这个幂次方数要大于数组的长度</span></span><br><span class="line">    <span class="comment">//Integer.highestOneBit计算的是&lt;=传入值的最大的2的幂次方数</span></span><br><span class="line">    <span class="comment">//所以为了达到我们的目的,我们要将传入的值翻倍</span></span><br><span class="line">    <span class="comment">//但为什么要-1,为了保证数据不出错,如果数组长度是16,不-1的话,实际传入的数是32,那调用方法计算出来的值也是32,和我们预想的结果16不一致.</span></span><br><span class="line">    <span class="comment">//如果数组长度为16,就返回16</span></span><br><span class="line">    <span class="comment">//17 ==&gt; 32</span></span><br><span class="line">    <span class="comment">//14 ==&gt; 16</span></span><br><span class="line">    <span class="comment">// 2 ==&gt; 16</span></span><br><span class="line">    <span class="comment">// 32 ==&gt; 32</span></span><br><span class="line">    <span class="comment">// 33 ==&gt; 64</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">        ? MAXIMUM_CAPACITY</span><br><span class="line">        : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②null处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">putForNullKey</span><span class="params">(V value)</span> &#123;</span><br><span class="line">    <span class="comment">//将key值为null的元素放在引用数组的第一个位置</span></span><br><span class="line">    <span class="comment">//遍历下标0中的链表,找key为null的元素,找到则覆盖,并且把旧值返回</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//没有找到则将新元素添加到下标0的链表的第一个位置,头插</span></span><br><span class="line"><span class="comment">//key为null的元素的hash默认为0</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="literal">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③计算hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//先对key值本身的hashCode进行计算</span></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为对象本身的hash值很可能相同,所以我们需要进行二次hash运算</span></span><br><span class="line">    <span class="comment">//进行一串的异或运算和与运算,我们称为&quot;扰动函数&quot;</span></span><br><span class="line">    <span class="comment">//&quot;扰动函数&quot;的目的是为了降低hash值的冲突,是哈希码更加均匀</span></span><br><span class="line">    <span class="comment">// 4次位运算 + 5次异或运算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//20和12不一定要固定,只要和为32就行,目的都是为了洗牌</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④计算元素的下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">//用引用数组的长度-1 和 哈希值 进行与运算</span></span><br><span class="line">    <span class="comment">//为了保证运算的结果在[0,length]之间</span></span><br><span class="line">    <span class="comment">//所以我们之前对数组的长度计算的时候需要时结果为2的幂次方数,保证二进制码只有一个1</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑤添加操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入参数1.哈希码 2.键 3.值 4.新元素下标</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//如果当前元素个数大于阈值 并且 新元素所在数组下标有数据不为null ==&gt;则我们要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">//1.创建新的扩容后的引用数组,将原数组的数据赋值给新数组</span></span><br><span class="line">        <span class="comment">//2.重新计算扩容阈值</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">//重新计算hash值</span></span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//重新计算新元素的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//开始添加</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//保存旧的数组</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="comment">//保存旧数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="comment">//如果旧数组的长度已经到达了最大长度,则将阈值设置为整型的最大值,然后结束退出</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建新的数组,长度为旧数组的两倍</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    <span class="comment">//将旧数组上的数据转移到新数组上</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    <span class="comment">//table的引用指向新的数组上</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">//重新计算阈值并设置</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组转移</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="comment">//新数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="comment">//遍历旧数组table,然后一个一个迁移</span></span><br><span class="line">    <span class="comment">//如果这里涉及到多线程操作的话,可能会出现循环链表,线程会不安全</span></span><br><span class="line">    <span class="comment">//为什么不直接迁移,还要遍历各个链表中的元素,是为了让以前的链表尽量的散列到不用的位置上去</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">//重新hash,一般不用</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算各个元素的下标,迁移</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用头插法进行元素添加</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//保存链表头节点Entry</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">//将新插入节点的next设置为原头节点,原头节点则会变为新头节点的下一个节点,从而形成新的链表</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">//元素个数+1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="读取Get方法"><a href="#读取Get方法" class="headerlink" title="读取Get方法"></a>读取Get方法</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> == entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/archives/66c016fb.html"/>
      <url>/archives/66c016fb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-JVM概述"><a href="#1-JVM概述" class="headerlink" title="1.JVM概述"></a>1.JVM概述</h2><blockquote><p>JVM：Java Virtual Machine，翻译过来是Java虚拟机</p></blockquote><h3 id="JDK、JRE、JVM关系"><a href="#JDK、JRE、JVM关系" class="headerlink" title="JDK、JRE、JVM关系"></a>JDK、JRE、JVM关系</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK: Java开发工具包==&gt;JRE+Java开发辅助工具</span><br><span class="line">JRE: Java运行环境==&gt;JVM+Java运行时类库</span><br></pre></td></tr></table></figure></blockquote><h3 id="JVM工作机制"><a href="#JVM工作机制" class="headerlink" title="JVM工作机制"></a>JVM工作机制</h3><blockquote><p>编译过程</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java源文件(.java)→编译→字节码文件(.class)→放到JVM上运行</span><br></pre></td></tr></table></figure><p>工作机制</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.使用功能区的类加载器将编译好的字节码文件加载到JVM内存中</span><br><span class="line">2.在JVM内存空间存储相关的数据(方法区,堆,栈,本地方法栈)</span><br><span class="line">3.使用功能区的执行引擎将字节码文件翻译为机器能懂的机器码,也就是一个个CPU执行指令</span><br><span class="line">4.执行引擎将执行指令发送个CPU执行</span><br></pre></td></tr></table></figure></blockquote><h3 id="JVM内存架构"><a href="#JVM内存架构" class="headerlink" title="JVM内存架构"></a>JVM内存架构</h3><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209131843770.png" alt="JVM"></p><p>内存区域划分</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.功能区</span><br><span class="line">类加载器</span><br><span class="line">执行引擎</span><br><span class="line">垃圾回收机制GC</span><br><span class="line">2.线程私有区域</span><br><span class="line">线程栈</span><br><span class="line">本地方法栈</span><br><span class="line">程序计数器</span><br><span class="line">3.线程共享区域</span><br><span class="line">堆</span><br><span class="line">方法区(1.7永久代,1.8元空间)</span><br><span class="line">直接内存(堆外内存)</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-功能区"><a href="#2-功能区" class="headerlink" title="2.功能区"></a>2.功能区</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><blockquote><p>ClassLoader: 加载字节码文件</p></blockquote><blockquote><p>分类</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.启动类加载器(Bootstrap)</span><br><span class="line">=&gt;由C++编写,所以Java环境下看不到,加载JRE/lib/*.jar中的核心类库</span><br><span class="line">2.扩展类加载器(Extension)</span><br><span class="line">==&gt;由Java编写,加载的是JRE/lib/ext/*.jar</span><br><span class="line">3.应用类加载器(AppClassLoader)</span><br><span class="line">==&gt;也叫系统类加载器,负责加载classpath中指定的jar包及目录中的class</span><br><span class="line">4.自定义加载器()</span><br><span class="line">==&gt;程序员自己开发一个类继承 java.lang.ClassLoader，定制类加载方式</span><br></pre></td></tr></table></figure><p>类加载器之间的关系</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上下级关系</span><br></pre></td></tr></table></figure><p>双亲委派机制</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209131900441.png" alt="img002.cb2a07a4"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.加载某一范围的类的时候,会找到范围对应的类加载器</span><br><span class="line">2.对应的类加载器不会立马开始查找这个类,会将任务交给上一级类加载器</span><br><span class="line">3.上级类加载器将任务继续上交,直到任务给到了启动类加载器</span><br><span class="line">4.启动类开始在自己复制的范围内查找,找到则加载,否则交给下一级类加载器</span><br><span class="line">5.下一级类加载器同上</span><br><span class="line">6.知道重新交给应用类加载器上,应用类加载器也找不到则抛出异常(ClassNotFoundException)</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">1.保护Java核心.class不被篡改(沙箱安全机制)</span><br><span class="line">2.避免重复加载: 父加载器加载了,就不必让子加载器再加载,也保证了类的全类名是唯一标识</span><br></pre></td></tr></table></figure></blockquote><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><blockquote><p>作用</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将字节码转换为机器码,即一条条Cpu指令</span><br></pre></td></tr></table></figure><p>分类</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.解释型</span><br><span class="line">==&gt;执行效率低,一代JVM</span><br><span class="line">2.即时编译型</span><br><span class="line">==&gt;JIT,二代JVM</span><br><span class="line">3.混合型(Java默认引擎)</span><br><span class="line">==&gt;汲取一代二代经验,一开始对代码进行解释,若一段代码被频繁调用,则对此代码进行即时编译,热度降后,取消即使编译</span><br></pre></td></tr></table></figure></blockquote><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><blockquote><p>Stop-The-World</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stop-The-World：字面意思让整个世界停止。在 GC 机制中，Stop-The-World 表示挂起整个 JVM 程序，等执行完垃圾回收之后，再继续执行 JVM 程序。Stop-The-World 通常也会简称为 STW。</span><br></pre></td></tr></table></figure></blockquote><h4 id="基本算法-四个"><a href="#基本算法-四个" class="headerlink" title="基本算法(四个)"></a>基本算法(四个)</h4><blockquote><p>概述</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;意为垃圾回收,释放不再使用的内存空间,清理不再使用的对象</span><br><span class="line">2.为什么</span><br><span class="line">==&gt;不清理可能会导致内存耗尽,通过GC,把不需要占用内存清理,释放空间,让项目持续的运行</span><br><span class="line">3.垃圾对象是什么</span><br><span class="line">==&gt;不再使用,或获取不到的对象就是垃圾对象</span><br></pre></td></tr></table></figure><p>引用计数法</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;在对象t中分配一个空间来保存对象被引用的次数</span><br><span class="line">==&gt;如果对象被引用,则引用次数+1</span><br><span class="line">==&gt;如果删除对象引用,则引用次数-1</span><br><span class="line">==&gt;当对象引用次数为0时,则对象会被回收</span><br><span class="line">2.优点</span><br><span class="line">==&gt;比较实时,不用等到内存不够才回收</span><br><span class="line">==&gt;不用STW,不影响程序的正常运行</span><br><span class="line">3.缺点：</span><br><span class="line">==&gt;回收时不STW会造成内存碎片问题.</span><br><span class="line">==&gt;不能解决对象间的循环引用问题</span><br><span class="line">4.小结：</span><br><span class="line">==&gt;正是由于引用计数法不能解决对象间的循环引用问题，所以事实上并没有哪一款 JVM 产品采用这个机制。</span><br></pre></td></tr></table></figure><p>标记清除法(老年代)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;当堆中的有效内存被耗尽时触发</span><br><span class="line">==&gt;进行STW,标记存活的对象</span><br><span class="line">==&gt;遍历堆中所有的对象,清除没被标记的对象</span><br><span class="line">2.优点</span><br><span class="line">==&gt;实现比较简单</span><br><span class="line">3.缺点</span><br><span class="line">==&gt;应为要遍历所以对象,所以效率低</span><br><span class="line">==&gt;只是清除了垃圾对象,没有重新排列,容易造成内存碎片</span><br><span class="line">==&gt;STW时,程序要暂时挂起,停止运行</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209132047345.png" alt="image-20220913204726272"></p><p>标记压缩法(老年代)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;在标记清除的基础上做优化,在清理阶段,不是简单的清理未标记的对象</span><br><span class="line">==&gt;将标记的对象移动到内存一段,然后清理标记对象边界以外的垃圾</span><br><span class="line">2.优点</span><br><span class="line">==&gt;解决了碎片化的问题</span><br><span class="line">3.缺点</span><br><span class="line">==&gt;效率比标记清除法都慢</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209132057906.png" alt="image-20220913205702840"></p><p>复制算法(年轻代)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">==&gt;将原有的内存空间一分为二,每次只有其中一块</span><br><span class="line">==&gt;将存活的对象复制到另一块内存空间,并排列,然后将此块内存空间清空</span><br><span class="line">2.优点</span><br><span class="line">==&gt;年轻代垃圾较多的时候,效率会高很多</span><br><span class="line">==&gt;没有内存碎片</span><br><span class="line">3.缺点</span><br><span class="line">==&gt;浪费了一块内存的空间</span><br><span class="line">==&gt;老年代垃圾较少的时候,效率比较差</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209132103775.png" alt="image-20220913210327657"></p></blockquote><h4 id="综合算法-两个"><a href="#综合算法-两个" class="headerlink" title="综合算法(两个)"></a>综合算法(两个)</h4><blockquote><p>分代算法</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;1.每个算法都有自己的优缺点,不能互相替代.</span><br><span class="line">&gt;2.对不同的垃圾对象选择不同的算法是正确的</span><br><span class="line">&gt;3.新生代适合使用复制算法</span><br><span class="line">&gt;4.老年代适合使用标记清除或标记压缩算法</span><br></pre></td></tr></table></figure><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209132111051.png" alt="image-20220913211113991"></p><p>分区算法</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;1.因为随着堆内存空间的增大,一次GC的时间也会越长,GC产生的停顿时间也约长</span><br><span class="line">&gt;2.为了更好的控制停顿时间,将堆空间划分不同的小区间,每个小区间独立使用,独立回收</span><br><span class="line">&gt;3.不是回收整个堆空间,所以减少一次停顿所消耗的时间</span><br></pre></td></tr></table></figure></blockquote><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="串行垃圾回收器"><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h5><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;在一个线程内执行垃圾回收操作</span><br><span class="line"></span><br><span class="line">年轻代用复制算法、老年代用标记压缩法</span><br></pre></td></tr></table></figure><p>SerialGC[新生]</p><p>SerialOldGC[老年]</p></blockquote><h5 id="并行垃圾回收器"><a href="#并行垃圾回收器" class="headerlink" title="并行垃圾回收器"></a>并行垃圾回收器</h5><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;在多个线程中执行垃圾回收操作</span><br><span class="line"></span><br><span class="line">年轻代用复制算法、老年代用标记压缩法</span><br></pre></td></tr></table></figure><p>ParNew[新生]</p><p>ParallelScavengeGC[新生]</p><p>ParallelOldGC[老年]</p></blockquote><h5 id="G1回收器-好用"><a href="#G1回收器-好用" class="headerlink" title="G1回收器[好用]"></a>G1回收器[好用]</h5><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G1(Garbage-First)是并发垃圾回收器, 主要目标用于配备多颗CPU的服务器，治理大内存。是JDK1.7提供的一个新收集器，是当今收集器技术发展的最前沿成果之一。</span><br><span class="line"></span><br><span class="line">G1将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了, 它们都是一部分Region(不需要连续)的集合。</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.优先回收垃圾多的区域(Region)</span><br><span class="line">2.保证了在有效的时间内达到更高的效率</span><br><span class="line"></span><br><span class="line">特点</span><br><span class="line">1.一整块堆内存被分成多个独立的区域Regions</span><br><span class="line">2.存活对象被拷贝到新的Survivor区</span><br><span class="line">3.新生代内存由一组不连续的堆heap区组成，使得可以动态调整各个区域</span><br><span class="line">4.多线程并发GC</span><br><span class="line">5.young GC会有STW</span><br></pre></td></tr></table></figure></blockquote><h5 id="垃圾回器对比"><a href="#垃圾回器对比" class="headerlink" title="垃圾回器对比"></a>垃圾回器对比</h5><blockquote><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209141950404.png" alt="image-20220914195010322"></p></blockquote><h2 id="3-线程私有区域"><a href="#3-线程私有区域" class="headerlink" title="3.线程私有区域"></a>3.线程私有区域</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用来保存下一条要执行的CPU指令的地址</span><br></pre></td></tr></table></figure><h5 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h5><p>方法栈帧</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.方法出口</span><br><span class="line">谁引用此方法,存储谁的地址</span><br><span class="line">2.动态链接</span><br><span class="line">存储指向方法区对应方法的地址</span><br><span class="line">3.操作数栈</span><br><span class="line">临时的空间,存储计算,复制等操作用到的操作数</span><br><span class="line">4.局部变量表</span><br><span class="line">储存方法参数,和局部变量</span><br></pre></td></tr></table></figure><p>main方法栈帧</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.局部变量表</span><br></pre></td></tr></table></figure><h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">native修饰的方法形成的栈</span><br></pre></td></tr></table></figure></blockquote><h2 id="4-线程公有区域"><a href="#4-线程公有区域" class="headerlink" title="4.线程公有区域"></a>4.线程公有区域</h2><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote><p>具体实现</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.=  1.7 永久代</span><br><span class="line">2.&gt;= 1.8元空间（Meta Space）</span><br><span class="line"></span><br><span class="line">区别</span><br><span class="line">1.永久代向JVM申请内存空间,元空间直接向内存申请空间</span><br><span class="line">2.永久代存在字符串常量池,元空间不存在字符串常量池</span><br></pre></td></tr></table></figure><p>元空间</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.类信息：类中定义的构造器、接口定义</span><br><span class="line">2.静态变量</span><br><span class="line">3.常量</span><br><span class="line">4.运行时常量池</span><br><span class="line">5.类中方法的代码</span><br></pre></td></tr></table></figure></blockquote><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote><p>数据结构</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.对象</span><br><span class="line">2.数组</span><br></pre></td></tr></table></figure><p>空间结构</p><p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209141911452.png" alt="image-20220914191127362"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.新生代(堆内存1/3)</span><br><span class="line">&gt;.Eden区[伊甸园区](新生代8/10)</span><br><span class="line">&gt;.幸存者区(新生代2/10)</span><br><span class="line">==&gt;Survivor0(From)</span><br><span class="line">==&gt;Survivor1(To)</span><br><span class="line">2.老年代(堆内存2/3)</span><br><span class="line">3.永久代[非堆]</span><br></pre></td></tr></table></figure><p>工作机制</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.新创建的对象会放在Eden区</span><br><span class="line">2.当Eden区使用的空间到达了一定的比例,会触发MinorGC清除垃圾对象,剩下来的对象被称为幸存者</span><br><span class="line">3.幸存者会被转移到幸存者区(幸存者区将会轮转清空,重新和Eden区对象组合一起重新排列)</span><br><span class="line">4.如果一个对象15次GC还幸存,转移到老年区</span><br><span class="line">5.如果幸存者区满了,Eden区的幸存者会转移到老年区</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.Eden区主要是生命周期很短的对象来来往往</span><br><span class="line">2.老年代主要是生命周期很长的对象，例如：IOC容器对象、线程池对象、数据库连接池对象等等</span><br><span class="line">3.幸存者区作为二者之间的过渡地带</span><br><span class="line"></span><br><span class="line">关于永久代</span><br><span class="line">从理论上来说属于堆</span><br><span class="line">从具体实现上来说不属于堆</span><br></pre></td></tr></table></figure></blockquote><h3 id="直接内存-堆外内存"><a href="#直接内存-堆外内存" class="headerlink" title="直接内存(堆外内存)"></a>直接内存(堆外内存)</h3><blockquote><p>含义</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接去内存条申请的内存,仅供NIO使用</span><br></pre></td></tr></table></figure></blockquote><h2 id="5-优化"><a href="#5-优化" class="headerlink" title="5.优化"></a>5.优化</h2><h3 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h3><blockquote><p>堆</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.majorGC(针对年轻代) 一两个月一次，如果业务量比较大，majorGC最少也要几天一次GC</span><br><span class="line">2.minorGC(针对老年代) 几个小时发生一次</span><br><span class="line">3.年轻代占整个堆的3/8,可以在附近微调</span><br></pre></td></tr></table></figure><p>元空间</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.8G内存，建议将元空间设置为256M，随着服务器内存大小的变化，元空间依次按比例变化即可.</span><br></pre></td></tr></table></figure></blockquote><h3 id="GC-1"><a href="#GC-1" class="headerlink" title="GC"></a>GC</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.选择合适的垃圾回收器：G1</span><br><span class="line">2.调节并行垃圾回收的线程数：和cpu的核数保持一致</span><br></pre></td></tr></table></figure></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.尽量使用StringBuffer、StringBuilder</span><br><span class="line">2.对于大对象用完及时释放、Connection、FIS、FOS、Map、List</span><br><span class="line">3.尽量少使用try...catch，尤其是不要在for循环内部使用try...catch</span><br></pre></td></tr></table></figure></blockquote><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.加内存</span><br><span class="line">2.选择合适磁盘[固态、机械]</span><br><span class="line">3.选择合适的CPU</span><br></pre></td></tr></table></figure></blockquote><h2 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6.面试题"></a>6.面试题</h2><h3 id="谈谈你对JVM的理解"><a href="#谈谈你对JVM的理解" class="headerlink" title="谈谈你对JVM的理解"></a>谈谈你对JVM的理解</h3><blockquote><blockquote><ul><li>JVM 技术的作用：提升、优化项目性能</li><li>JVM 结构<ul><li>类加载机制</li><li>Java栈</li><li>堆<ul><li>新生代<ul><li>Eden 区</li><li>幸存者区：S0+S1</li></ul></li><li>老年代</li></ul></li><li>元空间</li></ul></li><li>GC<ul><li>垃圾对象的标记<ul><li>引用技术法</li><li>GC Roots：概念→原理（堆外指向堆内）→GC Root 对象</li></ul></li><li>垃圾回收算法</li></ul></li><li>JVM 常用参数</li></ul></blockquote></blockquote><h3 id="Java-8-的虚拟机有什么更新"><a href="#Java-8-的虚拟机有什么更新" class="headerlink" title="Java 8 的虚拟机有什么更新"></a>Java 8 的虚拟机有什么更新</h3><blockquote><blockquote><ul><li>永久代取消，变成元空间；</li><li>常量池放入到元空间，但是一直都是在方法区中</li></ul></blockquote></blockquote><h3 id="什么是OOM"><a href="#什么是OOM" class="headerlink" title="什么是OOM"></a>什么是OOM</h3><blockquote><blockquote><ul><li>概念：堆内存溢出错误</li><li>全类名：java.lang.OutofMemoryError</li><li>产生原因：经过多轮 GC，连老年代都已经没了空间，还要继续创建新的对象。</li><li>详细过程：堆空间对象存储、GC 流程。</li><li>相关拓展：StackOverFlowError</li></ul></blockquote></blockquote><h3 id="什么是StackOverflowError"><a href="#什么是StackOverflowError" class="headerlink" title="什么是StackOverflowError"></a>什么是StackOverflowError</h3><blockquote><blockquote><ul><li>概念：栈内存溢出错误</li><li>产生原因：在一个线程中，栈内存分配给它的空间被不断新增的栈帧填满，没有及时释放栈帧。</li><li>详细过程：栈帧概念，栈帧中存储的数据，典型情况（无法退出的递归）</li><li>相关拓展：OOM</li></ul></blockquote></blockquote><h3 id="JVM-的常用参数调优你知道哪些"><a href="#JVM-的常用参数调优你知道哪些" class="headerlink" title="JVM 的常用参数调优你知道哪些?"></a>JVM 的常用参数调优你知道哪些?</h3><blockquote><blockquote><table><thead><tr><th>参数名</th><th>参数作用</th></tr></thead><tbody><tr><td>-Xms</td><td>★堆内存的初始大小</td></tr><tr><td>-Xmx</td><td>★堆内存的最大值（最多能够向操作系统申请多少）</td></tr><tr><td>-Xmn</td><td>新生代大小</td></tr><tr><td>-XX:PermSize</td><td>设置永久代(perm gen)初始值</td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td></tr></tbody></table></blockquote></blockquote><h3 id="谈谈-JVM-中，对类加载器你的认识"><a href="#谈谈-JVM-中，对类加载器你的认识" class="headerlink" title="谈谈 JVM 中，对类加载器你的认识"></a>谈谈 JVM 中，对类加载器你的认识</h3><blockquote><blockquote><p>双亲委派机制</p><ul><li>类加载器分类<ul><li>启动类加载器</li><li>扩展类加载器</li><li>应用类加载器</li><li>自定义加载器</li></ul></li><li>父子关系<ul><li>关系一：启动类加载器是扩展类加载器的父亲</li><li>关系二：扩展类加载器是应用类加载器的父亲</li></ul></li><li>查找机制：先让父加载器查找，如果找不到再让子加载器加载</li><li>好处<ul><li>好处1：避免重复操作</li><li>好处2：避免恶意替换核心 API</li></ul></li></ul></blockquote></blockquote><h3 id="堆内存空间大小设置的建议"><a href="#堆内存空间大小设置的建议" class="headerlink" title="堆内存空间大小设置的建议"></a>堆内存空间大小设置的建议</h3><blockquote><blockquote><ul><li>最大堆内存和初始化堆内存设置为一致：直接一步到位设置为能够使用的最大值，免除频繁申请空间的操作。<ul><li>空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制</li><li>空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</li></ul></li><li>新生代大小：Sun官方推荐配置为整个堆的 3/8</li></ul></blockquote></blockquote><h3 id="Java-栈每个线程占用空间大小如何设置"><a href="#Java-栈每个线程占用空间大小如何设置" class="headerlink" title="Java 栈每个线程占用空间大小如何设置"></a>Java 栈每个线程占用空间大小如何设置</h3><blockquote><blockquote><p>JDK5.0 以后每个线程所占用的栈内存大小为 1M，以前是 256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。一般小的应用， 如果栈不是很深， 应该是128k够用的。大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。</p></blockquote></blockquote><h3 id="JVM内存分哪几个区，每个区的作用是什么"><a href="#JVM内存分哪几个区，每个区的作用是什么" class="headerlink" title="JVM内存分哪几个区，每个区的作用是什么?"></a>JVM内存分哪几个区，每个区的作用是什么?</h3><blockquote><blockquote><p><strong>（1****）方法区</strong>：</p><p>   a. 有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载</p><p>   b. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。</p><p>   c. 该区域是被线程共享的。</p><p>   d. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</p><p><strong>（2****）虚拟机栈</strong>: </p><p>   a. 虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</p><p>   b. 虚拟机栈是线程私有的，它的生命周期与线程相同。</p><p>   c. 局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定</p><p>   d. 操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</p><p>   e. 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</p><p><strong>（3****）本地方法栈</strong>：<br> 本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。</p><p><strong>（4****）堆</strong>：</p><p>java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。</p><p><strong>（2）****程序计数器：</strong></p><p>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。</p></blockquote></blockquote><h3 id="Java中垃圾收集的方法有哪些"><a href="#Java中垃圾收集的方法有哪些" class="headerlink" title="Java中垃圾收集的方法有哪些?"></a>Java中垃圾收集的方法有哪些?</h3><blockquote><blockquote><p>采用分区分代回收思想：</p><p><strong>1****）复制算法</strong> 年轻代中使用的是Minor GC，这种GC算法采用的是复制算法(Copying)</p><p>a) 效率高，缺点：需要内存容量大，比较耗内存</p><p>b) 使用在占空间比较小、刷新次数多的新生区</p><p><strong>2****）标记-清除</strong> 老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p><p>a) 效率比较低，会差生碎片。</p><p><strong>3****）标记-整理</strong> 老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p><p>a) 效率低速度慢，需要移动对象，但不会产生碎片。</p></blockquote></blockquote><h3 id="如何判断一个对象是否存活-或者GC对象的判定方法"><a href="#如何判断一个对象是否存活-或者GC对象的判定方法" class="headerlink" title="如何判断一个对象是否存活?(或者GC对象的判定方法)"></a>如何判断一个对象是否存活?(或者GC对象的判定方法)</h3><blockquote><blockquote><p>判断一个对象是否存活有两种方法: </p><p><strong>（1****）引用计数法</strong></p><p>所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收. </p><p>引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。</p><p>*<em>（2</em>***）可达性算法(**<strong>引用链法)</strong> </p><p>该算法的基本思路就是通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。</p><p>在java中可以作为GC Roots的对象有以下几种：虚拟机栈中引用的对象、方法区类静态属性引用的对象、方法区常量池引用的对象、本地方法栈JNI引用的对象。</p></blockquote></blockquote><h3 id="Java类加载过程"><a href="#Java类加载过程" class="headerlink" title="Java类加载过程?"></a>Java类加载过程?</h3><blockquote><blockquote><p>Java类加载需要经历一下几个过程：</p><p><strong>（1****）加载</strong></p><p>加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：</p><p>   a. 通过一个类的全限定名获取该类的二进制流。</p><p>   b. 将该二进制流中的静态存储结构转化为方法去运行时数据结构。 </p><p>   c. 在内存中生成该类的Class对象，作为该类的数据访问入口。</p><p><strong>（2****）验证</strong></p><p>验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证: </p><p>   a. 文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型. </p><p>   b. 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</p><p>   c. 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</p><p>   d. 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</p><p>   e. 准备</p><p>准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><p><strong>（3****）解析</strong></p><p>该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。</p><p><strong>（4****）初始化</strong></p><p>初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</p></blockquote></blockquote><h3 id="简述java内存分配与回收策略以及Minor-GC和Major-GC（full-GC）"><a href="#简述java内存分配与回收策略以及Minor-GC和Major-GC（full-GC）" class="headerlink" title="简述java内存分配与回收策略以及Minor GC和Major GC（full GC）"></a>简述java内存分配与回收策略以及Minor GC和Major GC（full GC）</h3><blockquote><blockquote><p><strong>内存分配：</strong></p><p><strong>（1****）栈区</strong>：栈分为java虚拟机栈和本地方法栈</p><p><strong>（2****）堆区</strong>：堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，主要放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。</p><p><strong>（3****）方法区</strong>：被所有线程共享区域，用于存放已被虚拟机加载的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（permanment generation）</p><p><strong>（4****）程序计数器</strong>：当前线程所执行的行号指示器。通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。线程私有的。</p><p><strong>回收策略以及Minor GC<strong><strong>和Major GC</strong></strong>：</strong></p><p>（1）对象优先在堆的Eden区分配。</p><p>（2）大对象直接进入老年代。</p><p>（3）长期存活的对象将直接进入老年代。</p><p>当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
