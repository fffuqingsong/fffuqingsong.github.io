<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JUC | 小`白松</title><meta name="keywords" content="JUC"><meta name="author" content="FuQingSong"><meta name="copyright" content="FuQingSong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JUC">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC">
<meta property="og:url" content="https://fuqingsong.work/archives/aa55683f.html">
<meta property="og:site_name" content="小&#96;白松">
<meta property="og:description" content="JUC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ffuqingsong.gitee.io/pic-go-demo/img/202209211939330.png">
<meta property="article:published_time" content="2022-09-21T05:05:00.000Z">
<meta property="article:modified_time" content="2022-09-21T05:05:00.000Z">
<meta property="article:author" content="FuQingSong">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ffuqingsong.gitee.io/pic-go-demo/img/202209211939330.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://fuqingsong.work/archives/aa55683f"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="code-acDj6daLN5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-21 13:05:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-house-chimney-crack"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-pallet"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小`白松</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-house-chimney-crack"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-pallet"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JUC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-21T05:05:00.000Z" title="发表于 2022-09-21 13:05:00">2022-09-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-21T05:05:00.000Z" title="更新于 2022-09-21 13:05:00">2022-09-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="程序-进程-线程"><a href="#程序-进程-线程" class="headerlink" title="程序 进程 线程"></a>程序 进程 线程</h3><blockquote>
<p>程序 </p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.静态的概念</span><br><span class="line">2.源程序,应用程序,都可笼统的称为程序</span><br></pre></td></tr></table></figure>

<p>进程 </p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.动态的概念</span><br><span class="line">2.程序运行起就是一个进程</span><br><span class="line">3.QQ,WChat,都是一个个进程</span><br></pre></td></tr></table></figure>

<p>线程</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.一个进程中有多个任务,每单独的一个任务需要一个线程来处理</span><br><span class="line">2.笼统的可以称为进程是线程的容器</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="串行-并行-并发"><a href="#串行-并行-并发" class="headerlink" title="串行 并行 并发"></a>串行 并行 并发</h3><blockquote>
<p>串行</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个线程执行多个操作,多个操作要排队等待执行</span><br></pre></td></tr></table></figure>

<p>并行 </p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多个CPU核同时执行多个任务,核数和任务数一一对应</span><br></pre></td></tr></table></figure>
<p>并发<br> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单个CPU核同时执行多个任务</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="sleep-和wait-区别"><a href="#sleep-和wait-区别" class="headerlink" title="sleep()和wait()区别"></a>sleep()和wait()区别</h3><blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.sleep()会让线程拿着锁去睡</span><br><span class="line">2.wait()会让线程放开锁去睡</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="多线程创建"><a href="#多线程创建" class="headerlink" title="多线程创建"></a>多线程创建</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><blockquote>
<p>步骤</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.继承 Thread 类</span><br><span class="line">2.重写 run() 方法</span><br><span class="line">3.创建 Thread 子类对象</span><br><span class="line">4.调用 start() 方法启动线程</span><br></pre></td></tr></table></figure>

<p>实现代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoThread</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoThread</span>(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">        demo.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoThread</span><span class="params">(String threadName)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(threadName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; thread working ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><blockquote>
<p> 实现 Runnable 接口形式</p>
 <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure>

<p> 匿名内部类形式</p>
 <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure>

<p> Lambda 表达式形式</p>
 <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><blockquote>
<p>步骤</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.使用Executors.newFixedThreadPool(线程池数量)创建ExecutorService对象</span><br><span class="line">2.使用ExecutorService对象的execute()分配任务,每个任务就是一个线程</span><br><span class="line">3.execute()方法参数实现Runnable接口,写具体的线程操作.</span><br></pre></td></tr></table></figure>

<p>参考代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建线程池对象</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.给线程池对象分配任务，每一个任务是一个线程</span></span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="FutureTask-Callable"><a href="#FutureTask-Callable" class="headerlink" title="FutureTask+Callable"></a>FutureTask+Callable</h3><blockquote>
<p>和Runnable区别</p>
<p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209151508761.png" alt="image-20220915150859690"></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.我们直接再new Thread()的第一个参数中实现Runnable接口,在接口中写线程执行的操作,这样我们拿不到线程执行后的结果,因为Runnable接口中的run方法是没有返回值的</span><br><span class="line">2.Callable接口中的call方法是可以指定返回值的</span><br></pre></td></tr></table></figure>

<p>FutureTask 类的构造器</p>
<p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209151511941.png" alt="image-20220915151124892"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="built_in">this</span>.callable = callable;</span><br><span class="line">  <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据这个构造器，我们知道，创建 FutureTask 对象时，传入一个 Callable 类型的对象即可</span></span><br></pre></td></tr></table></figure>

<p>Callable 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从 call() 方法的声明我们可以看出，它有一个返回值。这个返回值可以将当前线程内计算结果返回</span></span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建三个FutureTask对象，封装三个线程的执行逻辑</span></span><br><span class="line">FutureTask&lt;Integer&gt; task01 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * Math.random() * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line">FutureTask&lt;Integer&gt; task02 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * Math.random() * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line">FutureTask&lt;Integer&gt; task03 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * Math.random() * <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建三个线程对象，然后启动线程</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task01, <span class="string">&quot;thread01&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task02, <span class="string">&quot;thread02&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task03, <span class="string">&quot;thread03&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.上面三个线程执行完成后，可以收集它们各自运算的结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">task01Result</span> <span class="operator">=</span> task01.get();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">task02Result</span> <span class="operator">=</span> task02.get();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">task03Result</span> <span class="operator">=</span> task03.get();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;task01Result = &quot;</span> + task01Result);</span><br><span class="line">System.out.println(<span class="string">&quot;task02Result = &quot;</span> + task02Result);</span><br><span class="line">System.out.println(<span class="string">&quot;task03Result = &quot;</span> + task03Result);</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明成员变量维护票库存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line">    <span class="comment">// 变量类型：java.util.concurrent.locks.Lock 接口</span></span><br><span class="line">    <span class="comment">// 对象类型：Lock 接口的最常用的实现类 ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明卖票的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saleTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            lock.lock(); <span class="comment">// synchronized (this) &#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 卖票的核心操作</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖了一张，还剩 &quot;</span> + --stock + <span class="string">&quot; 张票。&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖完了。&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock(); <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建当前类对象</span></span><br><span class="line">        <span class="type">Demo01HelloWorld</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo01HelloWorld</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开启三个线程调用卖票方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                demo.saleTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-01&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                demo.saleTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-02&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                demo.saleTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-03&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.确保锁被释放</span><br><span class="line"></span><br><span class="line">使用 Lock API 实现同步操作，是一种面向对象的编码风格。这种风格有很大的灵活性，同时可以在常规操作的基础上附加更强大的功能。但是也要求编写代码更加谨慎：如果忘记调用 lock.unlock() 方法则锁不会被释放，从而造成程序运行出错。</span><br><span class="line"></span><br><span class="line">2.加锁和解锁操作对称执行</span><br><span class="line"></span><br><span class="line">不管同步操作是一层还是多层，有多少个加锁操作，就应该相应的有多少个解锁操作。</span><br><span class="line"></span><br><span class="line">3.避免锁对象的线程私有化</span><br><span class="line"></span><br><span class="line">锁对象如果是线程内部自己创建的，是自己独占的，其它线程访问不到这个对象，那么这个锁将无法实现『排他』效果，说白了就是：锁不住。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>void lock()</td>
<td>加同步锁，如果没有得到锁会一直等</td>
</tr>
<tr>
<td>void unlock()</td>
<td>解除同步锁</td>
</tr>
<tr>
<td>boolean tryLock()</td>
<td>尝试获取锁。如果没有获取到则立即返回，不做任何等待<br>返回 true：表示获取成功  <br>返回 false：表示获取失败</td>
</tr>
<tr>
<td>boolean tryLock(long time, TimeUnit unit)</td>
<td>尝试获取锁，且等待指定时间<br>返回 true：表示获取成功  <br>返回 false：表示获取失败</td>
</tr>
<tr>
<td>void lockInterruptibly()</td>
<td>以『支持响应中断』的模式获取锁</td>
</tr>
<tr>
<td>Condition newCondition()</td>
<td>获取用于线程间通信的 Condition 对象</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全类名：java.util.concurrent.locks.ReentrantLock</span><br><span class="line"></span><br><span class="line">这是 Lock 接口最典型、最常用的一个实现类。</span><br></pre></td></tr></table></figure>

<p>基本用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.将解锁操作lock.unlock()放在finally&#123;&#125;中</span></span><br><span class="line"><span class="comment">//2.加锁和解锁的操作要对称,加速后一定要解锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步代码部分</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证可重入性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;外层加锁成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;内层加锁成功&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;内层解锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;外层解锁成功&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><blockquote>
<p>概念</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.在实际的开发场景中,线程的读操作不会改变数据的值,所以多个线程进行读操作是不会存在线程安全问题的</span><br><span class="line">2.但如果很多个线程同时在进行读操作,一个线程来进行写操作时,就不应该允许其他线程进行任何操作</span><br><span class="line"></span><br><span class="line">实现</span><br><span class="line">1.Java并发包java.util.concurrent下提供了读写锁ReentrantReadWriteLock</span><br><span class="line">2.它表示了两个锁,一个读锁(共享锁),一个写锁(独占锁,互斥锁,排它锁)</span><br></pre></td></tr></table></figure>

<p>重要特性</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.公平选择性</span><br><span class="line">支持公平和非公平锁,默认非公平锁,因为非公平锁的吞吐量高</span><br><span class="line">2.重进入</span><br><span class="line">两个锁都单方面的支持线程的可重入性</span><br><span class="line">一个线程中加读锁后还能继续加读锁</span><br><span class="line">一个线程中加写锁后还能继续加写锁</span><br><span class="line">3.锁降级</span><br><span class="line">一个线程中,读锁不能升级为写锁</span><br><span class="line">一个线程中,写锁可以降级为读锁</span><br><span class="line"></span><br><span class="line">提示</span><br><span class="line">1.一个线程占用了读锁,另外的一个线程如果想要申请写锁的话,要等读锁的这个线程将读锁释放才行,但另外一个线程想申请读锁的话时可以的.</span><br><span class="line">2.一个线程占用了写锁,另外的一个线程如果想要申请写锁或读锁都是不可以的,都要等待写锁释放</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><blockquote>
<p>入门</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockConditionWayDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建同步锁对象</span></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//创建条件对象(控制线程间通信)</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">//操作数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data + 1 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doIncr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为了避免虚假唤醒问题：使用 while 结构进行循环判断</span></span><br><span class="line">            <span class="comment">// 判断当前线程是否满足执行核心操作的条件</span></span><br><span class="line">            <span class="keyword">while</span> (data == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 满足条件时，不该当前线程干活，所以进入等待状态</span></span><br><span class="line">                condition.await();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不满足上面的条件时，说明该当前线程干活了，所以执行核心操作</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行 + 1 操作，data = &quot;</span> + ++data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自己的任务完成后，叫醒其它线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data - 1 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doDecr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为了避免虚假唤醒问题：使用 while 结构进行循环判断</span></span><br><span class="line">            <span class="comment">// 判断当前线程是否满足执行核心操作的条件</span></span><br><span class="line">            <span class="keyword">while</span> (data == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 满足条件时，不该当前线程干活，所以进入等待状态</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不满足上面的条件时，说明该当前线程干活了，所以执行核心操作</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行 - 1 操作，data = &quot;</span> + --data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自己的任务完成后，叫醒其它线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建当前类的对象</span></span><br><span class="line">        <span class="type">LockConditionWayDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockConditionWayDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建四个线程，两个 + 1，两个 - 1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.doIncr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-add A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.doDecr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-sub A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.doIncr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-add B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.doDecr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-sub B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义线程间通信</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockConditionWayDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建同步锁对象</span></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//创建条件对象(控制线程间通信)</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (data % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                conditionA.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;A&quot;</span>);</span><br><span class="line">            data++;</span><br><span class="line">            conditionB.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (data % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                conditionB.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;B&quot;</span>);</span><br><span class="line">            data++;</span><br><span class="line">            conditionA.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建当前类的对象</span></span><br><span class="line">        <span class="type">LockConditionWayDemo1</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockConditionWayDemo1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                demo.toA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                demo.toB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="Lock-与-synchronized-对比"><a href="#Lock-与-synchronized-对比" class="headerlink" title="Lock 与 synchronized 对比"></a>Lock 与 synchronized 对比</h3><blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在实际开发时，如果synchronized能够满足需要，那就使用synchronized，毕竟它自动加锁、解锁，代码简单。</span><br><span class="line">如果synchronized无法满足需求，只能使用Lock。</span><br></pre></td></tr></table></figure>

<p>相同点</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.都支持独占锁</span><br><span class="line">2.都支持可重入</span><br></pre></td></tr></table></figure>

<p>不同点</p>
<table>
<thead>
<tr>
<th></th>
<th>Lock 系列 API 用法</th>
<th>synchronized 用法</th>
</tr>
</thead>
<tbody><tr>
<td>加锁/解锁</td>
<td>手动</td>
<td>自动</td>
</tr>
<tr>
<td>支持共享锁</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>支持尝试获取锁失败  <br>后执行特定操作</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>灵活</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>便捷</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>响应中断</td>
<td>lockInterruptibly()  <br>方式支持阻塞状态响应中断</td>
<td>sleep()  <br>睡眠后支持响应中断</td>
</tr>
<tr>
<td>代码风格</td>
<td>面向对象</td>
<td>面向过程</td>
</tr>
<tr>
<td>底层机制</td>
<td>AQS（volatile + CAS + 线程的双向链表）= 非阻塞同步</td>
<td>阻塞同步</td>
</tr>
</tbody></table>
</blockquote>
<h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><h3 id="锁膨胀机制"><a href="#锁膨胀机制" class="headerlink" title="锁膨胀机制"></a>锁膨胀机制</h3><blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在JDK1.6之前,synchronized锁的底层工作机制只有重量级锁,从1.6开始,为了减少重量级锁频繁的获得锁和释放锁带来的性能的消耗,所以引入了『偏向锁』和『轻量级锁』</span><br></pre></td></tr></table></figure>

<p>锁的状态</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.无锁</span><br><span class="line">锁所在的那个对象刚创建出来,还没有线程来执行同步代码块</span><br><span class="line">2.偏向锁</span><br><span class="line">只有唯一的一个线程来访问对象,没有必要获得锁和释放锁,例如世界就一个房子,没有必要锁门,我们只需要在这个对象头中的偏向锁的Mark Word结构中在thread上把这个线程的ID记录下来,等到这个线程下次再来,就无需获得锁,可以随意穿梭,省去大量关于锁的操作.</span><br><span class="line">3.轻量级锁</span><br><span class="line">当有第二个线程来申请锁,两个线程不存在竞争关系,一前一后交替执行同步块,</span><br><span class="line">4.重量级锁</span><br><span class="line">多个线程来竞争锁,各个线程之间存在竞争关系</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="对象存储结构"><a href="#对象存储结构" class="headerlink" title="对象存储结构"></a>对象存储结构</h3><blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.对象头</span><br><span class="line">非数组对象</span><br><span class="line">    Mark Word</span><br><span class="line">    类型指针</span><br><span class="line">数组</span><br><span class="line">    Mark Word</span><br><span class="line">    类型指针</span><br><span class="line">    数组长度</span><br><span class="line">2.对象体</span><br><span class="line">3.对齐字节</span><br></pre></td></tr></table></figure>

<p>对象头</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.分类</span><br><span class="line">==&gt;非数组对象 MarkWord, 类型指针</span><br><span class="line">==&gt;数组      MarkWord, 类型指针, 数组长度</span><br><span class="line">2.MarkWord</span><br><span class="line">对象的运行时信息,对不中不同的锁状态有五种不同的结构</span><br><span class="line">3.类型指针</span><br><span class="line">指向这个对象对应方法区的类</span><br><span class="line">4.数组长度</span><br></pre></td></tr></table></figure>

<p>对象体</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象本身的数据</span><br></pre></td></tr></table></figure>

<p>对齐字节</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">填充数据,让这个对象的大小为8字节的整数倍</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="MarkWord五种状态"><a href="#MarkWord五种状态" class="headerlink" title="MarkWord五种状态"></a>MarkWord五种状态</h3><blockquote>
<p>1.无锁</p>
<p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162057391.png" alt="image-20220916205753316"></p>
<p>2.偏向锁</p>
<p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162058607.png" alt="image-20220916205808541"></p>
<p>3.轻量级锁</p>
<p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162058209.png" alt="image-20220916205819138"></p>
<p>4.重量级锁</p>
<p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162058496.png" alt="image-20220916205828434"></p>
<p>5.GC</p>
<p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209162058173.png" alt="image-20220916205838107"></p>
</blockquote>
<h3 id="对象监视器"><a href="#对象监视器" class="headerlink" title="对象监视器"></a>对象监视器</h3><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>;  <span class="comment">// 锁计数器</span></span><br><span class="line">    _waiters      = <span class="number">0</span>;</span><br><span class="line">    _recursions   = <span class="number">0</span>; <span class="comment">// 锁的重入次数</span></span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL; <span class="comment">// 指向持有 ObjectMonitor 对象的线程</span></span><br><span class="line">    _WaitSet      = NULL; <span class="comment">// 处于 wait 状态的线程，会被加入到 _WaitSet（等待队列）</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">// 处于等待锁 block 状态的线程，会被加入到该列表（阻塞队列）</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Lock底层原理"><a href="#Lock底层原理" class="headerlink" title="Lock底层原理"></a>Lock底层原理</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote>
<p>概念</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.Java内存模型</span><br><span class="line">2.CPU和内存之间的一层高速缓存层,这个缓存层存在与CPU内</span><br><span class="line">3.CPU从高速缓存中读取数据,对数据修改后,再通过高速缓存区同步给内存</span><br></pre></td></tr></table></figure>

<p>Java内存模型</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.主内存</span><br><span class="line">各线程之间共享的数据区域</span><br><span class="line">2.本地内存</span><br><span class="line">每个线程自己私有的数据区域</span><br></pre></td></tr></table></figure>

<p>作用</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.为了解决缓存一致性的问题</span><br><span class="line">不同的线程会从主内存读取同一个数据,又做了不同的修改,那么各个线程从本地内存同步给主内存的时候,又以哪个线程的修改结果为准呢?这就是缓存一致性的问题</span><br></pre></td></tr></table></figure>

<p>缓存一致性涉及的三个具体问题</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.原子性</span><br><span class="line">2.可见性</span><br><span class="line">3.有序性</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote>
<p>概念</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.一个操作是不可分割的,拿我们就可以说这个操作是原子操作</span><br><span class="line">2.非原子性的操作会引发线程安全问题,比如i++,++i等,看似一步操作,实则底层有两步操作</span><br><span class="line">3.有例如再JMM内存结构中,两个线程同时读取主内存的数据,各自修改后push将修改的数据返回给主内存的时候,会出现数据覆盖现象,</span><br><span class="line"></span><br><span class="line">怎么解决</span><br><span class="line">1.使用同步锁</span><br><span class="line">2.使用Java的concurrent包下面的原子类</span><br></pre></td></tr></table></figure>

<p>使用同步锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将累加方法修改为同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; data = &quot;</span> + ++data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用原子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明成员变量作为操作对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 累加方法还是非同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; data = &quot;</span> + data.incrementAndGet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种解决方案的比较</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.当使用同步锁机制,先生产环境下,并发量的增加会导致锁的状态升级为重量级锁,重量级锁会涉及到锁的获取和释放,比较消耗性能</span><br><span class="line">2.原子类结合AQS和CAS使得减少消耗系统的性能</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><blockquote>
<p>概念</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.每个线程对自己本地内存的操作,其他线程是不可见的.</span><br><span class="line">2.使用volatile关键字修饰变量,可以使得一个线程对数据的修改是其他线程知道</span><br><span class="line">3.一个线程对本地内存数据的修改其他线程是否可见</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在CPU执行指令,JVM编译源程序之后,系统内部会进行指令重排.</span><br><span class="line">2.保证程序的运行结果一致的情况下,优化系统内部的效率</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><blockquote>
<p>概念</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.当一个线程对被volatile修饰的变量进行操作的时候,JMM会将该线程对应的本地内存的变量的值flush到主内存中</span><br><span class="line">2.当一个线程对被volatile修饰的变量的值进行读取操作时,JMM会将该线程的本地内存的变量只置为无效,然后再去读取主内存中的变量的值</span><br><span class="line">3.所以volatile关键字可以保证各个线程之间的变量值的操作时可见性的</span><br><span class="line">4.volatile关键字能保证有序性</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="CAS机制"><a href="#CAS机制" class="headerlink" title="CAS机制"></a>CAS机制</h3><blockquote>
<p>概念</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.比较交换</span><br><span class="line">2.原子类中我们大量的用到了CAS</span><br></pre></td></tr></table></figure>

<p>具体过程</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.当一个线程对本地内存中的数据进行修改的过程中,会调用Atomic原子类中的方法,方法又会调用Unsafe类对象中的方法进行操作,再调用这个类方法的时候会将此变量在主内存中的地址值和旧值和新值传入</span><br><span class="line">4.在Unsafe对象在进行操作的时候,会使用到CAS机制,先去找到主内存中地址值所对应的变量的值,然后再去判断旧值是否和主内存中的值是否一直.如果一致则将本地内存的旧值改为新值,再执行store指令将新值同步给主内存,然后再执行write指令将新值写入主内存对应的地址值中.</span><br><span class="line">5.如果CAS机制比较后值不相同,则不能修改,随后开始自旋,重新尝试修改</span><br></pre></td></tr></table></figure>

<p>非阻塞同步</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.不用阻塞线程就能达到同步的效果</span><br><span class="line"></span><br><span class="line">为什么AtomicInteger方式对比synchronized方式性能优势非常明显?</span><br><span class="line">1.AtomicInteger搭配CAS机制不需要阻塞线程就能达到同步的效果</span><br><span class="line">2.synchronized因为需要加锁解锁操作所以会比较慢,需要阻塞线程实现同步效果</span><br></pre></td></tr></table></figure>

<p>ABA问题</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个不允许线程执行的操作,因为数据发生的变化,又可以进行操作了</span><br><span class="line"></span><br><span class="line">解决方法</span><br><span class="line">1.加版本号</span><br></pre></td></tr></table></figure>

<p>AtomicInteger类</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">整合了CAS机制和volatile,解决了缓存不一致问题</span><br><span class="line"></span><br><span class="line">满足JMM三大特性</span><br><span class="line">1.原子性: 俺原子类嘞</span><br><span class="line">2.可见性: 有volatile</span><br><span class="line">3.有序性: 有volatile</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h3><blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.ReentrantLock是Lock接口最常用的一个实现类,这个实现类内部又有多个内部类,这几个内部类是公平锁和非公平锁等,我们一般默认使用的是非公平锁NonfairSync,NonfairSync继承了Sync,Sync继承了AQS,NonfairSync重写了夫类的tryAcquire方法</span><br><span class="line">2.当一个线程进入lock方法时候,会先判断是否有其他线程占用,如果没有,则将当前线程设置为独占,state值+1</span><br><span class="line">3.当一个线程再次进入lock方法的时候,此时发现当前资源已被其他线程占用,则进入else执行acquire(1);</span><br><span class="line">4.acquire方法内部执行if(!tryAcquire(arg) <span class="built_in">&amp;</span><span class="built_in">&amp;</span> acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">5.tryAcquire方法是本类重写的方法,tryAcquire方法又调用了父类Sync的nonfairTryAcquire()方法</span><br><span class="line">6.nonfairTryAcquire()方法中先再次判断了资源是否被独占,如果没有被独占,则当前线程就独占它</span><br><span class="line">7.如果还是被独占,那就判断独占的线程是不是自己本身,如果是的话,可重入次数+1,也就是state值+1</span><br><span class="line">8.如果不是自己,那就返回false;回到acquire方法执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">9.addWaiter方法中将当前线程封装成一个节点对象,然后判断双向链表最后一个节点是否有值,如果有值,就把最后一个节点向前移一位,自己放在最后一个节点上</span><br><span class="line">10.解锁的时候调用ReentrantLock的unlock方法,中调用Sync的tryRelease方法,state减去相应的值,释放锁</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="集合线程安全"><a href="#集合线程安全" class="headerlink" title="集合线程安全"></a>集合线程安全</h2><blockquote>
<p>List</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList</span><br><span class="line">1.使用写时复制技术,向集合中写入数据时,先把整个集合复制一份</span><br><span class="line">2.将新数据写入的复制的集合中</span><br><span class="line">3.再让旧集合变量指向新集合2</span><br><span class="line"></span><br><span class="line">优点：写操作还是要加独占锁(一个一个)，这方面没区别；读操作允许并发执行，效率提升。</span><br><span class="line">缺点：由于需要把集合对象整体复制一份，所以对内存的消耗很大</span><br></pre></td></tr></table></figure>

<p>Set</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArraySet</span><br><span class="line">//同理CopyOnWriteArrayList</span><br></pre></td></tr></table></figure>

<p>Map</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap</span><br><span class="line">加入锁分段技术</span><br><span class="line">1.将一个集合中的数据分段来加锁</span><br><span class="line">2.降低线程间的竞争概率</span><br><span class="line"></span><br><span class="line">假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="工具类和Fork-Join框架"><a href="#工具类和Fork-Join框架" class="headerlink" title="工具类和Fork-Join框架"></a>工具类和Fork-Join框架</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定一个操作步骤数量，在各个子线程中，每完成一个任务就给步骤数量 - 1；在步骤数量减到0之前，CountDownLatch 可以帮我们把最后一步操作抑制住（阻塞），让最后一步操作一直等到步骤被减到 0 的时候执行。</span><br></pre></td></tr></table></figure>

<p>班长锁门(有六名同学在值日，班长负责锁门。班长必须确保所有同学都离开教室再锁门)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个变量，用来保存同学的数量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">stuNum</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建CountDownLatch对象</span></span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(stuNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建和同学数量相等的线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stuNum; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> String.valueOf(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成一次操作</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + num + <span class="string">&quot;号同学离开教室&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让countDownLatch管理的数量-1</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让countDownLatch负责将最后一步操作抑制住</span></span><br><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;班长锁门&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>集齐七颗龙珠召唤神龙</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明龙珠数量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dragonBall</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建CountdownLatch对象</span></span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(dragonBall);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建七个线程收集龙珠</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;现在拿到了&quot;</span> + num + <span class="string">&quot;号龙珠&quot;</span>);</span><br><span class="line"></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让countDownLatch对象抑制最后一步</span></span><br><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;龙珠集齐，召唤神龙&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">支持多线程在执行各自任务的时候，到达某个状态点就等待，等所有线程都到达这个状态点再继续执行后步骤。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoO19CyclicBarrierTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; matrix = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        matrix.add(Arrays.asList(<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;special&quot;</span>,<span class="string">&quot;end&quot;</span>));</span><br><span class="line">        matrix.add(Arrays.asList(<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;special&quot;</span>,<span class="string">&quot;end&quot;</span>));</span><br><span class="line">        matrix.add(Arrays.asList(<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;special&quot;</span>,<span class="string">&quot;end&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建CyclicBarrier对象</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建3个线程分别执行各自的任务</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;String&gt; list = matrix.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String value : list) &#123;</span><br><span class="line"></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; value = &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;special&quot;</span>.equals(value)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遇到特殊任务标记，就让当前线程等一下</span></span><br><span class="line">                        barrier.await();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;thread01&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;String&gt; list = matrix.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String value : list) &#123;</span><br><span class="line"></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; value = &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;special&quot;</span>.equals(value)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遇到特殊任务标记，就让当前线程等一下</span></span><br><span class="line">                        barrier.await();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;thread02&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;String&gt; list = matrix.get(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String value : list) &#123;</span><br><span class="line"></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; value = &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;special&quot;</span>.equals(value)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遇到特殊任务标记，就让当前线程等一下</span></span><br><span class="line">                        barrier.await();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;thread03&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote>
<p>入门使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建 Semaphore 对象，指定资源数量为 3</span></span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建 10 个线程争夺这 3 个资源</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 申请资源</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拿到资源执行操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】号车辆【驶入】车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】号车辆【驶出】车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 操作完成释放资源</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, i + <span class="string">&quot;&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入超时机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、设定车位数量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">carPositionCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建 Semaphore 对象</span></span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(carPositionCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、创建 50 个线程抢车位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">carNum</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">acquireResult</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 线程开始时先申请资源，申请不到会进入等待状态</span></span><br><span class="line">            <span class="comment">// 申请资源方式一：不见不散，等不到资源就一直等</span></span><br><span class="line">            <span class="comment">// semaphore.acquire();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 申请资源方式二：过时不候</span></span><br><span class="line">            acquireResult = semaphore.tryAcquire(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (acquireResult) &#123;</span><br><span class="line">                <span class="comment">// 申请到资源时，线程会继续执行</span></span><br><span class="line">                System.out.println(carNum + <span class="string">&quot;号车辆驶入车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 车辆在车位停放一段时间</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 停放完成离开车位</span></span><br><span class="line">                System.out.println(carNum + <span class="string">&quot;号车辆驶出车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(carNum + <span class="string">&quot;号车辆放弃等待&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断当前线程释放拿到了资源</span></span><br><span class="line">            <span class="keyword">if</span> (acquireResult) &#123;</span><br><span class="line">                <span class="comment">// 任务执行完成释放资源</span></span><br><span class="line">                semaphore.release();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景举例</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">借助Semaphore实现『限流』操作。</span><br><span class="line"></span><br><span class="line">- 当前服务器实例能够承受多大的访问量——设置为资源的数量。</span><br><span class="line">- 根据资源的数量创建Semaphore对象。</span><br><span class="line">- 服务器实例接收到请求通过Semaphore对象管理处理请求数量。</span><br><span class="line">    - 在能力范围内：处理请求。</span><br><span class="line">    - 超过能力范围：设定等待时间，看是否能够得到别的请求处理完成释放资源。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork Join"></a>Fork Join</h3><blockquote>
<p>概念</p>
<p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209211809076.png" alt="image-20220921180905006"></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用 Fork Join 框架能够帮助我们把一个大型任务，根据一定规律，拆分成小任务执行。如果拆分后的任务还不够小，可以以递归模式继续拆分，直到拆分到可以执行的程度。然后再把各个子任务执行的结果汇总到一起。</span><br><span class="line"></span><br><span class="line">- Fork：拆分：把大任务拆分成小任务。</span><br><span class="line">- Join：合并：把小任务执行的结果合并到一起。</span><br></pre></td></tr></table></figure>

<p>框架中 API 介绍</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.RecursiveTask</span><br><span class="line">我们使用 Fork Join 框架只需要继承 RecursiveTask，然后重写 compute() 方法即可。在 compute() 方法中需要包含：</span><br><span class="line"></span><br><span class="line">- 任务拆分的逻辑</span><br><span class="line">- 任务拆分的操作：调用 fork() 方法</span><br><span class="line">- 已拆分任务的合并：调用 join() 方法</span><br><span class="line">- 子任务结果的合并：将 join() 方法的返回值合并起来</span><br><span class="line">2.ForkJoinTask</span><br><span class="line">ForkJoinTask 类是 RecursiveTask 的父类。</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.需求</span><br><span class="line">完成从 1~100 的累加。</span><br><span class="line">2.思路</span><br><span class="line">通过任务拆分、合并的方式来实现。拆分的逻辑是：</span><br><span class="line"></span><br><span class="line">- 将大范围数值累加拆分为小范围数值累加。</span><br><span class="line">- 在 1~10 区间范围内执行计算。</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间开始位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间结束位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间调整值：要通过拆分任务将区间调整到 10 以内</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ADJUST_VALUE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前任务的结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明构造器，设定当前任务的开始和结束位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、判断当前区间是否是原子任务中可以执行计算的范围</span></span><br><span class="line">        <span class="keyword">if</span> (end - begin &lt;= ADJUST_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;= end ; i++) &#123;</span><br><span class="line">                result  = result + i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、计算新拆分任务的区间范围</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftBegin</span> <span class="operator">=</span> begin;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftEnd</span> <span class="operator">=</span> (begin + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">rightBegin</span> <span class="operator">=</span> leftEnd + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightEnd</span> <span class="operator">=</span> end;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、创建两个新的任务（子任务）</span></span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">myTaskLeft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(leftBegin, leftEnd);</span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">myTaskRight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(rightBegin, rightEnd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、调用框架提供的 fork() 进一步拆分任务</span></span><br><span class="line">            myTaskLeft.fork();</span><br><span class="line">            myTaskRight.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5、调用框架提供的 join() 获取子任务计算的结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftResult</span> <span class="operator">=</span> (<span class="type">int</span>) myTaskLeft.join();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightResult</span> <span class="operator">=</span> (<span class="type">int</span>) myTaskRight.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6、把子任务的结果合并到一起</span></span><br><span class="line">            result = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建 Fork Join 任务池</span></span><br><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建任务对象</span></span><br><span class="line"><span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、将任务对象提交到任务池</span></span><br><span class="line"><span class="type">ForkJoinTask</span> <span class="variable">forkJoinTask</span> <span class="operator">=</span> pool.submit(myTask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、获取任务执行结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">finalResult</span> <span class="operator">=</span> (<span class="type">int</span>) forkJoinTask.get();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;finalResult = &quot;</span> + finalResult);</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">线程池就是一个容器,存放多个线程对象的容器,当我们需要用到线程的时候,只用区线程池拿就行,不需要new新的线程,可以节省开辟线程的空间,提高代码的效率.</span><br><span class="line">2.有哪些</span><br><span class="line">newCachedThreadPool</span><br><span class="line">线程会根据需要创建多线程,并可以重用之前创建的线程,可扩容,适合执行短期的异步任务.</span><br><span class="line">newFixedThreadPool(线程数)</span><br><span class="line">指定固定的线程数,适合执行长期的任务</span><br><span class="line">newScheduledThreadPool(线程数)</span><br><span class="line">指定固定的线程数,支持周期性的任务执行</span><br><span class="line">newSingleThreadExecutor</span><br><span class="line">一个任务一个任务的执行，一池一线程。</span><br><span class="line">3.实际开发</span><br><span class="line">在实际的开发中,我们采用由ThreadPoolExecutor自定义的线程池</span><br></pre></td></tr></table></figure>

<p>为什么</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程的主要作用就是为了控制线程的数量,在开发过程中,我们将需要线程处理的任务放入到队列中,等待线程创建之后启动这些在队列中排队的任务,如果队列已满,我们就将任务交由非核心线程处理,线程池的主要特点是在线程池中的线程能够复用,能够控制最大的并发数量,任务总数超过了核心线程和非核心线程的数量,那就拒绝这个任务,拒绝也有四种策略,一个是默认的,直接抛出异常,阻止线程池接受新的任务,还有一种是让任务从哪里来,回哪里去,不用抛弃自己的任务,也不用抛出异常,另一种是替换自己队列中等待最久的那个任务,最后一种是默默丢弃,不去抛异常,</span><br><span class="line">线程池中的线程的重复利用能够降低资源的消耗,任务不用去等待线程的创建才被执行,线程创建时间的减少可以提高任务的响应速度,也可以更好的管理线程,应为如果线程无限制,无休止的创建,反反复复,会影响到系统的性能,降低系统的稳定性,所以我们用线程池堆线程进行管理,提高可管理性.</span><br></pre></td></tr></table></figure>

<p>底层原理</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在线程池刚刚创建的时候,里面是没有任何线程的,等任务来的时候,才会创建线程,当然也可以调用方法提前创建线程,当提交一个任务的时候,如果还有空闲的核心线程数或还未被创建的核心线程数,那我们就直接用这个核心线程或创建这个核心线程执行我们的这个任务,如果没有空闲的核心线程,且队列没有满的情况下,我们就把这个任务放在核心线程中排队等待,等待有空闲的核心线程后来处理队列中排队的任务,如果队列已经满了,但非核心线程还有空闲,我们就用非核心线程去处理这个任务,核心线程和非核心线程的区别是,核心线程一直都存在,非核心线程在一定的时间内没干活了,那么这个非核心线程就会被停掉,线程池在创建了很多的非核心任务后,在任务量核心线程和队列能解决的情况下,会在一定的时间内停止掉非核心线程的数量,线程池中的线程数会慢慢缩减到核心线程的数量,当队列已满的情况下,再来任务,这个任务会被指定的拒绝策略拒绝掉.</span><br></pre></td></tr></table></figure>

<p>七大参数</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个类的构造器都有4个,其中一个构造器的参数数量是5个,其他的都是7个,在实际的开发中,我们一般中7个参数的构造器,这七个参数是线程池的核心线程数,线程池的最大线程数,非核心线程的空闲存活时间,存活时间的单位,任务的队列,创建线程池中线程的工厂,拒绝策略.</span><br></pre></td></tr></table></figure>

<p>核心线程数和最大线程数如何设置</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果线程主要执行的是计算的任务,CPU利用率高,核心线程数等于CPU核心数</span><br><span class="line">如果线程主要执行的是IO操作,CPU利用率不高,核心线程数等于2倍的CPU核心数</span><br><span class="line">最大线程数都设置为核心线程数+1</span><br></pre></td></tr></table></figure>

<p>拒绝策略都有哪些</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拒绝策略一般分为4种,第一种为直接抛出异常,程序结束.第二中为任务从哪个线程来,让它回哪里去.第三种为直接替换阻塞队列中最靠前的任务,直接插队上位.第四种为默默丢弃,直接丢弃任务</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="CompletableFuture-异步编排"><a href="#CompletableFuture-异步编排" class="headerlink" title="CompletableFuture(异步编排)"></a>CompletableFuture(异步编排)</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure>

<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="什么是线程池-有哪些-怎么创建"><a href="#什么是线程池-有哪些-怎么创建" class="headerlink" title="什么是线程池,有哪些,怎么创建?"></a>什么是线程池,有哪些,怎么创建?</h3><blockquote>
<blockquote>
<p>线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率</p>
<p>在 JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法。</p>
<p>ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</p>
<p>ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(4);</p>
<p>ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(4);</p>
<p>ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();</p>
<p>然后调用他们的 execute 方法即可。</p>
<p><strong>（<strong><strong>1</strong></strong>）****newCachedThreadPool</strong></p>
<p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是：</p>
<p>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</p>
<p>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p>
<p>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</p>
<p><strong>（<strong><strong>2</strong></strong>）****newFixedThreadPool</strong></p>
<p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>
<p><strong>（<strong><strong>3</strong></strong>）****newSingleThreadExecutor</strong></p>
<p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p>
<p><strong>（<strong><strong>4</strong></strong>）****newScheduleThreadPool</strong></p>
<p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行。例如延迟3秒执行。</p>
<p>这4种线程池底层 全部是ThreadPoolExecutor对象的实现，阿里规范手册中规定线程池采用ThreadPoolExecutor自定义的，实际开发也是。</p>
</blockquote>
<blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.是什么</span><br><span class="line">线程池就是一个容器,存放多个线程对象的容器,当我们需要用到线程的时候,只用区线程池拿就行,不需要new新的线程,可以节省开辟线程的空间,提高代码的效率.</span><br><span class="line">2.有哪些</span><br><span class="line">newCachedThreadPool</span><br><span class="line">线程会根据需要创建多线程,并可以重用之前创建的线程,可扩容,适合执行短期的异步任务.</span><br><span class="line">newFixedThreadPool(线程数)</span><br><span class="line">指定固定的线程数,适合执行长期的任务</span><br><span class="line">newScheduledThreadPool(线程数)</span><br><span class="line">指定固定的线程数,支持周期性的任务执行</span><br><span class="line">newSingleThreadExecutor</span><br><span class="line">一个任务一个任务的执行，一池一线程。</span><br><span class="line">3.实际开发</span><br><span class="line">在实际的开发中,我们采用由ThreadPoolExecutor自定义的线程池</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h3 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h3><blockquote>
<blockquote>
<p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最 大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p>
<p>主要特点:线程复用;控制最大并发数:管理线程。</p>
<p>第一:降低资源消耗。通过重复利用己创建的线程降低线程创建和销毁造成的消耗。</p>
<p>第二:提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</p>
<p>第三:提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进 行统一的分配，调优和监控</p>
</blockquote>
<blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程的主要作用就是为了控制线程的数量,在开发过程中,我们将需要线程处理的任务放入到队列中,等待线程创建之后启动这些在队列中排队的任务,如果队列已满,我们就将任务交由非核心线程处理,线程池的主要特点是在线程池中的线程能够复用,能够控制最大的并发数量,任务总数超过了核心线程和非核心线程的数量,那就拒绝这个任务,拒绝也有四种策略,一个是默认的,直接抛出异常,阻止线程池接受新的任务,还有一种是让任务从哪里来,回哪里去,不用抛弃自己的任务,也不用抛出异常,另一种是替换自己队列中等待最久的那个任务,最后一种是默默丢弃,不去抛异常,</span><br><span class="line">线程池中的线程的重复利用能够降低资源的消耗,任务不用去等待线程的创建才被执行,线程创建时间的减少可以提高任务的响应速度,也可以更好的管理线程,应为如果线程无限制,无休止的创建,反反复复,会影响到系统的性能,降低系统的稳定性,所以我们用线程池堆线程进行管理,提高可管理性.</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h3 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h3><blockquote>
<blockquote>
<p><img src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209161825865.png" alt="image-20220916182533785"></p>
<p>第一步：线程池刚创建的时候，里面没有任何线程，等到有任务过来的时候才会创建线程。当然也可以调用 prestartAllCoreThreads() 或者 prestartCoreThread() 方法预创建corePoolSize个线程</p>
<p>第二步：调用execute()提交一个任务时，如果当前的工作线程数&lt;corePoolSize，直接创建新的线程执行这个任务</p>
<p>第三步：如果当时工作线程数量&gt;=corePoolSize，会将任务放入任务队列中缓存</p>
<p>第四步：如果队列已满，并且线程池中工作线程的数量&lt;maximumPoolSize，还是会创建线程执行这个任务</p>
<p>第五步：如果队列已满，并且线程池中的线程已达到maximumPoolSize，这个时候会执行拒绝策略，JAVA线程池默认的策略是AbortPolicy，即抛出RejectedExecutionException异常</p>
</blockquote>
<blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在线程池刚刚创建的时候,里面是没有任何线程的,等任务来的时候,才会创建线程,当然也可以调用方法提前创建线程,当提交一个任务的时候,如果还有空闲的核心线程数或还未被创建的核心线程数,那我们就直接用这个核心线程或创建这个核心线程执行我们的这个任务,如果没有空闲的核心线程,且队列没有满的情况下,我们就把这个任务放在核心线程中排队等待,等待有空闲的核心线程后来处理队列中排队的任务,如果队列已经满了,但非核心线程还有空闲,我们就用非核心线程去处理这个任务,核心线程和非核心线程的区别是,核心线程一直都存在,非核心线程在一定的时间内没干活了,那么这个非核心线程就会被停掉,线程池在创建了很多的非核心任务后,在任务量核心线程和队列能解决的情况下,会在一定的时间内停止掉非核心线程的数量,线程池中的线程数会慢慢缩减到核心线程的数量,当队列已满的情况下,再来任务,这个任务会被指定的拒绝策略拒绝掉.</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h3 id="ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？"><a href="#ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？" class="headerlink" title="ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？"></a>ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？</h3><blockquote>
<blockquote>
<p><strong>参数与作用：</strong>共7个参数</p>
<p><strong>corePoolSize****：</strong>核心线程数，在ThreadPoolExecutor中有一个与它相关的配置：allowCoreThreadTimeOut（默认为false），当allowCoreThreadTimeOut为false时，核心线程会一直存活，哪怕是一直空闲着。而当allowCoreThreadTimeOut为true时核心线程空闲时间超过keepAliveTime时会被回收。</p>
<p><strong>maximumPoolSize****：</strong>最大线程数，线程池能容纳的最大线程数，当线程池中的线程达到最大时，此时添加任务将会采用拒绝策略，默认的拒绝策略是抛出一个运行时错误（RejectedExecutionException）。值得一提的是，当初始化时用的工作队列为LinkedBlockingDeque时，这个值将无效。</p>
<p><strong>keepAliveTime****：</strong>存活时间，当非核心空闲超过这个时间将被回收，同时空闲核心线程是否回收受allowCoreThreadTimeOut影响。</p>
<p><strong>unit****：</strong>keepAliveTime的单位。</p>
<p><strong>workQueue****：</strong>任务队列，常用有三种队列，即SynchronousQueue,LinkedBlockingDeque（无界队列）,ArrayBlockingQueue（有界队列）。</p>
<p><strong>threadFactory****：</strong>线程工厂，ThreadFactory是一个接口，用来创建worker。通过线程工厂可以对线程的一些属性进行定制。默认直接新建线程。</p>
<p><strong>RejectedExecutionHandler****：</strong>也是一个接口，只有一个方法，当线程池中的资源已经全部使用，添加新线程被拒绝时，会调用RejectedExecutionHandler的rejectedExecution法。</p>
<p>默认是抛出一个运行时异常。</p>
<p><strong>线程池大小设置：</strong></p>
<p><strong>核心线程</strong><br><strong>CPU密集型：核心线程数=CPU核心数(或 核心线程数=CPU核心数+1)</strong><br><strong>I/O密集型：核心线程数=2*CPU核心数（或 核心线程数=CPU核心数/（1-阻塞系数))</strong><br><strong>混合型：核心线程数=（线程等待时间/线程CPU时间+1）*CPU核心数</strong></p>
<p><strong>最大线程</strong><br><strong>IO密集型经验应用，最大线程设置为 2N+1 (N为CPU数量，下同)<br>CPU密集型应用，最大线程设置为 N+1</strong></p>
<ol>
<li>需要分析线程池执行的任务的特性： CPU 密集型还是 IO 密集型</li>
<li>每个任务执行的平均时长大概是多少，这个任务的执行时长可能还跟任务处理逻辑是否涉及到网络传输以及底层系统资源依赖有关系</li>
</ol>
<p>如果是 CPU 密集型，主要是执行计算任务，响应时间很快，cpu 一直在运行，这种任务 cpu的利用率很高，那么线程数的配置应该根据 CPU 核心数来决定，CPU 核心数=最大同时执行线程数，加入 CPU 核心数为 4，那么服务器最多能同时执行 4 个线程。过多的线程会导致上下文切换反而使得效率降低。那线程池的最大线程数可以配置为 cpu 核心数+1 如果是 IO 密集型，主要是进行 IO 操作，执行 IO 操作的时间较长，这是 cpu 出于空闲状态，导致 cpu 的利用率不高，这种情况下可以增加线程池的大小。这种情况下可以结合线程的等待时长来做判断，等待时间越高，那么线程数也相对越多。一般可以配置 cpu 核心数的 2 倍。</p>
<p>一个公式：线程池设定最佳线程数目 = （（线程池设定的线程等待时间+线程 CPU 时间）/<br> 线程 CPU 时间 ）* CPU 数目</p>
<p>这个公式的线程 cpu 时间是预估的程序单个线程在 cpu 上运行的时间（通常使用 loadrunner测试大量运行次数求出平均值）</p>
<p><strong>拒绝策略：</strong></p>
<p>1、AbortPolicy：直接抛出异常，默认策略；<br> 2、CallerRunsPolicy：用调用者所在的线程来执行任务；<br> 3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br> 4、DiscardPolicy：直接丢弃任务；<br> 当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务</p>
</blockquote>
<blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.ThreadPoolExecutor对象有那些参数</span><br><span class="line">这个类的构造器都有4个,其中一个构造器的参数数量是5个,其他的都是7个,在实际的开发中,我们一般中7个参数的构造器,这七个参数是线程池的核心线程数,线程池的最大线程数,非核心线程的空闲存活时间,存活时间的单位,任务的队列,创建线程池中线程的工厂,拒绝策略.</span><br><span class="line">2.核心线程数和最大线程数如何设置</span><br><span class="line">如果线程主要执行的是计算的任务,CPU利用率高,核心线程数等于CPU核心数</span><br><span class="line">如果线程主要执行的是IO操作,CPU利用率不高,核心线程数等于2倍的CPU核心数</span><br><span class="line">最大线程数都设置为核心线程数+1</span><br><span class="line">3.拒绝策略都有哪些</span><br><span class="line">拒绝策略一般分为4种,第一种为直接抛出异常,程序结束.第二中为任务从哪个线程来,让它回哪里去.第三种为直接替换阻塞队列中最靠前的任务,直接插队上位.第四种为默默丢弃,直接丢弃任务</span><br></pre></td></tr></table></figure>

</blockquote>
</blockquote>
<h3 id="常见线程安全的并发容器有哪些？"><a href="#常见线程安全的并发容器有哪些？" class="headerlink" title="常见线程安全的并发容器有哪些？"></a>常见线程安全的并发容器有哪些？</h3><blockquote>
<blockquote>
<p>CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap</p>
</blockquote>
<blockquote>
<p>CopyOnWriteArrayList、CopyOnWriteArraySet采用写时复制实现线程安全</p>
</blockquote>
<blockquote>
<p>ConcurrentHashMap采用分段锁的方式实现线程安全</p>
</blockquote>
<blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.List</span><br><span class="line">我们使用CopyOnWriteArrayList,采用写时复制实现线程的安全,先读操作把集合整个复制一份,在写入新的集合,最后让原来指向集合的变量全部指向新集合</span><br><span class="line">2.Set</span><br><span class="line">我们使用CopyOnWriteArraySet,也是采用了写时复制实现的线程安全,</span><br><span class="line">3.Map</span><br><span class="line">使用ConcurrentHashMap,采用的时分段锁实现的线程安全.</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h3 id="synchronized底层实现是什么？lock底层是什么？有什么区别？"><a href="#synchronized底层实现是什么？lock底层是什么？有什么区别？" class="headerlink" title="synchronized底层实现是什么？lock底层是什么？有什么区别？"></a>synchronized底层实现是什么？lock底层是什么？有什么区别？</h3><blockquote>
<blockquote>
<p><strong>Synchronized****原理：</strong></p>
<p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p>
<p>代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p>
<p><strong>Lock****原理：</strong></p>
<p> Lock的存储结构：一个int类型状态值（用于锁的状态变更），一个双向链表（用于存储等待中的线程） </p>
<p> Lock获取锁的过程：本质上是通过CAS来获取状态值修改，如果当场没获取到，会将该线程放在线程等待链表中。 </p>
<p> Lock释放锁的过程：修改状态值，调整等待链表。 </p>
<p> Lock大量使用CAS+自旋。因此根据CAS特性，lock建议使用在低锁冲突的情况下。</p>
<p><strong>Lock<strong><strong>与synchronized</strong></strong>的区别：</strong></p>
<p>\1. Lock的加锁和解锁都是由java代码配合native方法（调用操作系统的相关方法）实现的，而synchronize的加锁和解锁的过程是由JVM管理的</p>
<p>\2. 当一个线程使用synchronize获取锁时，若锁被其他线程占用着，那么当前只能被阻塞，直到成功获取锁。而Lock则提供超时锁和可中断等更加灵活的方式，在未能获取锁的   条件下提供一种退出的机制。</p>
<p>\3. 一个锁内部可以有多个Condition实例，即有多路条件队列，而synchronize只有一路条件队列；同样Condition也提供灵活的阻塞方式，在未获得通知之前可以通过中断线程以  及设置等待时限等方式退出条件队列。</p>
<p>\4. synchronize对线程的同步仅提供独占模式，而Lock即可以提供独占模式，也可以提供共享模式</p>
<table>
<thead>
<tr>
<th>synchronized</th>
<th>Lock</th>
</tr>
</thead>
<tbody><tr>
<td>关键字</td>
<td>类</td>
</tr>
<tr>
<td>自动加锁和释放锁</td>
<td>需要手动调用unlock方法释放锁</td>
</tr>
<tr>
<td>jvm层面的锁</td>
<td>API层面的锁</td>
</tr>
<tr>
<td>非公平锁</td>
<td>可以选择公平或者非公平锁</td>
</tr>
<tr>
<td>锁是一个对象,并且锁的信息保存在了对象中</td>
<td>代码中通过int类型的state标识</td>
</tr>
<tr>
<td>有一个锁升级的过程</td>
<td>无</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.synchronized底层原理</span><br><span class="line">Hotspot虚拟机中的对象结构中,一个在堆中的对象的结构可以分为对象头,对象体,对齐字节,对象头中存在MarkWorld,类型指针,在多线程争抢锁的环境下,MarkWorld会有一个指针指向一个特殊的对象监视器类,在这个对象监视器类的结构中记录了各种关于锁的信息.</span><br><span class="line">当一个线程的执行过程中,遇到了synchronized,它会先去判断锁对象的对象监视器中的<span class="built_in">_</span>count是否为0,如果是0,则当前锁对象是未锁定状态,执行monitorenter指令,对锁对象的对象监视器中的<span class="built_in">_</span>recursions线程重入次数+1,<span class="built_in">_</span>count线程锁的计数器+1,<span class="built_in">_</span>owner指向当前线程.如果对象的对象监视器中的<span class="built_in">_</span>count不为0,则就去判断对象监视器中的<span class="built_in">_</span>owner是否指向自己,如果指向自己,就执行monitorenter指令,如果不指向自己,那就让当前线程进入阻塞队列,在对象监视器中的<span class="built_in">_</span>EntryList记录当前线程</span><br><span class="line">2.lock底层原理</span><br><span class="line">1.ReentrantLock是Lock接口最常用的一个实现类,这个实现类内部又有多个内部类,这几个内部类是公平锁和非公平锁等,我们一般默认使用的是非公平锁NonfairSync,NonfairSync继承了Sync,Sync继承了AQS,NonfairSync重写了夫类的tryAcquire方法</span><br><span class="line">2.当一个线程进入lock方法时候,会先判断是否有其他线程占用,如果没有,则将当前线程设置为独占,state值+1</span><br><span class="line">3.当一个线程再次进入lock方法的时候,此时发现当前资源已被其他线程占用,则进入else执行acquire(1);</span><br><span class="line">4.acquire方法内部执行if(!tryAcquire(arg) <span class="built_in">&amp;</span><span class="built_in">&amp;</span> acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">5.tryAcquire方法是本类重写的方法,tryAcquire方法又调用了父类Sync的nonfairTryAcquire()方法</span><br><span class="line">6.nonfairTryAcquire()方法中先再次判断了资源是否被独占,如果没有被独占,则当前线程就独占它</span><br><span class="line">7.如果还是被独占,那就判断独占的线程是不是自己本身,如果是的话,可重入次数+1,也就是state值+1</span><br><span class="line">8.如果不是自己,那就返回false;回到acquire方法执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">9.addWaiter方法中将当前线程封装成一个节点对象,然后判断双向链表最后一个节点是否有值,如果有值,就把最后一个节点向前移一位,自己放在最后一个节点上</span><br><span class="line">10.解锁的时候调用ReentrantLock的unlock方法,中调用Sync的tryRelease方法,state减去相应的值,释放锁</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://fuqingsong.work">FuQingSong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://fuqingsong.work/archives/aa55683f.html">https://fuqingsong.work/archives/aa55683f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fuqingsong.work" target="_blank">小`白松</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC/">JUC</a></div><div class="post_share"><div class="social-share" data-image="https://ffuqingsong.gitee.io/pic-go-demo/img/202209211939330.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/archives/c383a3c4.html"><img class="next-cover" src="https://ffuqingsong.gitee.io/pic-go-demo/img/202209211939854.png" onerror="onerror=null;src='/img/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Nacos</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NzIxNS8zMzY3OQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">程序 进程 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C-%E5%B9%B6%E8%A1%8C-%E5%B9%B6%E5%8F%91"><span class="toc-number">1.2.</span> <span class="toc-text">串行 并行 并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E5%92%8Cwait-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">sleep()和wait()区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">2.</span> <span class="toc-text">多线程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">继承Thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.</span> <span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.3.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FutureTask-Callable"><span class="toc-number">2.4.</span> <span class="toc-text">FutureTask+Callable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock"><span class="toc-number">3.</span> <span class="toc-text">Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HelloWorld"><span class="toc-number">3.1.</span> <span class="toc-text">HelloWorld</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">3.3.</span> <span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">3.4.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">3.5.</span> <span class="toc-text">线程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock-%E4%B8%8E-synchronized-%E5%AF%B9%E6%AF%94"><span class="toc-number">3.6.</span> <span class="toc-text">Lock 与 synchronized 对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">synchronized底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">锁膨胀机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">对象存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MarkWord%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">4.3.</span> <span class="toc-text">MarkWord五种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9B%91%E8%A7%86%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">对象监视器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">Lock底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM"><span class="toc-number">5.1.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">5.1.2.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">5.1.3.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">5.1.4.</span> <span class="toc-text">有序性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.2.</span> <span class="toc-text">volatile关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">CAS机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">5.4.</span> <span class="toc-text">AQS源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">6.</span> <span class="toc-text">集合线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%92%8CFork-Join%E6%A1%86%E6%9E%B6"><span class="toc-number">7.</span> <span class="toc-text">工具类和Fork-Join框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">7.1.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">7.2.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-number">7.3.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fork-Join"><span class="toc-number">7.4.</span> <span class="toc-text">Fork Join</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-1"><span class="toc-number">8.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CompletableFuture-%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92"><span class="toc-number">9.</span> <span class="toc-text">CompletableFuture(异步编排)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E6%9C%89%E5%93%AA%E4%BA%9B-%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA"><span class="toc-number">10.1.</span> <span class="toc-text">什么是线程池,有哪些,怎么创建?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">10.2.</span> <span class="toc-text">为什么要使用线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">10.3.</span> <span class="toc-text">线程池底层工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%EF%BC%9F%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E6%80%8E%E4%B9%88%E8%AE%BE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%92%8C%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%9F%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">10.4.</span> <span class="toc-text">ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">10.5.</span> <span class="toc-text">常见线程安全的并发容器有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Flock%E5%BA%95%E5%B1%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.6.</span> <span class="toc-text">synchronized底层实现是什么？lock底层是什么？有什么区别？</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By FuQingSong</div><div class="footer_custom_text"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://beian.miit.gov.cn"><img class="icp-icon" src="https://ffuqingsong.gitee.io/pic-go-demo/img/security1.png"><span>备案号:豫ICP备2022018990号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><div class="aplayer no-destroy" data-id="7572694205" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="true"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>window.$crisp = [];
window.CRISP_WEBSITE_ID = "7ce6a135-3e53-461b-ba2b-cd0ea32778c4";
(function () {
  d = document;
  s = d.createElement("script");
  s.src = "https://client.crisp.chat/l.js";
  s.async = 1;
  d.getElementsByTagName("head")[0].appendChild(s);
})();
$crisp.push(["safe", true])

if (false) {
  $crisp.push(["do", "chat:hide"])
  $crisp.push(["on", "chat:closed", function() {
    $crisp.push(["do", "chat:hide"])
  }])
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])

    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      $crisp.push(["do", "chat:hide"])
    }
    function chatBtnShow () {
      $crisp.push(["do", "chat:show"])
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>